<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/s3/guid-6013a680-57f9-415b-8851-c4fa63356636/_vorbis___i__spec_8html_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:30 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Applications: examples/sfexamples/oggvorbiscodec/src/libvorbis/doc/Vorbis_I_spec.html Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/sfexamples/oggvorbiscodec/src/libvorbis/doc/Vorbis_I_spec.html</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=<span class="stringliteral">&quot;Content-Type&quot;</span> content=<span class="stringliteral">&quot;text/html; charset=ISO-8859-1&quot;</span>&gt;&lt;title&gt;Vorbis I specification&lt;/title&gt;&lt;meta name=<span class="stringliteral">&quot;generator&quot;</span> content=<span class="stringliteral">&quot;DocBook XSL Stylesheets V1.68.1&quot;</span>&gt;&lt;/head&gt;&lt;body bgcolor=<span class="stringliteral">&quot;white&quot;</span> text=<span class="stringliteral">&quot;black&quot;</span> link=<span class="stringliteral">&quot;#0000FF&quot;</span> vlink=<span class="stringliteral">&quot;#840084&quot;</span> alink=<span class="stringliteral">&quot;#0000FF&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;article&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h1 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2405333&quot;</span>&gt;&lt;/a&gt;Vorbis I specification&lt;/h1&gt;&lt;/div&gt;&lt;div&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;corpauthor&quot;</span>&gt;Xiph.org Foundation&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;hr&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;toc&quot;</span>&gt;&lt;p&gt;&lt;b&gt;Table of Contents&lt;/b&gt;&lt;/p&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-intro&quot;</span>&gt;1. Introduction and Description&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2519516&quot;</span>&gt;1.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2518126&quot;</span>&gt;1.2. Decoder Configuration&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2449172&quot;</span>&gt;1.3. High-level Decode Process&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-bitpacking&quot;</span>&gt;2. Bitpacking Convention&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2524173&quot;</span>&gt;2.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-codebook&quot;</span>&gt;3. Probability Model and Codebooks&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2523292&quot;</span>&gt;3.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2509016&quot;</span>&gt;3.2. Packed <a class="code" href="structcodebook.html">codebook</a> format&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2450655&quot;</span>&gt;3.3. Use of the <a class="code" href="structcodebook.html">codebook</a> abstraction&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-codec&quot;</span>&gt;4. Codec Setup and Packet Decode&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2512199&quot;</span>&gt;4.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2531940&quot;</span>&gt;4.2. Header decode and decode setup&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2545699&quot;</span>&gt;4.3. Audio packet decode and synthesis&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-comment&quot;</span>&gt;5. comment field and header specification&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2541891&quot;</span>&gt;5.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2541925&quot;</span>&gt;5.2. Comment encoding&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-floor0&quot;</span>&gt;6. Floor type 0 setup and decode&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2512128&quot;</span>&gt;6.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2505686&quot;</span>&gt;6.2. Floor 0 format&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-floor1&quot;</span>&gt;7. Floor type 1 setup and decode&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2541060&quot;</span>&gt;7.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2540135&quot;</span>&gt;7.2. Floor 1 format&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-residue&quot;</span>&gt;8. Residue setup and decode&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2524422&quot;</span>&gt;8.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2517330&quot;</span>&gt;8.2. Residue format&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2506346&quot;</span>&gt;8.3. residue 0&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2517602&quot;</span>&gt;8.4. residue 1&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2517633&quot;</span>&gt;8.5. residue 2&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2538870&quot;</span>&gt;8.6. Residue decode&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-helper&quot;</span>&gt;9. Helper equations&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2507758&quot;</span>&gt;9.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2512257&quot;</span>&gt;9.2. Functions&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-tables&quot;</span>&gt;10. Tables&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-spec-floor1_inverse_dB_table&quot;</span>&gt;10.1. floor1_inverse_dB_table&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;appendix&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-over-ogg&quot;</span>&gt;A. Embedding Vorbis into an Ogg stream&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2520211&quot;</span>&gt;A.1. Overview&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;&lt;dl&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2530380&quot;</span>&gt;A.1.1. Restrictions&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2512176&quot;</span>&gt;A.1.2. MIME type&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#id2520628&quot;</span>&gt;A.2. Encapsulation&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;appendix&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#vorbis-over-rtp&quot;</span>&gt;B. Vorbis encapsulation in RTP&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;appendix&quot;</span>&gt;&lt;a href=<span class="stringliteral">&quot;#footer&quot;</span>&gt;C. Colophon&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h2 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span> style=<span class="stringliteral">&quot;clear: both&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-intro&quot;</span>&gt;&lt;/a&gt;1. Introduction and Description&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p <span class="keyword">class</span>=<span class="stringliteral">&quot;releaseinfo&quot;</span>&gt;
<a name="l00002"></a>00002  $Id: 01-introduction.xml 7186 2004-07-20 07:19:25Z xiphmont $
<a name="l00003"></a>00003 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2519516&quot;</span>&gt;&lt;/a&gt;1.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00004"></a>00004 This document provides a high level description of the Vorbis codec<span class="stringliteral">&#39;s</span>
<a name="l00005"></a>00005 <span class="stringliteral">construction.  A bit-by-bit specification appears beginning in </span>
<a name="l00006"></a>00006 <span class="stringliteral">&lt;a href=&quot;#vorbis-spec-codec&quot; title=&quot;4. Codec Setup and Packet Decode&quot;&gt;Section 4, &amp;#8220;Codec Setup and Packet Decode&amp;#8221;&lt;/a&gt;.</span>
<a name="l00007"></a>00007 <span class="stringliteral">The later sections assume a high-level</span>
<a name="l00008"></a>00008 <span class="stringliteral">understanding of the Vorbis decode process, which is </span>
<a name="l00009"></a>00009 <span class="stringliteral">provided here.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2528250&quot;&gt;&lt;/a&gt;1.1.1. Application&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00010"></a>00010 <span class="stringliteral">Vorbis is a general purpose perceptual audio CODEC intended to allow</span>
<a name="l00011"></a>00011 <span class="stringliteral">maximum encoder flexibility, thus allowing it to scale competitively</span>
<a name="l00012"></a>00012 <span class="stringliteral">over an exceptionally wide range of bitrates.  At the high</span>
<a name="l00013"></a>00013 <span class="stringliteral">quality/bitrate end of the scale (CD or DAT rate stereo, 16/24 bits)</span>
<a name="l00014"></a>00014 <span class="stringliteral">it is in the same league as MPEG-2 and MPC.  Similarly, the 1.0</span>
<a name="l00015"></a>00015 <span class="stringliteral">encoder can encode high-quality CD and DAT rate stereo at below 48kbps</span>
<a name="l00016"></a>00016 <span class="stringliteral">without resampling to a lower rate.  Vorbis is also intended for</span>
<a name="l00017"></a>00017 <span class="stringliteral">lower and higher sample rates (from 8kHz telephony to 192kHz digital</span>
<a name="l00018"></a>00018 <span class="stringliteral">masters) and a range of channel representations (monaural,</span>
<a name="l00019"></a>00019 <span class="stringliteral">polyphonic, stereo, quadraphonic, 5.1, ambisonic, or up to 255</span>
<a name="l00020"></a>00020 <span class="stringliteral">discrete channels).</span>
<a name="l00021"></a>00021 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2525977&quot;&gt;&lt;/a&gt;1.1.2. Classification&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00022"></a>00022 <span class="stringliteral">Vorbis I is a forward-adaptive monolithic transform CODEC based on the</span>
<a name="l00023"></a>00023 <span class="stringliteral">Modified Discrete Cosine Transform.  The codec is structured to allow</span>
<a name="l00024"></a>00024 <span class="stringliteral">addition of a hybrid wavelet filterbank in Vorbis II to offer better</span>
<a name="l00025"></a>00025 <span class="stringliteral">transient response and reproduction using a transform better suited to</span>
<a name="l00026"></a>00026 <span class="stringliteral">localized time events.</span>
<a name="l00027"></a>00027 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2517154&quot;&gt;&lt;/a&gt;1.1.3. Assumptions&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00028"></a>00028 <span class="stringliteral">The Vorbis CODEC design assumes a complex, psychoacoustically-aware</span>
<a name="l00029"></a>00029 <span class="stringliteral">encoder and simple, low-complexity decoder. Vorbis decode is</span>
<a name="l00030"></a>00030 <span class="stringliteral">computationally simpler than mp3, although it does require more</span>
<a name="l00031"></a>00031 <span class="stringliteral">working memory as Vorbis has no static probability model; the vector</span>
<a name="l00032"></a>00032 <span class="stringliteral">codebooks used in the first stage of decoding from the bitstream are</span>
<a name="l00033"></a>00033 <span class="stringliteral">packed in their entirety into the Vorbis bitstream headers. In</span>
<a name="l00034"></a>00034 <span class="stringliteral">packed form, these codebooks occupy only a few kilobytes; the extent</span>
<a name="l00035"></a>00035 <span class="stringliteral">to which they are pre-decoded into a cache is the dominant factor in</span>
<a name="l00036"></a>00036 <span class="stringliteral">decoder memory usage.</span>
<a name="l00037"></a>00037 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00038"></a>00038 <span class="stringliteral">Vorbis provides none of its own framing, synchronization or protection</span>
<a name="l00039"></a>00039 <span class="stringliteral">against errors; it is solely a method of accepting input audio,</span>
<a name="l00040"></a>00040 <span class="stringliteral">dividing it into individual frames and compressing these frames into</span>
<a name="l00041"></a>00041 <span class="stringliteral">raw, unformatted &#39;</span>packets<span class="stringliteral">&#39;. The decoder then accepts these raw</span>
<a name="l00042"></a>00042 <span class="stringliteral">packets in sequence, decodes them, synthesizes audio frames from</span>
<a name="l00043"></a>00043 <span class="stringliteral">them, and reassembles the frames into a facsimile of the original</span>
<a name="l00044"></a>00044 <span class="stringliteral">audio stream. Vorbis is a free-form variable bit rate (VBR) codec and packets have no</span>
<a name="l00045"></a>00045 <span class="stringliteral">minimum size, maximum size, or fixed/expected size.  Packets</span>
<a name="l00046"></a>00046 <span class="stringliteral">are designed that they may be truncated (or padded) and remain</span>
<a name="l00047"></a>00047 <span class="stringliteral">decodable; this is not to be considered an error condition and is used</span>
<a name="l00048"></a>00048 <span class="stringliteral">extensively in bitrate management in peeling.  Both the transport</span>
<a name="l00049"></a>00049 <span class="stringliteral">mechanism and decoder must allow that a packet may be any size, or</span>
<a name="l00050"></a>00050 <span class="stringliteral">end before or after packet decode expects.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00051"></a>00051 <span class="stringliteral">Vorbis packets are thus intended to be used with a transport mechanism</span>
<a name="l00052"></a>00052 <span class="stringliteral">that provides free-form framing, sync, positioning and error correction</span>
<a name="l00053"></a>00053 <span class="stringliteral">in accordance with these design assumptions, such as Ogg (for file</span>
<a name="l00054"></a>00054 <span class="stringliteral">transport) or RTP (for network multicast).  For purposes of a few</span>
<a name="l00055"></a>00055 <span class="stringliteral">examples in this document, we will assume that Vorbis is to be</span>
<a name="l00056"></a>00056 <span class="stringliteral">embedded in an Ogg stream specifically, although this is by no means a</span>
<a name="l00057"></a>00057 <span class="stringliteral">requirement or fundamental assumption in the Vorbis design.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00058"></a>00058 <span class="stringliteral">The specification for embedding Vorbis into</span>
<a name="l00059"></a>00059 <span class="stringliteral">an Ogg transport stream is in &lt;a href=&quot;#vorbis-over-ogg&quot; title=&quot;A. Embedding Vorbis into an Ogg stream&quot;&gt;Appendix A, &lt;i&gt;Embedding Vorbis into an Ogg stream&lt;/i&gt;&lt;/a&gt;.</span>
<a name="l00060"></a>00060 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518614&quot;&gt;&lt;/a&gt;1.1.4. Codec Setup and Probability Model&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00061"></a>00061 <span class="stringliteral">Vorbis&#39;</span> heritage is as a research CODEC and its current design
<a name="l00062"></a>00062 reflects a desire to allow multiple decades of continuous encoder
<a name="l00063"></a>00063 improvement before running out of room within the codec specification.
<a name="l00064"></a>00064 For these reasons, configurable aspects of codec setup intentionally
<a name="l00065"></a>00065 lean toward the extreme of forward adaptive.&lt;/p&gt;&lt;p&gt;
<a name="l00066"></a>00066 The single most controversial design decision in Vorbis (and the most
<a name="l00067"></a>00067 unusual <span class="keywordflow">for</span> a Vorbis developer to keep in mind) is that the entire
<a name="l00068"></a>00068 probability model of the codec, the Huffman and VQ codebooks, is
<a name="l00069"></a>00069 packed into the bitstream header along with extensive CODEC setup
<a name="l00070"></a>00070 parameters (often several hundred fields).  This makes it impossible,
<a name="l00071"></a>00071 as it would be with MPEG audio layers, to embed a simple frame type
<a name="l00072"></a>00072 flag in each audio packet, or begin decode at any frame in the stream
<a name="l00073"></a>00073 without having previously fetched the codec setup header.
<a name="l00074"></a>00074 &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;note&quot;</span> style=<span class="stringliteral">&quot;margin-left: 0.5in; margin-right: 0.5in;&quot;</span>&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;Note&lt;/h3&gt;&lt;p&gt;
<a name="l00075"></a>00075 Vorbis &lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;emphasis&quot;</span>&gt;&lt;em&gt;can&lt;/em&gt;&lt;/span&gt; initiate decode at any arbitrary packet within a
<a name="l00076"></a>00076 bitstream so <span class="keywordtype">long</span> as the codec has been initialized/setup with the
<a name="l00077"></a>00077 setup headers.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00078"></a>00078 Thus, Vorbis headers are both required <span class="keywordflow">for</span> decode to begin and
<a name="l00079"></a>00079 relatively large as bitstream headers go.  The header size is
<a name="l00080"></a>00080 unbounded, although <span class="keywordflow">for</span> streaming a rule-of-thumb of 4kB or less is
<a name="l00081"></a>00081 recommended (and Xiph.Org<span class="stringliteral">&#39;s Vorbis encoder follows this suggestion).&lt;/p&gt;&lt;p&gt;</span>
<a name="l00082"></a>00082 <span class="stringliteral">Our own design work indicates the primary liability of the</span>
<a name="l00083"></a>00083 <span class="stringliteral">required header is in mindshare; it is an unusual design and thus</span>
<a name="l00084"></a>00084 <span class="stringliteral">causes some amount of complaint among engineers as this runs against</span>
<a name="l00085"></a>00085 <span class="stringliteral">current design trends (and also points out limitations in some</span>
<a name="l00086"></a>00086 <span class="stringliteral">existing software/interface designs, such as Windows&#39;</span> ACM codec
<a name="l00087"></a>00087 framework).  However, we find that it does not fundamentally limit
<a name="l00088"></a>00088 Vorbis<span class="stringliteral">&#39; suitable application space.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518094&quot;&gt;&lt;/a&gt;1.1.5. Format Specification&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00089"></a>00089 <span class="stringliteral">The Vorbis format is well-defined by its decode specification; any</span>
<a name="l00090"></a>00090 <span class="stringliteral">encoder that produces packets that are correctly decoded by the</span>
<a name="l00091"></a>00091 <span class="stringliteral">reference Vorbis decoder described below may be considered a proper</span>
<a name="l00092"></a>00092 <span class="stringliteral">Vorbis encoder.  A decoder must faithfully and completely implement</span>
<a name="l00093"></a>00093 <span class="stringliteral">the specification defined below (except where noted) to be considered</span>
<a name="l00094"></a>00094 <span class="stringliteral">a proper Vorbis decoder.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518110&quot;&gt;&lt;/a&gt;1.1.6. Hardware Profile&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00095"></a>00095 <span class="stringliteral">Although Vorbis decode is computationally simple, it may still run</span>
<a name="l00096"></a>00096 <span class="stringliteral">into specific limitations of an embedded design.  For this reason,</span>
<a name="l00097"></a>00097 <span class="stringliteral">embedded designs are allowed to deviate in limited ways from the</span>
<a name="l00098"></a>00098 <span class="stringliteral">&#39;</span>full<span class="stringliteral">&#39; decode specification yet still be certified compliant.  These</span>
<a name="l00099"></a>00099 <span class="stringliteral">optional omissions are labelled in the spec where relevant.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518126&quot;&gt;&lt;/a&gt;1.2. Decoder Configuration&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00100"></a>00100 <span class="stringliteral">Decoder setup consists of configuration of multiple, self-contained</span>
<a name="l00101"></a>00101 <span class="stringliteral">component abstractions that perform specific functions in the decode</span>
<a name="l00102"></a>00102 <span class="stringliteral">pipeline.  Each different component instance of a specific type is</span>
<a name="l00103"></a>00103 <span class="stringliteral">semantically interchangeable; decoder configuration consists both of</span>
<a name="l00104"></a>00104 <span class="stringliteral">internal component configuration, as well as arrangement of specific</span>
<a name="l00105"></a>00105 <span class="stringliteral">instances into a decode pipeline.  Componentry arrangement is roughly</span>
<a name="l00106"></a>00106 <span class="stringliteral">as follows:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;components.png&quot; alt=&quot;decoder pipeline configuration&quot;&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518164&quot;&gt;&lt;/a&gt;1.2.1. Global Config&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00107"></a>00107 <span class="stringliteral">Global codec configuration consists of a few audio related fields</span>
<a name="l00108"></a>00108 <span class="stringliteral">(sample rate, channels), Vorbis version (always &#39;</span>0<span class="stringliteral">&#39; in Vorbis I),</span>
<a name="l00109"></a>00109 <span class="stringliteral">bitrate hints, and the lists of component instances.  All other</span>
<a name="l00110"></a>00110 <span class="stringliteral">configuration is in the context of specific components.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518178&quot;&gt;&lt;/a&gt;1.2.2. Mode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00111"></a>00111 <span class="stringliteral">Each Vorbis frame is coded according to a master &#39;</span>mode<span class="stringliteral">&#39;.  A bitstream</span>
<a name="l00112"></a>00112 <span class="stringliteral">may use one or many modes.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00113"></a>00113 <span class="stringliteral">The mode mechanism is used to encode a frame according to one of</span>
<a name="l00114"></a>00114 <span class="stringliteral">multiple possible methods with the intention of choosing a method best</span>
<a name="l00115"></a>00115 <span class="stringliteral">suited to that frame.  Different modes are, e.g. how frame size</span>
<a name="l00116"></a>00116 <span class="stringliteral">is changed from frame to frame. The mode number of a frame serves as a</span>
<a name="l00117"></a>00117 <span class="stringliteral">top level configuration switch for all other specific aspects of frame</span>
<a name="l00118"></a>00118 <span class="stringliteral">decode.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00119"></a>00119 <span class="stringliteral">A &#39;</span>mode<span class="stringliteral">&#39; configuration consists of a frame size setting, window type</span>
<a name="l00120"></a>00120 <span class="stringliteral">(always 0, the Vorbis window, in Vorbis I), transform type (always</span>
<a name="l00121"></a>00121 <span class="stringliteral">type 0, the MDCT, in Vorbis I) and a mapping number.  The mapping</span>
<a name="l00122"></a>00122 <span class="stringliteral">number specifies which mapping configuration instance to use for</span>
<a name="l00123"></a>00123 <span class="stringliteral">low-level packet decode and synthesis.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518208&quot;&gt;&lt;/a&gt;1.2.3. Mapping&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00124"></a>00124 <span class="stringliteral">A mapping contains a channel coupling description and a list of</span>
<a name="l00125"></a>00125 <span class="stringliteral">&#39;</span>submaps<span class="stringliteral">&#39; that bundle sets of channel vectors together for grouped</span>
<a name="l00126"></a>00126 <span class="stringliteral">encoding and decoding. These submaps are not references to external</span>
<a name="l00127"></a>00127 <span class="stringliteral">components; the submap list is internal and specific to a mapping.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00128"></a>00128 <span class="stringliteral">A &#39;</span>submap<span class="stringliteral">&#39; is a configuration/grouping that applies to a subset of</span>
<a name="l00129"></a>00129 <span class="stringliteral">floor and residue vectors within a mapping.  The submap functions as a</span>
<a name="l00130"></a>00130 <span class="stringliteral">last layer of indirection such that specific special floor or residue</span>
<a name="l00131"></a>00131 <span class="stringliteral">settings can be applied not only to all the vectors in a given mode,</span>
<a name="l00132"></a>00132 <span class="stringliteral">but also specific vectors in a specific mode.  Each submap specifies</span>
<a name="l00133"></a>00133 <span class="stringliteral">the proper floor and residue instance number to use for decoding that</span>
<a name="l00134"></a>00134 <span class="stringliteral">submap&#39;</span>s spectral floor and spectral residue vectors.&lt;/p&gt;&lt;p&gt;
<a name="l00135"></a>00135 As an example:&lt;/p&gt;&lt;p&gt;
<a name="l00136"></a>00136 Assume a Vorbis stream that contains six channels in the standard 5.1
<a name="l00137"></a>00137 format.  The sixth channel, as is normal in 5.1, is bass only.
<a name="l00138"></a>00138 Therefore it would be wasteful to encode a full-spectrum version of it
<a name="l00139"></a>00139 as with the other channels.  The submapping mechanism can be used to
<a name="l00140"></a>00140 apply a full range floor and residue encoding to channels 0 through 4,
<a name="l00141"></a>00141 and a bass-only representation to the bass channel, thus saving space.
<a name="l00142"></a>00142 In <span class="keyword">this</span> example, channels 0-4 belong to submap 0 (which indicates use
<a name="l00143"></a>00143 of a full-range floor) and channel 5 belongs to submap 1, which uses a
<a name="l00144"></a>00144 bass-only representation.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2462918&quot;</span>&gt;&lt;/a&gt;1.2.4. Floor&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00145"></a>00145 Vorbis encodes a spectral <span class="stringliteral">&#39;floor&#39;</span> vector <span class="keywordflow">for each</span> PCM channel.  This
<a name="l00146"></a>00146 vector is a low-resolution representation of the audio spectrum <span class="keywordflow">for</span>
<a name="l00147"></a>00147 the given channel in the current frame, generally used akin to a
<a name="l00148"></a>00148 whitening filter.  It is named a <span class="stringliteral">&#39;floor&#39;</span> because the Xiph.Org
<a name="l00149"></a>00149 reference encoder has historically used it as a unit-baseline <span class="keywordflow">for</span>
<a name="l00150"></a>00150 spectral resolution.&lt;/p&gt;&lt;p&gt;
<a name="l00151"></a>00151 A floor encoding may be of two types.  Floor 0 uses a packed LSP
<a name="l00152"></a>00152 representation on a dB amplitude scale and Bark frequency scale.
<a name="l00153"></a>00153 Floor 1 represents the curve as a piecewise linear interpolated
<a name="l00154"></a>00154 representation on a dB amplitude scale and linear frequency scale.
<a name="l00155"></a>00155 The two floors are semantically interchangeable in
<a name="l00156"></a>00156 encoding/decoding. However, floor type 1 provides more stable
<a name="l00157"></a>00157 inter-frame behavior, and so is the preferred choice in all
<a name="l00158"></a>00158 coupled-stereo and high bitrate modes.  Floor 1 is also considerably
<a name="l00159"></a>00159 less expensive to decode than floor 0.&lt;/p&gt;&lt;p&gt;
<a name="l00160"></a>00160 Floor 0 is not to be considered deprecated, but it is of limited
<a name="l00161"></a>00161 modern use.  No known Vorbis encoder past Xiph.org<span class="stringliteral">&#39;s own beta 4 makes</span>
<a name="l00162"></a>00162 <span class="stringliteral">use of floor 0.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00163"></a>00163 <span class="stringliteral">The values coded/decoded by a floor are both compactly formatted and</span>
<a name="l00164"></a>00164 <span class="stringliteral">make use of entropy coding to save space.  For this reason, a floor</span>
<a name="l00165"></a>00165 <span class="stringliteral">configuration generally refers to multiple codebooks in the codebook</span>
<a name="l00166"></a>00166 <span class="stringliteral">component list.  Entropy coding is thus provided as an abstraction,</span>
<a name="l00167"></a>00167 <span class="stringliteral">and each floor instance may choose from any and all available</span>
<a name="l00168"></a>00168 <span class="stringliteral">codebooks when coding/decoding.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518290&quot;&gt;&lt;/a&gt;1.2.5. Residue&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00169"></a>00169 <span class="stringliteral">The spectral residue is the fine structure of the audio spectrum</span>
<a name="l00170"></a>00170 <span class="stringliteral">once the floor curve has been subtracted out.  In simplest terms, it</span>
<a name="l00171"></a>00171 <span class="stringliteral">is coded in the bitstream using cascaded (multi-pass) vector</span>
<a name="l00172"></a>00172 <span class="stringliteral">quantization according to one of three specific packing/coding</span>
<a name="l00173"></a>00173 <span class="stringliteral">algorithms numbered 0 through 2.  The packing algorithm details are</span>
<a name="l00174"></a>00174 <span class="stringliteral">configured by residue instance.  As with the floor components, the</span>
<a name="l00175"></a>00175 <span class="stringliteral">final VQ/entropy encoding is provided by external codebook instances</span>
<a name="l00176"></a>00176 <span class="stringliteral">and each residue instance may choose from any and all available</span>
<a name="l00177"></a>00177 <span class="stringliteral">codebooks.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2518309&quot;&gt;&lt;/a&gt;1.2.6. Codebooks&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00178"></a>00178 <span class="stringliteral">Codebooks are a self-contained abstraction that perform entropy</span>
<a name="l00179"></a>00179 <span class="stringliteral">decoding and, optionally, use the entropy-decoded integer value as an</span>
<a name="l00180"></a>00180 <span class="stringliteral">offset into an index of output value vectors, returning the indicated</span>
<a name="l00181"></a>00181 <span class="stringliteral">vector of values.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00182"></a>00182 <span class="stringliteral">The entropy coding in a Vorbis I codebook is provided by a standard</span>
<a name="l00183"></a>00183 <span class="stringliteral">Huffman binary tree representation.  This tree is tightly packed using</span>
<a name="l00184"></a>00184 <span class="stringliteral">one of several methods, depending on whether codeword lengths are</span>
<a name="l00185"></a>00185 <span class="stringliteral">ordered or unordered, or the tree is sparse.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00186"></a>00186 <span class="stringliteral">The codebook vector index is similarly packed according to index</span>
<a name="l00187"></a>00187 <span class="stringliteral">characteristic.  Most commonly, the vector index is encoded as a</span>
<a name="l00188"></a>00188 <span class="stringliteral">single list of values of possible values that are then permuted into</span>
<a name="l00189"></a>00189 <span class="stringliteral">a list of n-dimensional rows (lattice VQ).&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449172&quot;&gt;&lt;/a&gt;1.3. High-level Decode Process&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449178&quot;&gt;&lt;/a&gt;1.3.1. Decode Setup&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00190"></a>00190 <span class="stringliteral">Before decoding can begin, a decoder must initialize using the</span>
<a name="l00191"></a>00191 <span class="stringliteral">bitstream headers matching the stream to be decoded.  Vorbis uses</span>
<a name="l00192"></a>00192 <span class="stringliteral">three header packets; all are required, in-order, by this</span>
<a name="l00193"></a>00193 <span class="stringliteral">specification. Once set up, decode may begin at any audio packet</span>
<a name="l00194"></a>00194 <span class="stringliteral">belonging to the Vorbis stream. In Vorbis I, all packets after the</span>
<a name="l00195"></a>00195 <span class="stringliteral">three initial headers are audio packets. &lt;/p&gt;&lt;p&gt;</span>
<a name="l00196"></a>00196 <span class="stringliteral">The header packets are, in order, the identification</span>
<a name="l00197"></a>00197 <span class="stringliteral">header, the comments header, and the setup header.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449199&quot;&gt;&lt;/a&gt;1.3.1.1. Identification Header&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00198"></a>00198 <span class="stringliteral">The identification header identifies the bitstream as Vorbis, Vorbis</span>
<a name="l00199"></a>00199 <span class="stringliteral">version, and the simple audio characteristics of the stream such as</span>
<a name="l00200"></a>00200 <span class="stringliteral">sample rate and number of channels.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449212&quot;&gt;&lt;/a&gt;1.3.1.2. Comment Header&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00201"></a>00201 <span class="stringliteral">The comment header includes user text comments (&quot;tags&quot;) and a vendor</span>
<a name="l00202"></a>00202 <span class="stringliteral">string for the application/library that produced the bitstream.  The</span>
<a name="l00203"></a>00203 <span class="stringliteral">encoding and proper use of the comment header is described in </span>
<a name="l00204"></a>00204 <span class="stringliteral">&lt;a href=&quot;#vorbis-spec-comment&quot; title=&quot;5. comment field and header specification&quot;&gt;Section 5, &amp;#8220;comment field and header specification&amp;#8221;&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449230&quot;&gt;&lt;/a&gt;1.3.1.3. Setup Header&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00205"></a>00205 <span class="stringliteral">The setup header includes extensive CODEC setup information as well as</span>
<a name="l00206"></a>00206 <span class="stringliteral">the complete VQ and Huffman codebooks needed for decode.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449243&quot;&gt;&lt;/a&gt;1.3.2. Decode Procedure&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;highlights&quot;&gt;&lt;p&gt;</span>
<a name="l00207"></a>00207 <span class="stringliteral">The decoding and synthesis procedure for all audio packets is</span>
<a name="l00208"></a>00208 <span class="stringliteral">fundamentally the same.</span>
<a name="l00209"></a>00209 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;decode packet type flag&lt;/li&gt;&lt;li&gt;decode mode number&lt;/li&gt;&lt;li&gt;decode window shape (long windows only)&lt;/li&gt;&lt;li&gt;decode floor&lt;/li&gt;&lt;li&gt;decode residue into residue vectors&lt;/li&gt;&lt;li&gt;inverse channel coupling of residue vectors&lt;/li&gt;&lt;li&gt;generate floor curve from decoded floor data&lt;/li&gt;&lt;li&gt;compute dot product of floor and residue, producing audio spectrum vector&lt;/li&gt;&lt;li&gt;inverse monolithic transform of audio spectrum vector, always an MDCT in Vorbis I&lt;/li&gt;&lt;li&gt;overlap/add left-hand output of transform with right-hand output of previous frame&lt;/li&gt;&lt;li&gt;store right hand-data from transform of current frame for future lapping&lt;/li&gt;&lt;li&gt;if not first frame, return results of overlap/add as audio result of current frame&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00210"></a>00210 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00211"></a>00211 <span class="stringliteral">Note that clever rearrangement of the synthesis arithmetic is</span>
<a name="l00212"></a>00212 <span class="stringliteral">possible; as an example, one can take advantage of symmetries in the</span>
<a name="l00213"></a>00213 <span class="stringliteral">MDCT to store the right-hand transform data of a partial MDCT for a</span>
<a name="l00214"></a>00214 <span class="stringliteral">50% inter-frame buffer space savings, and then complete the transform</span>
<a name="l00215"></a>00215 <span class="stringliteral">later before overlap/add with the next frame.  This optimization</span>
<a name="l00216"></a>00216 <span class="stringliteral">produces entirely equivalent output and is naturally perfectly legal.</span>
<a name="l00217"></a>00217 <span class="stringliteral">The decoder must be &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;entirely mathematically equivalent&lt;/em&gt;&lt;/span&gt; to the</span>
<a name="l00218"></a>00218 <span class="stringliteral">specification, it need not be a literal semantic implementation.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449344&quot;&gt;&lt;/a&gt;1.3.2.1. Packet type decode&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00219"></a>00219 <span class="stringliteral">Vorbis I uses four packet types. The first three packet types mark each</span>
<a name="l00220"></a>00220 <span class="stringliteral">of the three Vorbis headers described above. The fourth packet type</span>
<a name="l00221"></a>00221 <span class="stringliteral">marks an audio packet. All other packet types are reserved; packets</span>
<a name="l00222"></a>00222 <span class="stringliteral">marked with a reserved type should be ignored.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00223"></a>00223 <span class="stringliteral">Following the three header packets, all packets in a Vorbis I stream</span>
<a name="l00224"></a>00224 <span class="stringliteral">are audio.  The first step of audio packet decode is to read and</span>
<a name="l00225"></a>00225 <span class="stringliteral">verify the packet type; &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;a non-audio packet when audio is expected</span>
<a name="l00226"></a>00226 <span class="stringliteral">indicates stream corruption or a non-compliant stream. The decoder</span>
<a name="l00227"></a>00227 <span class="stringliteral">must ignore the packet and not attempt decoding it to</span>
<a name="l00228"></a>00228 <span class="stringliteral">audio&lt;/em&gt;&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2449370&quot;&gt;&lt;/a&gt;1.3.2.2. Mode decode&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00229"></a>00229 <span class="stringliteral">Vorbis allows an encoder to set up multiple, numbered packet &#39;</span>modes<span class="stringliteral">&#39;,</span>
<a name="l00230"></a>00230 <span class="stringliteral">as described earlier, all of which may be used in a given Vorbis</span>
<a name="l00231"></a>00231 <span class="stringliteral">stream. The mode is encoded as an integer used as a direct offset into</span>
<a name="l00232"></a>00232 <span class="stringliteral">the mode instance index. &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;vorbis-spec-window&quot;&gt;&lt;/a&gt;1.3.2.3. Window shape decode (long windows only)&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00233"></a>00233 <span class="stringliteral">Vorbis frames may be one of two PCM sample sizes specified during</span>
<a name="l00234"></a>00234 <span class="stringliteral">codec setup.  In Vorbis I, legal frame sizes are powers of two from 64</span>
<a name="l00235"></a>00235 <span class="stringliteral">to 8192 samples.  Aside from coupling, Vorbis handles channels as</span>
<a name="l00236"></a>00236 <span class="stringliteral">independent vectors and these frame sizes are in samples per channel.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00237"></a>00237 <span class="stringliteral">Vorbis uses an overlapping transform, namely the MDCT, to blend one</span>
<a name="l00238"></a>00238 <span class="stringliteral">frame into the next, avoiding most inter-frame block boundary</span>
<a name="l00239"></a>00239 <span class="stringliteral">artifacts.  The MDCT output of one frame is windowed according to MDCT</span>
<a name="l00240"></a>00240 <span class="stringliteral">requirements, overlapped 50% with the output of the previous frame and</span>
<a name="l00241"></a>00241 <span class="stringliteral">added.  The window shape assures seamless reconstruction.  &lt;/p&gt;&lt;p&gt;</span>
<a name="l00242"></a>00242 <span class="stringliteral">This is easy to visualize in the case of equal sized-windows:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;window1.png&quot; alt=&quot;overlap of two equal-sized windows&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00243"></a>00243 <span class="stringliteral">And slightly more complex in the case of overlapping unequal sized</span>
<a name="l00244"></a>00244 <span class="stringliteral">windows:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;window2.png&quot; alt=&quot;overlap of a long and a short window&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00245"></a>00245 <span class="stringliteral">In the unequal-sized window case, the window shape of the long window</span>
<a name="l00246"></a>00246 <span class="stringliteral">must be modified for seamless lapping as above.  It is possible to</span>
<a name="l00247"></a>00247 <span class="stringliteral">correctly infer window shape to be applied to the current window from</span>
<a name="l00248"></a>00248 <span class="stringliteral">knowing the sizes of the current, previous and next window.  It is</span>
<a name="l00249"></a>00249 <span class="stringliteral">legal for a decoder to use this method. However, in the case of a long</span>
<a name="l00250"></a>00250 <span class="stringliteral">window (short windows require no modification), Vorbis also codes two</span>
<a name="l00251"></a>00251 <span class="stringliteral">flag bits to specify pre- and post- window shape.  Although not</span>
<a name="l00252"></a>00252 <span class="stringliteral">strictly necessary for function, this minor redundancy allows a packet</span>
<a name="l00253"></a>00253 <span class="stringliteral">to be fully decoded to the point of lapping entirely independently of</span>
<a name="l00254"></a>00254 <span class="stringliteral">any other packet, allowing easier abstraction of decode layers as well</span>
<a name="l00255"></a>00255 <span class="stringliteral">as allowing a greater level of easy parallelism in encode and</span>
<a name="l00256"></a>00256 <span class="stringliteral">decode.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00257"></a>00257 <span class="stringliteral">A description of valid window functions for use with an inverse MDCT</span>
<a name="l00258"></a>00258 <span class="stringliteral">can be found in the paper </span>
<a name="l00259"></a>00259 <span class="stringliteral">&amp;#8220;&lt;span class=&quot;citetitle&quot;&gt;</span>
<a name="l00260"></a>00260 <span class="stringliteral">&lt;a href=&quot;http://www.iocon.com/resource/docs/ps/eusipco_corrected.ps&quot; target=&quot;_top&quot;&gt;</span>
<a name="l00261"></a>00261 <span class="stringliteral">The use of multirate filter banks for coding of high quality digital</span>
<a name="l00262"></a>00262 <span class="stringliteral">audio&lt;/a&gt;&lt;/span&gt;&amp;#8221;, by T. Sporer, K. Brandenburg and B. Edler.  Vorbis windows</span>
<a name="l00263"></a>00263 <span class="stringliteral">all use the slope function </span>
<a name="l00264"></a>00264 <span class="stringliteral">  &lt;span class=&quot;inlinemediaobject&quot;&gt;&lt;/span&gt;.</span>
<a name="l00265"></a>00265 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450128&quot;&gt;&lt;/a&gt;1.3.2.4. floor decode&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00266"></a>00266 <span class="stringliteral">Each floor is encoded/decoded in channel order, however each floor</span>
<a name="l00267"></a>00267 <span class="stringliteral">belongs to a &#39;</span>submap<span class="stringliteral">&#39; that specifies which floor configuration to</span>
<a name="l00268"></a>00268 <span class="stringliteral">use.  All floors are decoded before residue decode begins.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450140&quot;&gt;&lt;/a&gt;1.3.2.5. residue decode&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00269"></a>00269 <span class="stringliteral">Although the number of residue vectors equals the number of channels,</span>
<a name="l00270"></a>00270 <span class="stringliteral">channel coupling may mean that the raw residue vectors extracted</span>
<a name="l00271"></a>00271 <span class="stringliteral">during decode do not map directly to specific channels.  When channel</span>
<a name="l00272"></a>00272 <span class="stringliteral">coupling is in use, some vectors will correspond to coupled magnitude</span>
<a name="l00273"></a>00273 <span class="stringliteral">or angle.  The coupling relationships are described in the codec setup</span>
<a name="l00274"></a>00274 <span class="stringliteral">and may differ from frame to frame, due to different mode numbers.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00275"></a>00275 <span class="stringliteral">Vorbis codes residue vectors in groups by submap; the coding is done</span>
<a name="l00276"></a>00276 <span class="stringliteral">in submap order from submap 0 through n-1.  This differs from floors</span>
<a name="l00277"></a>00277 <span class="stringliteral">which are coded using a configuration provided by submap number, but</span>
<a name="l00278"></a>00278 <span class="stringliteral">are coded individually in channel order.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450165&quot;&gt;&lt;/a&gt;1.3.2.6. inverse channel coupling&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00279"></a>00279 <span class="stringliteral">A detailed discussion of stereo in the Vorbis codec can be found in</span>
<a name="l00280"></a>00280 <span class="stringliteral">the document &lt;a href=&quot;stereo.html&quot; target=&quot;_top&quot;&gt;&lt;em class=&quot;citetitle&quot;&gt;Stereo Channel Coupling in the</span>
<a name="l00281"></a>00281 <span class="stringliteral">Vorbis CODEC&lt;/em&gt;&lt;/a&gt;.  Vorbis is not limited to only stereo coupling, but</span>
<a name="l00282"></a>00282 <span class="stringliteral">the stereo document also gives a good overview of the generic coupling</span>
<a name="l00283"></a>00283 <span class="stringliteral">mechanism.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00284"></a>00284 <span class="stringliteral">Vorbis coupling applies to pairs of residue vectors at a time;</span>
<a name="l00285"></a>00285 <span class="stringliteral">decoupling is done in-place a pair at a time in the order and using</span>
<a name="l00286"></a>00286 <span class="stringliteral">the vectors specified in the current mapping configuration.  The</span>
<a name="l00287"></a>00287 <span class="stringliteral">decoupling operation is the same for all pairs, converting square</span>
<a name="l00288"></a>00288 <span class="stringliteral">polar representation (where one vector is magnitude and the second</span>
<a name="l00289"></a>00289 <span class="stringliteral">angle) back to Cartesian representation.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00290"></a>00290 <span class="stringliteral">After decoupling, in order, each pair of vectors on the coupling list, </span>
<a name="l00291"></a>00291 <span class="stringliteral">the resulting residue vectors represent the fine spectral detail</span>
<a name="l00292"></a>00292 <span class="stringliteral">of each output channel.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450201&quot;&gt;&lt;/a&gt;1.3.2.7. generate floor curve&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00293"></a>00293 <span class="stringliteral">The decoder may choose to generate the floor curve at any appropriate</span>
<a name="l00294"></a>00294 <span class="stringliteral">time.  It is reasonable to generate the output curve when the floor</span>
<a name="l00295"></a>00295 <span class="stringliteral">data is decoded from the raw packet, or it can be generated after</span>
<a name="l00296"></a>00296 <span class="stringliteral">inverse coupling and applied to the spectral residue directly,</span>
<a name="l00297"></a>00297 <span class="stringliteral">combining generation and the dot product into one step and eliminating</span>
<a name="l00298"></a>00298 <span class="stringliteral">some working space.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00299"></a>00299 <span class="stringliteral">Both floor 0 and floor 1 generate a linear-range, linear-domain output</span>
<a name="l00300"></a>00300 <span class="stringliteral">vector to be multiplied (dot product) by the linear-range,</span>
<a name="l00301"></a>00301 <span class="stringliteral">linear-domain spectral residue.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450222&quot;&gt;&lt;/a&gt;1.3.2.8. compute floor/residue dot product&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00302"></a>00302 <span class="stringliteral">This step is straightforward; for each output channel, the decoder</span>
<a name="l00303"></a>00303 <span class="stringliteral">multiplies the floor curve and residue vectors element by element,</span>
<a name="l00304"></a>00304 <span class="stringliteral">producing the finished audio spectrum of each channel.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00305"></a>00305 <span class="stringliteral">One point is worth mentioning about this dot product; a common mistake</span>
<a name="l00306"></a>00306 <span class="stringliteral">in a fixed point implementation might be to assume that a 32 bit</span>
<a name="l00307"></a>00307 <span class="stringliteral">fixed-point representation for floor and residue and direct</span>
<a name="l00308"></a>00308 <span class="stringliteral">multiplication of the vectors is sufficient for acceptable spectral</span>
<a name="l00309"></a>00309 <span class="stringliteral">depth in all cases because it happens to mostly work with the current</span>
<a name="l00310"></a>00310 <span class="stringliteral">Xiph.Org reference encoder.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00311"></a>00311 <span class="stringliteral">However, floor vector values can span ~140dB (~24 bits unsigned), and</span>
<a name="l00312"></a>00312 <span class="stringliteral">the audio spectrum vector should represent a minimum of 120dB (~21</span>
<a name="l00313"></a>00313 <span class="stringliteral">bits with sign), even when output is to a 16 bit PCM device.  For the</span>
<a name="l00314"></a>00314 <span class="stringliteral">residue vector to represent full scale if the floor is nailed to</span>
<a name="l00315"></a>00315 <span class="stringliteral">-140dB, it must be able to span 0 to +140dB.  For the residue vector</span>
<a name="l00316"></a>00316 <span class="stringliteral">to reach full scale if the floor is nailed at 0dB, it must be able to</span>
<a name="l00317"></a>00317 <span class="stringliteral">represent -140dB to +0dB.  Thus, in order to handle full range</span>
<a name="l00318"></a>00318 <span class="stringliteral">dynamics, a residue vector may span -140dB to +140dB entirely within</span>
<a name="l00319"></a>00319 <span class="stringliteral">spec.  A 280dB range is approximately 48 bits with sign; thus the</span>
<a name="l00320"></a>00320 <span class="stringliteral">residue vector must be able to represent a 48 bit range and the dot</span>
<a name="l00321"></a>00321 <span class="stringliteral">product must be able to handle an effective 48 bit times 24 bit</span>
<a name="l00322"></a>00322 <span class="stringliteral">multiplication.  This range may be achieved using large (64 bit or</span>
<a name="l00323"></a>00323 <span class="stringliteral">larger) integers, or implementing a movable binary point</span>
<a name="l00324"></a>00324 <span class="stringliteral">representation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450264&quot;&gt;&lt;/a&gt;1.3.2.9. inverse monolithic transform (MDCT)&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00325"></a>00325 <span class="stringliteral">The audio spectrum is converted back into time domain PCM audio via an</span>
<a name="l00326"></a>00326 <span class="stringliteral">inverse Modified Discrete Cosine Transform (MDCT).  A detailed</span>
<a name="l00327"></a>00327 <span class="stringliteral">description of the MDCT is available in the paper &lt;a href=&quot;http://www.iocon.com/resource/docs/ps/eusipco_corrected.ps&quot; target=&quot;_top&quot;&gt;&amp;#8220;&lt;span class=&quot;citetitle&quot;&gt;The use of multirate filter banks for coding of high quality digital</span>
<a name="l00328"></a>00328 <span class="stringliteral">audio&lt;/span&gt;&amp;#8221;&lt;/a&gt;, by T. Sporer, K. Brandenburg and B. Edler.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00329"></a>00329 <span class="stringliteral">Note that the PCM produced directly from the MDCT is not yet finished</span>
<a name="l00330"></a>00330 <span class="stringliteral">audio; it must be lapped with surrounding frames using an appropriate</span>
<a name="l00331"></a>00331 <span class="stringliteral">window (such as the Vorbis window) before the MDCT can be considered</span>
<a name="l00332"></a>00332 <span class="stringliteral">orthogonal.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450296&quot;&gt;&lt;/a&gt;1.3.2.10. overlap/add data&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00333"></a>00333 <span class="stringliteral">Windowed MDCT output is overlapped and added with the right hand data</span>
<a name="l00334"></a>00334 <span class="stringliteral">of the previous window such that the 3/4 point of the previous window</span>
<a name="l00335"></a>00335 <span class="stringliteral">is aligned with the 1/4 point of the current window (as illustrated in</span>
<a name="l00336"></a>00336 <span class="stringliteral">the window overlap diagram). At this point, the audio data between the</span>
<a name="l00337"></a>00337 <span class="stringliteral">center of the previous frame and the center of the current frame is</span>
<a name="l00338"></a>00338 <span class="stringliteral">now finished and ready to be returned. &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450312&quot;&gt;&lt;/a&gt;1.3.2.11. cache right hand data&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00339"></a>00339 <span class="stringliteral">The decoder must cache the right hand portion of the current frame to</span>
<a name="l00340"></a>00340 <span class="stringliteral">be lapped with the left hand portion of the next frame.</span>
<a name="l00341"></a>00341 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2542059&quot;&gt;&lt;/a&gt;1.3.2.12. return finished audio data&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00342"></a>00342 <span class="stringliteral">The overlapped portion produced from overlapping the previous and</span>
<a name="l00343"></a>00343 <span class="stringliteral">current frame data is finished data to be returned by the decoder.</span>
<a name="l00344"></a>00344 <span class="stringliteral">This data spans from the center of the previous window to the center</span>
<a name="l00345"></a>00345 <span class="stringliteral">of the current window.  In the case of same-sized windows, the amount</span>
<a name="l00346"></a>00346 <span class="stringliteral">of data to return is one-half block consisting of and only of the</span>
<a name="l00347"></a>00347 <span class="stringliteral">overlapped portions. When overlapping a short and long window, much of</span>
<a name="l00348"></a>00348 <span class="stringliteral">the returned range is not actually overlap.  This does not damage</span>
<a name="l00349"></a>00349 <span class="stringliteral">transform orthogonality.  Pay attention however to returning the</span>
<a name="l00350"></a>00350 <span class="stringliteral">correct data range; the amount of data to be returned is:</span>
<a name="l00351"></a>00351 <span class="stringliteral"></span>
<a name="l00352"></a>00352 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l00353"></a>00353 <span class="stringliteral">window_blocksize(previous_window)/4+window_blocksize(current_window)/4</span>
<a name="l00354"></a>00354 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00355"></a>00355 <span class="stringliteral"></span>
<a name="l00356"></a>00356 <span class="stringliteral">from the center of the previous window to the center of the current</span>
<a name="l00357"></a>00357 <span class="stringliteral">window.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00358"></a>00358 <span class="stringliteral">Data is not returned from the first frame; it must be used to &#39;</span>prime<span class="stringliteral">&#39;</span>
<a name="l00359"></a>00359 <span class="stringliteral">the decode engine.  The encoder accounts for this priming when</span>
<a name="l00360"></a>00360 <span class="stringliteral">calculating PCM offsets; after the first frame, the proper PCM output</span>
<a name="l00361"></a>00361 <span class="stringliteral">offset is &#39;</span>0<span class="stringliteral">&#39; (as no data has been returned yet).&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-bitpacking&quot;&gt;&lt;/a&gt;2. Bitpacking Convention&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;</span>
<a name="l00362"></a>00362 <span class="stringliteral"> $Id: 02-bitpacking.xml 7186 2004-07-20 07:19:25Z xiphmont $</span>
<a name="l00363"></a>00363 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2524173&quot;&gt;&lt;/a&gt;2.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00364"></a>00364 <span class="stringliteral">The Vorbis codec uses relatively unstructured raw packets containing</span>
<a name="l00365"></a>00365 <span class="stringliteral">arbitrary-width binary integer fields.  Logically, these packets are a</span>
<a name="l00366"></a>00366 <span class="stringliteral">bitstream in which bits are coded one-by-one by the encoder and then</span>
<a name="l00367"></a>00367 <span class="stringliteral">read one-by-one in the same monotonically increasing order by the</span>
<a name="l00368"></a>00368 <span class="stringliteral">decoder.  Most current binary storage arrangements group bits into a</span>
<a name="l00369"></a>00369 <span class="stringliteral">native word size of eight bits (octets), sixteen bits, thirty-two bits</span>
<a name="l00370"></a>00370 <span class="stringliteral">or, less commonly other fixed word sizes.  The Vorbis bitpacking</span>
<a name="l00371"></a>00371 <span class="stringliteral">convention specifies the correct mapping of the logical packet</span>
<a name="l00372"></a>00372 <span class="stringliteral">bitstream into an actual representation in fixed-width words.</span>
<a name="l00373"></a>00373 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2498786&quot;&gt;&lt;/a&gt;2.1.1. octets, bytes and words&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00374"></a>00374 <span class="stringliteral">In most contemporary architectures, a &#39;</span>byte<span class="stringliteral">&#39; is synonymous with an</span>
<a name="l00375"></a>00375 <span class="stringliteral">&#39;</span>octet<span class="stringliteral">&#39;, that is, eight bits.  This has not always been the case;</span>
<a name="l00376"></a>00376 <span class="stringliteral">seven, ten, eleven and sixteen bit &#39;</span>bytes<span class="stringliteral">&#39; have been used.  For</span>
<a name="l00377"></a>00377 <span class="stringliteral">purposes of the bitpacking convention, a byte implies the native,</span>
<a name="l00378"></a>00378 <span class="stringliteral">smallest integer storage representation offered by a platform.  On</span>
<a name="l00379"></a>00379 <span class="stringliteral">modern platforms, this is generally assumed to be eight bits (not</span>
<a name="l00380"></a>00380 <span class="stringliteral">necessarily because of the processor but because of the</span>
<a name="l00381"></a>00381 <span class="stringliteral">filesystem/memory architecture.  Modern filesystems invariably offer</span>
<a name="l00382"></a>00382 <span class="stringliteral">bytes as the fundamental atom of storage).  A &#39;</span>word<span class="stringliteral">&#39; is an integer</span>
<a name="l00383"></a>00383 <span class="stringliteral">size that is a grouped multiple of this smallest size.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00384"></a>00384 <span class="stringliteral">The most ubiquitous architectures today consider a &#39;</span>byte<span class="stringliteral">&#39; to be an</span>
<a name="l00385"></a>00385 <span class="stringliteral">octet (eight bits) and a word to be a group of two, four or eight</span>
<a name="l00386"></a>00386 <span class="stringliteral">bytes (16, 32 or 64 bits).  Note however that the Vorbis bitpacking</span>
<a name="l00387"></a>00387 <span class="stringliteral">convention is still well defined for any native byte size; Vorbis uses</span>
<a name="l00388"></a>00388 <span class="stringliteral">the native bit-width of a given storage system. This document assumes</span>
<a name="l00389"></a>00389 <span class="stringliteral">that a byte is one octet for purposes of example.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2516522&quot;&gt;&lt;/a&gt;2.1.2. bit order&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00390"></a>00390 <span class="stringliteral">A byte has a well-defined &#39;</span>least significant<span class="stringliteral">&#39; bit (LSb), which is the</span>
<a name="l00391"></a>00391 <span class="stringliteral">only bit set when the byte is storing the two&#39;</span>s complement integer
<a name="l00392"></a>00392 value +1.  A byte<span class="stringliteral">&#39;s &#39;</span>most significant<span class="stringliteral">&#39; bit (MSb) is at the opposite</span>
<a name="l00393"></a>00393 <span class="stringliteral">end of the byte. Bits in a byte are numbered from zero at the LSb to</span>
<a name="l00394"></a>00394 <span class="stringliteral">&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;=7 in an octet) for the</span>
<a name="l00395"></a>00395 <span class="stringliteral">MSb.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2483456&quot;&gt;&lt;/a&gt;2.1.3. byte order&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00396"></a>00396 <span class="stringliteral">Words are native groupings of multiple bytes.  Several byte orderings</span>
<a name="l00397"></a>00397 <span class="stringliteral">are possible in a word; the common ones are 3-2-1-0 (&#39;</span>big endian<span class="stringliteral">&#39; or</span>
<a name="l00398"></a>00398 <span class="stringliteral">&#39;</span>most significant byte first<span class="stringliteral">&#39; in which the highest-valued byte comes</span>
<a name="l00399"></a>00399 <span class="stringliteral">first), 0-1-2-3 (&#39;</span>little endian<span class="stringliteral">&#39; or &#39;</span>least significant byte first<span class="stringliteral">&#39; in</span>
<a name="l00400"></a>00400 <span class="stringliteral">which the lowest value byte comes first) and less commonly 3-1-2-0 and</span>
<a name="l00401"></a>00401 <span class="stringliteral">0-2-1-3 (&#39;</span>mixed endian<span class="stringliteral">&#39;).&lt;/p&gt;&lt;p&gt;</span>
<a name="l00402"></a>00402 <span class="stringliteral">The Vorbis bitpacking convention specifies storage and bitstream</span>
<a name="l00403"></a>00403 <span class="stringliteral">manipulation at the byte, not word, level, thus host word ordering is</span>
<a name="l00404"></a>00404 <span class="stringliteral">of a concern only during optimization when writing high performance</span>
<a name="l00405"></a>00405 <span class="stringliteral">code that operates on a word of storage at a time rather than by byte.</span>
<a name="l00406"></a>00406 <span class="stringliteral">Logically, bytes are always coded and decoded in order from byte zero</span>
<a name="l00407"></a>00407 <span class="stringliteral">through byte &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2513509&quot;&gt;&lt;/a&gt;2.1.4. coding bits into byte sequences&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00408"></a>00408 <span class="stringliteral">The Vorbis codec has need to code arbitrary bit-width integers, from</span>
<a name="l00409"></a>00409 <span class="stringliteral">zero to 32 bits wide, into packets.  These integer fields are not</span>
<a name="l00410"></a>00410 <span class="stringliteral">aligned to the boundaries of the byte representation; the next field</span>
<a name="l00411"></a>00411 <span class="stringliteral">is written at the bit position at which the previous field ends.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00412"></a>00412 <span class="stringliteral">The encoder logically packs integers by writing the LSb of a binary</span>
<a name="l00413"></a>00413 <span class="stringliteral">integer to the logical bitstream first, followed by next least</span>
<a name="l00414"></a>00414 <span class="stringliteral">significant bit, etc, until the requested number of bits have been</span>
<a name="l00415"></a>00415 <span class="stringliteral">coded.  When packing the bits into bytes, the encoder begins by</span>
<a name="l00416"></a>00416 <span class="stringliteral">placing the LSb of the integer to be written into the least</span>
<a name="l00417"></a>00417 <span class="stringliteral">significant unused bit position of the destination byte, followed by</span>
<a name="l00418"></a>00418 <span class="stringliteral">the next-least significant bit of the source integer and so on up to</span>
<a name="l00419"></a>00419 <span class="stringliteral">the requested number of bits.  When all bits of the destination byte</span>
<a name="l00420"></a>00420 <span class="stringliteral">have been filled, encoding continues by zeroing all bits of the next</span>
<a name="l00421"></a>00421 <span class="stringliteral">byte and writing the next bit into the bit position 0 of that byte.</span>
<a name="l00422"></a>00422 <span class="stringliteral">Decoding follows the same process as encoding, but by reading bits</span>
<a name="l00423"></a>00423 <span class="stringliteral">from the byte stream and reassembling them into integers.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2537805&quot;&gt;&lt;/a&gt;2.1.5. signedness&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00424"></a>00424 <span class="stringliteral">The signedness of a specific number resulting from decode is to be</span>
<a name="l00425"></a>00425 <span class="stringliteral">interpreted by the decoder given decode context.  That is, the three</span>
<a name="l00426"></a>00426 <span class="stringliteral">bit binary pattern &#39;</span>b111<span class="stringliteral">&#39; can be taken to represent either &#39;</span>seven<span class="stringliteral">&#39; as</span>
<a name="l00427"></a>00427 <span class="stringliteral">an unsigned integer, or &#39;</span>-1<span class="stringliteral">&#39; as a signed, two&#39;</span>s complement integer.
<a name="l00428"></a>00428 The encoder and decoder are responsible <span class="keywordflow">for</span> knowing <span class="keywordflow">if</span> fields are to
<a name="l00429"></a>00429 be treated as <span class="keywordtype">signed</span> or <span class="keywordtype">unsigned</span>.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2513546&quot;</span>&gt;&lt;/a&gt;2.1.6. coding example&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00430"></a>00430 Code the 4 bit integer value <span class="stringliteral">&#39;12&#39;</span> [b1100] into an empty bytestream.
<a name="l00431"></a>00431 Bytestream result:
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;  
<a name="l00434"></a>00434               |
<a name="l00435"></a>00435               V
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         7 6 5 4 3 2 1 0
<a name="l00438"></a>00438 byte 0 [0 0 0 0 1 1 0 0]  &amp;lt;-
<a name="l00439"></a>00439 byte 1 [               ]
<a name="l00440"></a>00440 byte 2 [               ]
<a name="l00441"></a>00441 byte 3 [               ]
<a name="l00442"></a>00442              ...
<a name="l00443"></a>00443 byte n [               ]  bytestream length == 1 byte
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 &lt;/pre&gt;&lt;p&gt;
<a name="l00446"></a>00446 &lt;/p&gt;&lt;p&gt;
<a name="l00447"></a>00447 Continue by coding the 3 bit integer value <span class="stringliteral">&#39;-1&#39;</span> [b111]:
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l00450"></a>00450         |
<a name="l00451"></a>00451         V
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         7 6 5 4 3 2 1 0
<a name="l00454"></a>00454 byte 0 [0 1 1 1 1 1 0 0]  &amp;lt;-
<a name="l00455"></a>00455 byte 1 [               ]
<a name="l00456"></a>00456 byte 2 [               ]
<a name="l00457"></a>00457 byte 3 [               ]
<a name="l00458"></a>00458              ... 
<a name="l00459"></a>00459 byte n [               ]  bytestream length == 1 byte
<a name="l00460"></a>00460 &lt;/pre&gt;&lt;p&gt;
<a name="l00461"></a>00461 &lt;/p&gt;&lt;p&gt;
<a name="l00462"></a>00462 Continue by coding the 7 bit integer value <span class="stringliteral">&#39;17&#39;</span> [b0010001]:
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l00465"></a>00465           |
<a name="l00466"></a>00466           V    
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         7 6 5 4 3 2 1 0
<a name="l00469"></a>00469 byte 0 [1 1 1 1 1 1 0 0]
<a name="l00470"></a>00470 byte 1 [0 0 0 0 1 0 0 0]  &amp;lt;-
<a name="l00471"></a>00471 byte 2 [               ]
<a name="l00472"></a>00472 byte 3 [               ]
<a name="l00473"></a>00473              ...
<a name="l00474"></a>00474 byte n [               ]  bytestream length == 2 bytes
<a name="l00475"></a>00475                           bit cursor == 6
<a name="l00476"></a>00476 &lt;/pre&gt;&lt;p&gt;
<a name="l00477"></a>00477 &lt;/p&gt;&lt;p&gt;
<a name="l00478"></a>00478 Continue by coding the 13 bit integer value <span class="stringliteral">&#39;6969&#39;</span> [b110 11001110 01]:
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l00481"></a>00481                 |
<a name="l00482"></a>00482                 V
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         7 6 5 4 3 2 1 0
<a name="l00485"></a>00485 byte 0 [1 1 1 1 1 1 0 0]
<a name="l00486"></a>00486 byte 1 [0 1 0 0 1 0 0 0]
<a name="l00487"></a>00487 byte 2 [1 1 0 0 1 1 1 0]
<a name="l00488"></a>00488 byte 3 [0 0 0 0 0 1 1 0]  &amp;lt;-
<a name="l00489"></a>00489              ...
<a name="l00490"></a>00490 byte n [               ]  bytestream length == 4 bytes
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 &lt;/pre&gt;&lt;p&gt;
<a name="l00493"></a>00493 &lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2513617&quot;</span>&gt;&lt;/a&gt;2.1.7. decoding example&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00494"></a>00494 Reading from the beginning of the bytestream encoded in the above example:
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l00497"></a>00497                       |
<a name="l00498"></a>00498                       V
<a name="l00499"></a>00499                       
<a name="l00500"></a>00500         7 6 5 4 3 2 1 0
<a name="l00501"></a>00501 byte 0 [1 1 1 1 1 1 0 0]  &amp;lt;-
<a name="l00502"></a>00502 byte 1 [0 1 0 0 1 0 0 0]
<a name="l00503"></a>00503 byte 2 [1 1 0 0 1 1 1 0]
<a name="l00504"></a>00504 byte 3 [0 0 0 0 0 1 1 0]  bytestream length == 4 bytes
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 &lt;/pre&gt;&lt;p&gt;
<a name="l00507"></a>00507 &lt;/p&gt;&lt;p&gt;
<a name="l00508"></a>00508 We read two, two-bit integer fields, resulting in the returned numbers
<a name="l00509"></a>00509 <span class="stringliteral">&#39;b00&#39;</span> and <span class="stringliteral">&#39;b11&#39;</span>.  Two things are worth noting here:
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;itemizedlist&quot;</span>&gt;&lt;ul type=<span class="stringliteral">&quot;disc&quot;</span>&gt;&lt;li&gt;&lt;p&gt;Although these four bits were originally written as a single
<a name="l00512"></a>00512 four-bit integer, reading some other combination of bit-widths from the
<a name="l00513"></a>00513 bitstream is well defined.  There are no artificial alignment
<a name="l00514"></a>00514 boundaries maintained in the bitstream.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The second value is the
<a name="l00515"></a>00515 two-bit-wide integer <span class="stringliteral">&#39;b11&#39;</span>.  This value may be interpreted either as
<a name="l00516"></a>00516 the <span class="keywordtype">unsigned</span> value <span class="charliteral">&#39;3&#39;</span>, or the <span class="keywordtype">signed</span> value <span class="stringliteral">&#39;-1&#39;</span>.  Signedness is
<a name="l00517"></a>00517 dependent on decode context.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00518"></a>00518 &lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2513669&quot;</span>&gt;&lt;/a&gt;2.1.8. end-of-packet alignment&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00519"></a>00519 The typical use of bitpacking is to produce many independent
<a name="l00520"></a>00520 byte-aligned packets which are embedded into a larger byte-aligned
<a name="l00521"></a>00521 container structure, such as an Ogg transport bitstream.  Externally,
<a name="l00522"></a>00522 each bytestream (encoded bitstream) must begin and end on a byte
<a name="l00523"></a>00523 boundary.  Often, the encoded bitstream is not an integer number of
<a name="l00524"></a>00524 bytes, and so there is unused (uncoded) space in the last byte of a
<a name="l00525"></a>00525 packet.&lt;/p&gt;&lt;p&gt;
<a name="l00526"></a>00526 Unused space in the last byte of a bytestream is always zeroed during
<a name="l00527"></a>00527 the coding process.  Thus, should this unused space be read, it will
<a name="l00528"></a>00528 return binary zeroes.&lt;/p&gt;&lt;p&gt;
<a name="l00529"></a>00529 Attempting to read past the end of an encoded packet results in an
<a name="l00530"></a>00530 &#39;end-of-packet&#39; condition.  End-of-packet is not to be considered an
<a name="l00531"></a>00531 error; it is merely a state indicating that there is insufficient
<a name="l00532"></a>00532 remaining data to fulfill the desired read size.  Vorbis uses truncated
<a name="l00533"></a>00533 packets as a normal mode of operation, and as such, decoders must
<a name="l00534"></a>00534 handle reading past the end of a packet as a typical mode of
<a name="l00535"></a>00535 operation. Any further read operations after an &#39;end-of-packet&#39;
<a name="l00536"></a>00536 condition shall also return &#39;end-of-packet&#39;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2520883&quot;&gt;&lt;/a&gt;2.1.9.  reading zero bits&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00537"></a>00537 Reading a zero-bit-wide integer returns the value &#39;0&#39; and does not
<a name="l00538"></a>00538 increment the stream cursor.  Reading to the end of the packet (but
<a name="l00539"></a>00539 not past, such that an &#39;end-of-packet&#39; condition has not triggered)
<a name="l00540"></a>00540 and then reading a zero bit integer shall succeed, returning 0, and
<a name="l00541"></a>00541 not trigger an end-of-packet condition.  Reading a zero-bit-wide
<a name="l00542"></a>00542 integer after a previous read sets &#39;end-of-packet&#39; shall also fail
<a name="l00543"></a>00543 with &#39;end-of-packet&#39;.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-<a class="code" href="structcodebook.html">codebook</a>&quot;&gt;&lt;/a&gt;3. Probability Model and Codebooks&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;
<a name="l00544"></a>00544  $Id: 03-<a class="code" href="structcodebook.html">codebook</a>.xml 7186 2004-07-20 07:19:25Z xiphmont $
<a name="l00545"></a>00545 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2523292&quot;&gt;&lt;/a&gt;3.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00546"></a>00546 Unlike practically every other mainstream audio codec, Vorbis has no
<a name="l00547"></a>00547 statically configured probability model, instead packing all entropy
<a name="l00548"></a>00548 decoding configuration, VQ and Huffman, into the bitstream itself in
<a name="l00549"></a>00549 the third header, the codec setup header.  This packed configuration
<a name="l00550"></a>00550 consists of multiple &#39;codebooks&#39;, each containing a specific
<a name="l00551"></a>00551 Huffman-equivalent representation <a class="code" href="interfacefor.html">for</a> decoding compressed codewords as
<a name="l00552"></a>00552 well as an optional lookup table of output vector values to which a
<a name="l00553"></a>00553 decoded Huffman value is applied as an offset, generating the final
<a name="l00554"></a>00554 decoded output corresponding to a given compressed codeword.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2497985&quot;&gt;&lt;/a&gt;3.1.1. Bitwise operation&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00555"></a>00555 The <a class="code" href="structcodebook.html">codebook</a> mechanism is built on top of the vorbis bitpacker. Both
<a name="l00556"></a>00556 the codebooks themselves and the codewords they decode are unrolled 
<a name="l00557"></a>00557 from a packet as a series of arbitrary-width values read from the 
<a name="l00558"></a>00558 stream according to &lt;a href=&quot;<span class="preprocessor">#vorbis-spec-bitpacking&quot; title=&quot;2. Bitpacking Convention&quot;&gt;Section 2, &amp;#8220;Bitpacking Convention&amp;#8221;&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2509016&quot;&gt;&lt;/a&gt;3.2. Packed codebook format&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span>For purposes of the examples below, we assume that the storage
<a name="l00560"></a>00560 system<span class="stringliteral">&#39;s native byte width is eight bits.  This is not universally</span>
<a name="l00561"></a>00561 <span class="stringliteral">true; see &lt;a href=&quot;#vorbis-spec-bitpacking&quot; title=&quot;2. Bitpacking Convention&quot;&gt;Section 2, &amp;#8220;Bitpacking Convention&amp;#8221;&lt;/a&gt; for discussion </span>
<a name="l00562"></a>00562 <span class="stringliteral">relating to non-eight-bit bytes.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450934&quot;&gt;&lt;/a&gt;3.2.1. codebook decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00563"></a>00563 <span class="stringliteral">A codebook begins with a 24 bit sync pattern, 0x564342:</span>
<a name="l00564"></a>00564 <span class="stringliteral"></span>
<a name="l00565"></a>00565 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00566"></a>00566 <span class="stringliteral">byte 0: [ 0 1 0 0 0 0 1 0 ] (0x42)</span>
<a name="l00567"></a>00567 <span class="stringliteral">byte 1: [ 0 1 0 0 0 0 1 1 ] (0x43)</span>
<a name="l00568"></a>00568 <span class="stringliteral">byte 2: [ 0 1 0 1 0 1 1 0 ] (0x56)</span>
<a name="l00569"></a>00569 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00570"></a>00570 <span class="stringliteral">16 bit &lt;code class=&quot;varname&quot;&gt;[codebook_dimensions]&lt;/code&gt; and 24 bit &lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt; fields:</span>
<a name="l00571"></a>00571 <span class="stringliteral"></span>
<a name="l00572"></a>00572 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00573"></a>00573 <span class="stringliteral"></span>
<a name="l00574"></a>00574 <span class="stringliteral">byte 3: [ X X X X X X X X ] </span>
<a name="l00575"></a>00575 <span class="stringliteral">byte 4: [ X X X X X X X X ] [codebook_dimensions] (16 bit unsigned)</span>
<a name="l00576"></a>00576 <span class="stringliteral"></span>
<a name="l00577"></a>00577 <span class="stringliteral">byte 5: [ X X X X X X X X ] </span>
<a name="l00578"></a>00578 <span class="stringliteral">byte 6: [ X X X X X X X X ] </span>
<a name="l00579"></a>00579 <span class="stringliteral">byte 7: [ X X X X X X X X ] [codebook_entries] (24 bit unsigned)</span>
<a name="l00580"></a>00580 <span class="stringliteral"></span>
<a name="l00581"></a>00581 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00582"></a>00582 <span class="stringliteral">Next is the &lt;code class=&quot;varname&quot;&gt;[ordered]&lt;/code&gt; bit flag:</span>
<a name="l00583"></a>00583 <span class="stringliteral"></span>
<a name="l00584"></a>00584 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00585"></a>00585 <span class="stringliteral"></span>
<a name="l00586"></a>00586 <span class="stringliteral">byte 8: [               X ] [ordered] (1 bit)</span>
<a name="l00587"></a>00587 <span class="stringliteral"></span>
<a name="l00588"></a>00588 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00589"></a>00589 <span class="stringliteral">Each entry, numbering a</span>
<a name="l00590"></a>00590 <span class="stringliteral">total of &lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt;, is assigned a codeword length.</span>
<a name="l00591"></a>00591 <span class="stringliteral">We now read the list of codeword lengths and store these lengths in</span>
<a name="l00592"></a>00592 <span class="stringliteral">the array &lt;code class=&quot;varname&quot;&gt;[codebook_codeword_lengths]&lt;/code&gt;. Decode of lengths is</span>
<a name="l00593"></a>00593 <span class="stringliteral">according to whether the &lt;code class=&quot;varname&quot;&gt;[ordered]&lt;/code&gt; flag is set or unset.</span>
<a name="l00594"></a>00594 <span class="stringliteral"></span>
<a name="l00595"></a>00595 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;p&gt;If the &lt;code class=&quot;varname&quot;&gt;[ordered]&lt;/code&gt; flag is unset, the codeword list is not</span>
<a name="l00596"></a>00596 <span class="stringliteral">  length ordered and the decoder needs to read each codeword length</span>
<a name="l00597"></a>00597 <span class="stringliteral">  one-by-one.&lt;/p&gt;&lt;p&gt;The decoder first reads one additional bit flag, the</span>
<a name="l00598"></a>00598 <span class="stringliteral">  &lt;code class=&quot;varname&quot;&gt;[sparse]&lt;/code&gt; flag.  This flag determines whether or not the</span>
<a name="l00599"></a>00599 <span class="stringliteral">  codebook contains unused entries that are not to be included in the</span>
<a name="l00600"></a>00600 <span class="stringliteral">  codeword decode tree:</span>
<a name="l00601"></a>00601 <span class="stringliteral"></span>
<a name="l00602"></a>00602 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00603"></a>00603 <span class="stringliteral">byte 8: [             X 1 ] [sparse] flag (1 bit)</span>
<a name="l00604"></a>00604 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00605"></a>00605 <span class="stringliteral">  The decoder now performs for each of the &lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt;</span>
<a name="l00606"></a>00606 <span class="stringliteral">  codebook entries:</span>
<a name="l00607"></a>00607 <span class="stringliteral"></span>
<a name="l00608"></a>00608 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00609"></a>00609 <span class="stringliteral">  </span>
<a name="l00610"></a>00610 <span class="stringliteral">  1) if([sparse] is set){</span>
<a name="l00611"></a>00611 <span class="stringliteral"></span>
<a name="l00612"></a>00612 <span class="stringliteral">         2) [flag] = read one bit;</span>
<a name="l00613"></a>00613 <span class="stringliteral">         3) if([flag] is set){</span>
<a name="l00614"></a>00614 <span class="stringliteral"></span>
<a name="l00615"></a>00615 <span class="stringliteral">              4) [length] = read a five bit unsigned integer;</span>
<a name="l00616"></a>00616 <span class="stringliteral">              5) codeword length for this entry is [length]+1;</span>
<a name="l00617"></a>00617 <span class="stringliteral"></span>
<a name="l00618"></a>00618 <span class="stringliteral">            } else {</span>
<a name="l00619"></a>00619 <span class="stringliteral"></span>
<a name="l00620"></a>00620 <span class="stringliteral">              6) this entry is unused.  mark it as such.</span>
<a name="l00621"></a>00621 <span class="stringliteral"></span>
<a name="l00622"></a>00622 <span class="stringliteral">            }</span>
<a name="l00623"></a>00623 <span class="stringliteral"></span>
<a name="l00624"></a>00624 <span class="stringliteral">     } else the sparse flag is not set {</span>
<a name="l00625"></a>00625 <span class="stringliteral"></span>
<a name="l00626"></a>00626 <span class="stringliteral">        7) [length] = read a five bit unsigned integer;</span>
<a name="l00627"></a>00627 <span class="stringliteral">        8) the codeword length for this entry is [length]+1;</span>
<a name="l00628"></a>00628 <span class="stringliteral">        </span>
<a name="l00629"></a>00629 <span class="stringliteral">     }</span>
<a name="l00630"></a>00630 <span class="stringliteral"></span>
<a name="l00631"></a>00631 <span class="stringliteral">&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If the &lt;code class=&quot;varname&quot;&gt;[ordered]&lt;/code&gt; flag is set, the codeword list for this</span>
<a name="l00632"></a>00632 <span class="stringliteral">  codebook is encoded in ascending length order.  Rather than reading</span>
<a name="l00633"></a>00633 <span class="stringliteral">  a length for every codeword, the encoder reads the number of</span>
<a name="l00634"></a>00634 <span class="stringliteral">  codewords per length.  That is, beginning at entry zero:</span>
<a name="l00635"></a>00635 <span class="stringliteral"></span>
<a name="l00636"></a>00636 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00637"></a>00637 <span class="stringliteral">  1) [current_entry] = 0;</span>
<a name="l00638"></a>00638 <span class="stringliteral">  2) [current_length] = read a five bit unsigned integer and add 1;</span>
<a name="l00639"></a>00639 <span class="stringliteral">  3) [number] = read &lt;a href=&quot;#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;([codebook_entries] - [current_entry]) bits as an unsigned integer</span>
<a name="l00640"></a>00640 <span class="stringliteral">  4) set the entries [current_entry] through [current_entry]+[number]-1, inclusive, </span>
<a name="l00641"></a>00641 <span class="stringliteral">    of the [codebook_codeword_lengths] array to [current_length]</span>
<a name="l00642"></a>00642 <span class="stringliteral">  5) set [current_entry] to [number] + [current_entry]</span>
<a name="l00643"></a>00643 <span class="stringliteral">  6) increment [current_length] by 1</span>
<a name="l00644"></a>00644 <span class="stringliteral">  7) if [current_entry] is greater than [codebook_entries] ERROR CONDITION; </span>
<a name="l00645"></a>00645 <span class="stringliteral">    the decoder will not be able to read this stream.</span>
<a name="l00646"></a>00646 <span class="stringliteral">  8) if [current_entry] is less than [codebook_entries], repeat process starting at 3)</span>
<a name="l00647"></a>00647 <span class="stringliteral">  9) done.</span>
<a name="l00648"></a>00648 <span class="stringliteral">&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00649"></a>00649 <span class="stringliteral"></span>
<a name="l00650"></a>00650 <span class="stringliteral">After all codeword lengths have been decoded, the decoder reads the</span>
<a name="l00651"></a>00651 <span class="stringliteral">vector lookup table.  Vorbis I supports three lookup types:</span>
<a name="l00652"></a>00652 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;No lookup&lt;/li&gt;&lt;li&gt;Implicitly populated value mapping (lattice VQ)&lt;/li&gt;&lt;li&gt;Explicitly populated value mapping (tessellated or &#39;</span>foam<span class="stringliteral">&#39;</span>
<a name="l00653"></a>00653 <span class="stringliteral">VQ)&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00654"></a>00654 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00655"></a>00655 <span class="stringliteral">The lookup table type is read as a four bit unsigned integer:</span>
<a name="l00656"></a>00656 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00657"></a>00657 <span class="stringliteral">  1) [codebook_lookup_type] = read four bits as an unsigned integer</span>
<a name="l00658"></a>00658 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00659"></a>00659 <span class="stringliteral">Codebook decode precedes according to &lt;code class=&quot;varname&quot;&gt;[codebook_lookup_type]&lt;/code&gt;:</span>
<a name="l00660"></a>00660 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;p&gt;Lookup type zero indicates no lookup to be read.  Proceed past</span>
<a name="l00661"></a>00661 <span class="stringliteral">lookup decode.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lookup types one and two are similar, differing only in the</span>
<a name="l00662"></a>00662 <span class="stringliteral">number of lookup values to be read.  Lookup type one reads a list of</span>
<a name="l00663"></a>00663 <span class="stringliteral">values that are permuted in a set pattern to build a list of vectors,</span>
<a name="l00664"></a>00664 <span class="stringliteral">each vector of order &lt;code class=&quot;varname&quot;&gt;[codebook_dimensions]&lt;/code&gt; scalars.  Lookup</span>
<a name="l00665"></a>00665 <span class="stringliteral">type two builds the same vector list, but reads each scalar for each</span>
<a name="l00666"></a>00666 <span class="stringliteral">vector explicitly, rather than building vectors from a smaller list of</span>
<a name="l00667"></a>00667 <span class="stringliteral">possible scalar values.  Lookup decode proceeds as follows:</span>
<a name="l00668"></a>00668 <span class="stringliteral"></span>
<a name="l00669"></a>00669 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00670"></a>00670 <span class="stringliteral">  1) [codebook_minimum_value] = &lt;a href=&quot;#vorbis-spec-float32_unpack&quot; title=&quot;9.2.2. float32_unpack&quot;&gt;float32_unpack&lt;/a&gt;( read 32 bits as an unsigned integer) </span>
<a name="l00671"></a>00671 <span class="stringliteral">  2) [codebook_delta_value] = &lt;a href=&quot;#vorbis-spec-float32_unpack&quot; title=&quot;9.2.2. float32_unpack&quot;&gt;float32_unpack&lt;/a&gt;( read 32 bits as an unsigned integer) </span>
<a name="l00672"></a>00672 <span class="stringliteral">  3) [codebook_value_bits] = read 4 bits as an unsigned integer and add 1</span>
<a name="l00673"></a>00673 <span class="stringliteral">  4) [codebook_sequence_p] = read 1 bit as a boolean flag</span>
<a name="l00674"></a>00674 <span class="stringliteral"></span>
<a name="l00675"></a>00675 <span class="stringliteral">  if ( [codebook_lookup_type] is 1 ) {</span>
<a name="l00676"></a>00676 <span class="stringliteral">   </span>
<a name="l00677"></a>00677 <span class="stringliteral">     5) [codebook_lookup_values] = &lt;a href=&quot;#vorbis-spec-lookup1_values&quot; title=&quot;9.2.3. lookup1_values&quot;&gt;lookup1_values&lt;/a&gt;(&lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt;, &lt;code class=&quot;varname&quot;&gt;[codebook_dimensions]&lt;/code&gt; )</span>
<a name="l00678"></a>00678 <span class="stringliteral"></span>
<a name="l00679"></a>00679 <span class="stringliteral">  } else {</span>
<a name="l00680"></a>00680 <span class="stringliteral"></span>
<a name="l00681"></a>00681 <span class="stringliteral">     6) [codebook_lookup_values] = &lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt; * &lt;code class=&quot;varname&quot;&gt;[codebook_dimensions]&lt;/code&gt;</span>
<a name="l00682"></a>00682 <span class="stringliteral"></span>
<a name="l00683"></a>00683 <span class="stringliteral">  }</span>
<a name="l00684"></a>00684 <span class="stringliteral"></span>
<a name="l00685"></a>00685 <span class="stringliteral">  7) read a total of [codebook_lookup_values] unsigned integers of [codebook_value_bits] each; </span>
<a name="l00686"></a>00686 <span class="stringliteral">     store these in order in the array [codebook_multiplicands]</span>
<a name="l00687"></a>00687 <span class="stringliteral">&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A &lt;code class=&quot;varname&quot;&gt;[codebook_lookup_type]&lt;/code&gt; of greater than two is reserved</span>
<a name="l00688"></a>00688 <span class="stringliteral">and indicates a stream that is not decodable by the specification in this</span>
<a name="l00689"></a>00689 <span class="stringliteral">document.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00690"></a>00690 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00691"></a>00691 <span class="stringliteral">An &#39;</span>end of packet<span class="stringliteral">&#39; during any read operation in the above steps is</span>
<a name="l00692"></a>00692 <span class="stringliteral">considered an error condition rendering the stream undecodable.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2519623&quot;&gt;&lt;/a&gt;3.2.1.1. Huffman decision tree representation&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00693"></a>00693 <span class="stringliteral">The &lt;code class=&quot;varname&quot;&gt;[codebook_codeword_lengths]&lt;/code&gt; array and</span>
<a name="l00694"></a>00694 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[codebook_entries]&lt;/code&gt; value uniquely define the Huffman decision</span>
<a name="l00695"></a>00695 <span class="stringliteral">tree used for entropy decoding.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00696"></a>00696 <span class="stringliteral">Briefly, each used codebook entry (recall that length-unordered</span>
<a name="l00697"></a>00697 <span class="stringliteral">codebooks support unused codeword entries) is assigned, in order, the</span>
<a name="l00698"></a>00698 <span class="stringliteral">lowest valued unused binary Huffman codeword possible.  Assume the</span>
<a name="l00699"></a>00699 <span class="stringliteral">following codeword length list:</span>
<a name="l00700"></a>00700 <span class="stringliteral"></span>
<a name="l00701"></a>00701 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00702"></a>00702 <span class="stringliteral">entry 0: length 2</span>
<a name="l00703"></a>00703 <span class="stringliteral">entry 1: length 4</span>
<a name="l00704"></a>00704 <span class="stringliteral">entry 2: length 4</span>
<a name="l00705"></a>00705 <span class="stringliteral">entry 3: length 4</span>
<a name="l00706"></a>00706 <span class="stringliteral">entry 4: length 4</span>
<a name="l00707"></a>00707 <span class="stringliteral">entry 5: length 2</span>
<a name="l00708"></a>00708 <span class="stringliteral">entry 6: length 3</span>
<a name="l00709"></a>00709 <span class="stringliteral">entry 7: length 3</span>
<a name="l00710"></a>00710 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00711"></a>00711 <span class="stringliteral">Assigning codewords in order (lowest possible value of the appropriate</span>
<a name="l00712"></a>00712 <span class="stringliteral">length to highest) results in the following codeword list:</span>
<a name="l00713"></a>00713 <span class="stringliteral"></span>
<a name="l00714"></a>00714 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00715"></a>00715 <span class="stringliteral">entry 0: length 2 codeword 00</span>
<a name="l00716"></a>00716 <span class="stringliteral">entry 1: length 4 codeword 0100</span>
<a name="l00717"></a>00717 <span class="stringliteral">entry 2: length 4 codeword 0101</span>
<a name="l00718"></a>00718 <span class="stringliteral">entry 3: length 4 codeword 0110</span>
<a name="l00719"></a>00719 <span class="stringliteral">entry 4: length 4 codeword 0111</span>
<a name="l00720"></a>00720 <span class="stringliteral">entry 5: length 2 codeword 10</span>
<a name="l00721"></a>00721 <span class="stringliteral">entry 6: length 3 codeword 110</span>
<a name="l00722"></a>00722 <span class="stringliteral">entry 7: length 3 codeword 111</span>
<a name="l00723"></a>00723 <span class="stringliteral">&lt;/pre&gt;&lt;div class=&quot;note&quot; style=&quot;margin-left: 0.5in; margin-right: 0.5in;&quot;&gt;&lt;h3 class=&quot;title&quot;&gt;Note&lt;/h3&gt;&lt;p&gt;</span>
<a name="l00724"></a>00724 <span class="stringliteral">Unlike most binary numerical values in this document, we</span>
<a name="l00725"></a>00725 <span class="stringliteral">intend the above codewords to be read and used bit by bit from left to</span>
<a name="l00726"></a>00726 <span class="stringliteral">right, thus the codeword &#39;</span>001<span class="stringliteral">&#39; is the bit string &#39;</span>zero, zero, one<span class="stringliteral">&#39;.</span>
<a name="l00727"></a>00727 <span class="stringliteral">When determining &#39;</span>lowest possible value<span class="stringliteral">&#39; in the assignment definition</span>
<a name="l00728"></a>00728 <span class="stringliteral">above, the leftmost bit is the MSb.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00729"></a>00729 <span class="stringliteral">It is clear that the codeword length list represents a Huffman</span>
<a name="l00730"></a>00730 <span class="stringliteral">decision tree with the entry numbers equivalent to the leaves numbered</span>
<a name="l00731"></a>00731 <span class="stringliteral">left-to-right:</span>
<a name="l00732"></a>00732 <span class="stringliteral"></span>
<a name="l00733"></a>00733 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;hufftree.png&quot; alt=&quot;[huffman tree illustration]&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00734"></a>00734 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00735"></a>00735 <span class="stringliteral">As we assign codewords in order, we see that each choice constructs a</span>
<a name="l00736"></a>00736 <span class="stringliteral">new leaf in the leftmost possible position.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00737"></a>00737 <span class="stringliteral">Note that it&#39;</span>s possible to underspecify or overspecify a Huffman tree
<a name="l00738"></a>00738 via the length list.  In the above example, <span class="keywordflow">if</span> codeword seven were
<a name="l00739"></a>00739 eliminated, it<span class="stringliteral">&#39;s clear that the tree is unfinished:</span>
<a name="l00740"></a>00740 <span class="stringliteral"></span>
<a name="l00741"></a>00741 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;hufftree-under.png&quot; alt=&quot;[underspecified huffman tree illustration]&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00742"></a>00742 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00743"></a>00743 <span class="stringliteral">Similarly, in the original codebook, it&#39;</span>s clear that the tree is fully
<a name="l00744"></a>00744 populated and a ninth codeword is impossible.  Both underspecified and
<a name="l00745"></a>00745 overspecified trees are an error condition rendering the stream
<a name="l00746"></a>00746 undecodable.&lt;/p&gt;&lt;p&gt;
<a name="l00747"></a>00747 Codebook entries marked <span class="stringliteral">&#39;unused&#39;</span> are simply skipped in the assigning
<a name="l00748"></a>00748 process.  They have no codeword and <span class="keywordflow">do</span> not appear in the decision
<a name="l00749"></a>00749 tree, thus it<span class="stringliteral">&#39;s impossible for any bit pattern read from the stream to</span>
<a name="l00750"></a>00750 <span class="stringliteral">decode to that entry number.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450540&quot;&gt;&lt;/a&gt;3.2.1.2. VQ lookup table vector representation&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00751"></a>00751 <span class="stringliteral">Unpacking the VQ lookup table vectors relies on the following values:</span>
<a name="l00752"></a>00752 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l00753"></a>00753 <span class="stringliteral">the [codebook_multiplicands] array</span>
<a name="l00754"></a>00754 <span class="stringliteral">[codebook_minimum_value]</span>
<a name="l00755"></a>00755 <span class="stringliteral">[codebook_delta_value]</span>
<a name="l00756"></a>00756 <span class="stringliteral">[codebook_sequence_p]</span>
<a name="l00757"></a>00757 <span class="stringliteral">[codebook_lookup_type]</span>
<a name="l00758"></a>00758 <span class="stringliteral">[codebook_entries]</span>
<a name="l00759"></a>00759 <span class="stringliteral">[codebook_dimensions]</span>
<a name="l00760"></a>00760 <span class="stringliteral">[codebook_lookup_values]</span>
<a name="l00761"></a>00761 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00762"></a>00762 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00763"></a>00763 <span class="stringliteral">Decoding (unpacking) a specific vector in the vector lookup table</span>
<a name="l00764"></a>00764 <span class="stringliteral">proceeds according to &lt;code class=&quot;varname&quot;&gt;[codebook_lookup_type]&lt;/code&gt;.  The unpacked</span>
<a name="l00765"></a>00765 <span class="stringliteral">vector values are what a codebook would return during audio packet</span>
<a name="l00766"></a>00766 <span class="stringliteral">decode in a VQ context.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h6 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450569&quot;&gt;&lt;/a&gt;3.2.1.2.1. Vector value decode: Lookup type 1&lt;/h6&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00767"></a>00767 <span class="stringliteral">Lookup type one specifies a lattice VQ lookup table built</span>
<a name="l00768"></a>00768 <span class="stringliteral">algorithmically from a list of scalar values.  Calculate (unpack) the</span>
<a name="l00769"></a>00769 <span class="stringliteral">final values of a codebook entry vector from the entries in</span>
<a name="l00770"></a>00770 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[codebook_multiplicands]&lt;/code&gt; as follows (&lt;code class=&quot;varname&quot;&gt;[value_vector]&lt;/code&gt;</span>
<a name="l00771"></a>00771 <span class="stringliteral">is the output vector representing the vector of values for entry number</span>
<a name="l00772"></a>00772 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[lookup_offset]&lt;/code&gt; in this codebook):</span>
<a name="l00773"></a>00773 <span class="stringliteral"></span>
<a name="l00774"></a>00774 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00775"></a>00775 <span class="stringliteral">  1) [last] = 0;</span>
<a name="l00776"></a>00776 <span class="stringliteral">  2) [index_divisor] = 1;</span>
<a name="l00777"></a>00777 <span class="stringliteral">  3) iterate [i] over the range 0 ... [codebook_dimensions]-1 (once for each scalar value in the value vector) {</span>
<a name="l00778"></a>00778 <span class="stringliteral">       </span>
<a name="l00779"></a>00779 <span class="stringliteral">       4) [multiplicand_offset] = ( [lookup_offset] divided by [index_divisor] using integer </span>
<a name="l00780"></a>00780 <span class="stringliteral">          division ) integer modulo [codebook_lookup_values]</span>
<a name="l00781"></a>00781 <span class="stringliteral"></span>
<a name="l00782"></a>00782 <span class="stringliteral">       5) vector [value_vector] element [i] = </span>
<a name="l00783"></a>00783 <span class="stringliteral">            ( [codebook_multiplicands] array element number [multiplicand_offset] ) *</span>
<a name="l00784"></a>00784 <span class="stringliteral">            [codebook_delta_value] + [codebook_minimum_value] + [last];</span>
<a name="l00785"></a>00785 <span class="stringliteral"></span>
<a name="l00786"></a>00786 <span class="stringliteral">       6) if ( [codebook_sequence_p] is set ) then set [last] = vector [value_vector] element [i]</span>
<a name="l00787"></a>00787 <span class="stringliteral"></span>
<a name="l00788"></a>00788 <span class="stringliteral">       7) [index_divisor] = [index_divisor] * [codebook_lookup_values]</span>
<a name="l00789"></a>00789 <span class="stringliteral"></span>
<a name="l00790"></a>00790 <span class="stringliteral">     }</span>
<a name="l00791"></a>00791 <span class="stringliteral"> </span>
<a name="l00792"></a>00792 <span class="stringliteral">  8) vector calculation completed.</span>
<a name="l00793"></a>00793 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h6 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450608&quot;&gt;&lt;/a&gt;3.2.1.2.2. Vector value decode: Lookup type 2&lt;/h6&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00794"></a>00794 <span class="stringliteral">Lookup type two specifies a VQ lookup table in which each scalar in</span>
<a name="l00795"></a>00795 <span class="stringliteral">each vector is explicitly set by the &lt;code class=&quot;varname&quot;&gt;[codebook_multiplicands]&lt;/code&gt;</span>
<a name="l00796"></a>00796 <span class="stringliteral">array in a one-to-one mapping.  Calculate [unpack] the</span>
<a name="l00797"></a>00797 <span class="stringliteral">final values of a codebook entry vector from the entries in</span>
<a name="l00798"></a>00798 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[codebook_multiplicands]&lt;/code&gt; as follows (&lt;code class=&quot;varname&quot;&gt;[value_vector]&lt;/code&gt;</span>
<a name="l00799"></a>00799 <span class="stringliteral">is the output vector representing the vector of values for entry number</span>
<a name="l00800"></a>00800 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[lookup_offset]&lt;/code&gt; in this codebook):</span>
<a name="l00801"></a>00801 <span class="stringliteral"></span>
<a name="l00802"></a>00802 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00803"></a>00803 <span class="stringliteral">  1) [last] = 0;</span>
<a name="l00804"></a>00804 <span class="stringliteral">  2) [multiplicand_offset] = [lookup_offset] * [codebook_dimensions]</span>
<a name="l00805"></a>00805 <span class="stringliteral">  3) iterate [i] over the range 0 ... [codebook_dimensions]-1 (once for each scalar value in the value vector) {</span>
<a name="l00806"></a>00806 <span class="stringliteral"></span>
<a name="l00807"></a>00807 <span class="stringliteral">       4) vector [value_vector] element [i] = </span>
<a name="l00808"></a>00808 <span class="stringliteral">            ( [codebook_multiplicands] array element number [multiplicand_offset] ) *</span>
<a name="l00809"></a>00809 <span class="stringliteral">            [codebook_delta_value] + [codebook_minimum_value] + [last];</span>
<a name="l00810"></a>00810 <span class="stringliteral"></span>
<a name="l00811"></a>00811 <span class="stringliteral">       5) if ( [codebook_sequence_p] is set ) then set [last] = vector [value_vector] element [i] </span>
<a name="l00812"></a>00812 <span class="stringliteral"></span>
<a name="l00813"></a>00813 <span class="stringliteral">       6) increment [multiplicand_offset]</span>
<a name="l00814"></a>00814 <span class="stringliteral"></span>
<a name="l00815"></a>00815 <span class="stringliteral">     }</span>
<a name="l00816"></a>00816 <span class="stringliteral"> </span>
<a name="l00817"></a>00817 <span class="stringliteral">  7) vector calculation completed.</span>
<a name="l00818"></a>00818 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2450655&quot;&gt;&lt;/a&gt;3.3. Use of the codebook abstraction&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00819"></a>00819 <span class="stringliteral">The decoder uses the codebook abstraction much as it does the</span>
<a name="l00820"></a>00820 <span class="stringliteral">bit-unpacking convention; a specific codebook reads a</span>
<a name="l00821"></a>00821 <span class="stringliteral">codeword from the bitstream, decoding it into an entry number, and then</span>
<a name="l00822"></a>00822 <span class="stringliteral">returns that entry number to the decoder (when used in a scalar</span>
<a name="l00823"></a>00823 <span class="stringliteral">entropy coding context), or uses that entry number as an offset into</span>
<a name="l00824"></a>00824 <span class="stringliteral">the VQ lookup table, returning a vector of values (when used in a context</span>
<a name="l00825"></a>00825 <span class="stringliteral">desiring a VQ value). Scalar or VQ context is always explicit; any call</span>
<a name="l00826"></a>00826 <span class="stringliteral">to the codebook mechanism requests either a scalar entry number or a</span>
<a name="l00827"></a>00827 <span class="stringliteral">lookup vector.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00828"></a>00828 <span class="stringliteral">Note that VQ lookup type zero indicates that there is no lookup table;</span>
<a name="l00829"></a>00829 <span class="stringliteral">requesting decode using a codebook of lookup type 0 in any context</span>
<a name="l00830"></a>00830 <span class="stringliteral">expecting a vector return value (even in a case where a vector of</span>
<a name="l00831"></a>00831 <span class="stringliteral">dimension one) is forbidden.  If decoder setup or decode requests such</span>
<a name="l00832"></a>00832 <span class="stringliteral">an action, that is an error condition rendering the packet</span>
<a name="l00833"></a>00833 <span class="stringliteral">undecodable.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00834"></a>00834 <span class="stringliteral">Using a codebook to read from the packet bitstream consists first of</span>
<a name="l00835"></a>00835 <span class="stringliteral">reading and decoding the next codeword in the bitstream. The decoder</span>
<a name="l00836"></a>00836 <span class="stringliteral">reads bits until the accumulated bits match a codeword in the</span>
<a name="l00837"></a>00837 <span class="stringliteral">codebook.  This process can be though of as logically walking the</span>
<a name="l00838"></a>00838 <span class="stringliteral">Huffman decode tree by reading one bit at a time from the bitstream,</span>
<a name="l00839"></a>00839 <span class="stringliteral">and using the bit as a decision boolean to take the 0 branch (left in</span>
<a name="l00840"></a>00840 <span class="stringliteral">the above examples) or the 1 branch (right in the above examples).</span>
<a name="l00841"></a>00841 <span class="stringliteral">Walking the tree finishes when the decode process hits a leaf in the</span>
<a name="l00842"></a>00842 <span class="stringliteral">decision tree; the result is the entry number corresponding to that</span>
<a name="l00843"></a>00843 <span class="stringliteral">leaf.  Reading past the end of a packet propagates the &#39;</span>end-of-stream<span class="stringliteral">&#39;</span>
<a name="l00844"></a>00844 <span class="stringliteral">condition to the decoder.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00845"></a>00845 <span class="stringliteral">When used in a scalar context, the resulting codeword entry is the</span>
<a name="l00846"></a>00846 <span class="stringliteral">desired return value.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00847"></a>00847 <span class="stringliteral">When used in a VQ context, the codeword entry number is used as an</span>
<a name="l00848"></a>00848 <span class="stringliteral">offset into the VQ lookup table.  The value returned to the decoder is</span>
<a name="l00849"></a>00849 <span class="stringliteral">the vector of scalars corresponding to this offset.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-codec&quot;&gt;&lt;/a&gt;4. Codec Setup and Packet Decode&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;</span>
<a name="l00850"></a>00850 <span class="stringliteral"> $Id: 04-codec.xml 10466 2005-11-28 00:34:44Z giles $</span>
<a name="l00851"></a>00851 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2512199&quot;&gt;&lt;/a&gt;4.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00852"></a>00852 <span class="stringliteral">This document serves as the top-level reference document for the</span>
<a name="l00853"></a>00853 <span class="stringliteral">bit-by-bit decode specification of Vorbis I.  This document assumes a</span>
<a name="l00854"></a>00854 <span class="stringliteral">high-level understanding of the Vorbis decode process, which is</span>
<a name="l00855"></a>00855 <span class="stringliteral">provided in &lt;a href=&quot;#vorbis-spec-intro&quot; title=&quot;1. Introduction and Description&quot;&gt;Section 1, &amp;#8220;Introduction and Description&amp;#8221;&lt;/a&gt;.  &lt;a href=&quot;#vorbis-spec-bitpacking&quot; title=&quot;2. Bitpacking Convention&quot;&gt;Section 2, &amp;#8220;Bitpacking Convention&amp;#8221;&lt;/a&gt; covers reading and writing bit fields from</span>
<a name="l00856"></a>00856 <span class="stringliteral">and to bitstream packets.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2531940&quot;&gt;&lt;/a&gt;4.2. Header decode and decode setup&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00857"></a>00857 <span class="stringliteral">A Vorbis bitstream begins with three header packets. The header</span>
<a name="l00858"></a>00858 <span class="stringliteral">packets are, in order, the identification header, the comments header,</span>
<a name="l00859"></a>00859 <span class="stringliteral">and the setup header. All are required for decode compliance.  An</span>
<a name="l00860"></a>00860 <span class="stringliteral">end-of-packet condition during decoding the first or third header</span>
<a name="l00861"></a>00861 <span class="stringliteral">packet renders the stream undecodable.  End-of-packet decoding the</span>
<a name="l00862"></a>00862 <span class="stringliteral">comment header is a non-fatal error condition.&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2531581&quot;&gt;&lt;/a&gt;4.2.1. Common header decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00863"></a>00863 <span class="stringliteral">Each header packet begins with the same header fields.</span>
<a name="l00864"></a>00864 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00865"></a>00865 <span class="stringliteral">  1) [packet_type] : 8 bit value</span>
<a name="l00866"></a>00866 <span class="stringliteral">  2) 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73: the characters &#39;</span>v<span class="charliteral">&#39;,&#39;</span>o<span class="charliteral">&#39;,&#39;</span>r<span class="charliteral">&#39;,&#39;</span>b<span class="charliteral">&#39;,&#39;</span>i<span class="charliteral">&#39;,&#39;</span>s<span class="stringliteral">&#39; as six octets</span>
<a name="l00867"></a>00867 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00868"></a>00868 <span class="stringliteral">Decode continues according to packet type; the identification header</span>
<a name="l00869"></a>00869 <span class="stringliteral">is type 1, the comment header type 3 and the setup header type 5</span>
<a name="l00870"></a>00870 <span class="stringliteral">(these types are all odd as a packet with a leading single bit of &#39;</span>0<span class="stringliteral">&#39;</span>
<a name="l00871"></a>00871 <span class="stringliteral">is an audio packet).  The packets must occur in the order of</span>
<a name="l00872"></a>00872 <span class="stringliteral">identification, comment, setup.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2522768&quot;&gt;&lt;/a&gt;4.2.2. Identification header&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00873"></a>00873 <span class="stringliteral">The identification header is a short header of only a few fields used</span>
<a name="l00874"></a>00874 <span class="stringliteral">to declare the stream definitively as Vorbis, and provide a few externally</span>
<a name="l00875"></a>00875 <span class="stringliteral">relevant pieces of information about the audio stream. The</span>
<a name="l00876"></a>00876 <span class="stringliteral">identification header is coded as follows:&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l00877"></a>00877 <span class="stringliteral"> 1) [vorbis_version] = read 32 bits as unsigned integer</span>
<a name="l00878"></a>00878 <span class="stringliteral"> 2) [audio_channels] = read 8 bit integer as unsigned</span>
<a name="l00879"></a>00879 <span class="stringliteral"> 3) [audio_sample_rate] = read 32 bits as unsigned integer</span>
<a name="l00880"></a>00880 <span class="stringliteral"> 4) [bitrate_maximum] = read 32 bits as signed integer</span>
<a name="l00881"></a>00881 <span class="stringliteral"> 5) [bitrate_nominal] = read 32 bits as signed integer</span>
<a name="l00882"></a>00882 <span class="stringliteral"> 6) [bitrate_minimum] = read 32 bits as signed integer</span>
<a name="l00883"></a>00883 <span class="stringliteral"> 7) [blocksize_0] = 2 exponent (read 4 bits as unsigned integer)</span>
<a name="l00884"></a>00884 <span class="stringliteral"> 8) [blocksize_1] = 2 exponent (read 4 bits as unsigned integer)</span>
<a name="l00885"></a>00885 <span class="stringliteral"> 9) [framing_flag] = read one bit</span>
<a name="l00886"></a>00886 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l00887"></a>00887 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[vorbis_version]&lt;/code&gt; is to read &#39;</span>0<span class="stringliteral">&#39; in order to be compatible</span>
<a name="l00888"></a>00888 <span class="stringliteral">with this document.  Both &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt; and</span>
<a name="l00889"></a>00889 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[audio_sample_rate]&lt;/code&gt; must read greater than zero.  Allowed final</span>
<a name="l00890"></a>00890 <span class="stringliteral">blocksize values are 64, 128, 256, 512, 1024, 2048, 4096 and 8192 in</span>
<a name="l00891"></a>00891 <span class="stringliteral">Vorbis I.  &lt;code class=&quot;varname&quot;&gt;[blocksize_0]&lt;/code&gt; must be less than or equal to</span>
<a name="l00892"></a>00892 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[blocksize_1]&lt;/code&gt;.  The framing bit must be nonzero.  Failure to</span>
<a name="l00893"></a>00893 <span class="stringliteral">meet any of these conditions renders a stream undecodable.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00894"></a>00894 <span class="stringliteral">The bitrate fields above are used only as hints. The nominal bitrate</span>
<a name="l00895"></a>00895 <span class="stringliteral">field especially may be considerably off in purely VBR streams.  The</span>
<a name="l00896"></a>00896 <span class="stringliteral">fields are meaningful only when greater than zero.&lt;/p&gt;&lt;p&gt;</span>
<a name="l00897"></a>00897 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;All three fields set to the same value implies a fixed rate, or tightly bounded, nearly fixed-rate bitstream&lt;/li&gt;&lt;li&gt;Only nominal set implies a VBR or ABR stream that averages the nominal bitrate&lt;/li&gt;&lt;li&gt;Maximum and or minimum set implies a VBR bitstream that obeys the bitrate limits&lt;/li&gt;&lt;li&gt;None set indicates the encoder does not care to speculate.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00898"></a>00898 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2505902&quot;&gt;&lt;/a&gt;4.2.3. Comment header&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00899"></a>00899 <span class="stringliteral">Comment header decode and data specification is covered in</span>
<a name="l00900"></a>00900 <span class="stringliteral">&lt;a href=&quot;#vorbis-spec-comment&quot; title=&quot;5. comment field and header specification&quot;&gt;Section 5, &amp;#8220;comment field and header specification&amp;#8221;&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2505916&quot;&gt;&lt;/a&gt;4.2.4. Setup header&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00901"></a>00901 <span class="stringliteral">Vorbis codec setup is configurable to an extreme degree:</span>
<a name="l00902"></a>00902 <span class="stringliteral"></span>
<a name="l00903"></a>00903 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;components.png&quot; alt=&quot;[decoder pipeline configuration]&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00904"></a>00904 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l00905"></a>00905 <span class="stringliteral">The setup header contains the bulk of the codec setup information</span>
<a name="l00906"></a>00906 <span class="stringliteral">needed for decode.  The setup header contains, in order, the lists of</span>
<a name="l00907"></a>00907 <span class="stringliteral">codebook configurations, time-domain transform configurations</span>
<a name="l00908"></a>00908 <span class="stringliteral">(placeholders in Vorbis I), floor configurations, residue</span>
<a name="l00909"></a>00909 <span class="stringliteral">configurations, channel mapping configurations and mode</span>
<a name="l00910"></a>00910 <span class="stringliteral">configurations. It finishes with a framing bit of &#39;</span>1<span class="stringliteral">&#39;.  Header decode</span>
<a name="l00911"></a>00911 <span class="stringliteral">proceeds in the following order:&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2524640&quot;&gt;&lt;/a&gt;4.2.4.1. Codebooks&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_codebook_count]&lt;/code&gt; = read eight bits as unsigned integer and add one&lt;/li&gt;&lt;li&gt;Decode &lt;code class=&quot;varname&quot;&gt;[vorbis_codebook_count]&lt;/code&gt; codebooks in order as defined</span>
<a name="l00912"></a>00912 <span class="stringliteral">in &lt;a href=&quot;#vorbis-spec-codebook&quot; title=&quot;3. Probability Model and Codebooks&quot;&gt;Section 3, &amp;#8220;Probability Model and Codebooks&amp;#8221;&lt;/a&gt;.  Save each configuration, in</span>
<a name="l00913"></a>00913 <span class="stringliteral">order, in an array of</span>
<a name="l00914"></a>00914 <span class="stringliteral">codebook configurations &lt;code class=&quot;varname&quot;&gt;[vorbis_codebook_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2524679&quot;&gt;&lt;/a&gt;4.2.4.2. Time domain transforms&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00915"></a>00915 <span class="stringliteral">These hooks are placeholders in Vorbis I.  Nevertheless, the</span>
<a name="l00916"></a>00916 <span class="stringliteral">configuration placeholder values must be read to maintain bitstream</span>
<a name="l00917"></a>00917 <span class="stringliteral">sync.&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_time_count]&lt;/code&gt; = read 6 bits as unsigned integer and add one&lt;/li&gt;&lt;li&gt;read &lt;code class=&quot;varname&quot;&gt;[vorbis_time_count]&lt;/code&gt; 16 bit values; each value should be zero.  If any value is nonzero, this is an error condition and the stream is undecodable.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2524718&quot;&gt;&lt;/a&gt;4.2.4.3. Floors&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00918"></a>00918 <span class="stringliteral">Vorbis uses two floor types; header decode is handed to the decode</span>
<a name="l00919"></a>00919 <span class="stringliteral">abstraction of the appropriate type.&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_floor_count]&lt;/code&gt; = read 6 bits as unsigned integer and add one&lt;/li&gt;&lt;li&gt;&lt;p&gt;For each &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of &lt;code class=&quot;varname&quot;&gt;[vorbis_floor_count]&lt;/code&gt; floor numbers:</span>
<a name="l00920"></a>00920 <span class="stringliteral">  &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;read the floor type: vector &lt;code class=&quot;varname&quot;&gt;[vorbis_floor_types]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; =</span>
<a name="l00921"></a>00921 <span class="stringliteral">read 16 bits as unsigned integer&lt;/li&gt;&lt;li&gt;If the floor type is zero, decode the floor</span>
<a name="l00922"></a>00922 <span class="stringliteral">configuration as defined in &lt;a href=&quot;#vorbis-spec-floor0&quot; title=&quot;6. Floor type 0 setup and decode&quot;&gt;Section 6, &amp;#8220;Floor type 0 setup and decode&amp;#8221;&lt;/a&gt;; save</span>
<a name="l00923"></a>00923 <span class="stringliteral">this</span>
<a name="l00924"></a>00924 <span class="stringliteral">configuration in slot &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of the floor configuration array &lt;code class=&quot;varname&quot;&gt;[vorbis_floor_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;If the floor type is one,</span>
<a name="l00925"></a>00925 <span class="stringliteral">decode the floor configuration as defined in &lt;a href=&quot;#vorbis-spec-floor1&quot; title=&quot;7. Floor type 1 setup and decode&quot;&gt;Section 7, &amp;#8220;Floor type 1 setup and decode&amp;#8221;&lt;/a&gt;; save this configuration in slot &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of the floor configuration array &lt;code class=&quot;varname&quot;&gt;[vorbis_floor_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;If the the floor type is greater than one, this stream is undecodable; ERROR CONDITION&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00926"></a>00926 <span class="stringliteral"> &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2510370&quot;&gt;&lt;/a&gt;4.2.4.4. Residues&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00927"></a>00927 <span class="stringliteral">Vorbis uses three residue types; header decode of each type is identical.</span>
<a name="l00928"></a>00928 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_residue_count]&lt;/code&gt; = read 6 bits as unsigned integer and add one</span>
<a name="l00929"></a>00929 <span class="stringliteral">&lt;/li&gt;&lt;li&gt;&lt;p&gt;For each of &lt;code class=&quot;varname&quot;&gt;[vorbis_residue_count]&lt;/code&gt; residue numbers:</span>
<a name="l00930"></a>00930 <span class="stringliteral"> &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;read the residue type; vector &lt;code class=&quot;varname&quot;&gt;[vorbis_residue_types]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; = read 16 bits as unsigned integer&lt;/li&gt;&lt;li&gt;If the residue type is zero,</span>
<a name="l00931"></a>00931 <span class="stringliteral">one or two, decode the residue configuration as defined in &lt;a href=&quot;#vorbis-spec-residue&quot; title=&quot;8. Residue setup and decode&quot;&gt;Section 8, &amp;#8220;Residue setup and decode&amp;#8221;&lt;/a&gt;; save this configuration in slot &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of the residue configuration array &lt;code class=&quot;varname&quot;&gt;[vorbis_residue_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;If the the residue type is greater than two, this stream is undecodable; ERROR CONDITION&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00932"></a>00932 <span class="stringliteral">&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2510452&quot;&gt;&lt;/a&gt;4.2.4.5. Mappings&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l00933"></a>00933 <span class="stringliteral">Mappings are used to set up specific pipelines for encoding</span>
<a name="l00934"></a>00934 <span class="stringliteral">multichannel audio with varying channel mapping applications. Vorbis I</span>
<a name="l00935"></a>00935 <span class="stringliteral">uses a single mapping type (0), with implicit PCM channel mappings.&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_count]&lt;/code&gt; = read 6 bits as unsigned integer and add one&lt;/li&gt;&lt;li&gt;&lt;p&gt;For each &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_count]&lt;/code&gt; mapping numbers:</span>
<a name="l00936"></a>00936 <span class="stringliteral">  &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;read the mapping type: 16 bits as unsigned integer.  There&#39;</span>s no reason to save the mapping type in Vorbis I.&lt;/li&gt;&lt;li&gt;If the mapping type is nonzero, the stream is undecodable&lt;/li&gt;&lt;li&gt;&lt;p&gt;If the mapping type is zero:
<a name="l00937"></a>00937     &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;i&quot;</span>&gt;&lt;li&gt;&lt;p&gt;read 1 bit as a <span class="keywordtype">boolean</span> flag
<a name="l00938"></a>00938       &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;A&quot;</span>&gt;&lt;li&gt;<span class="keywordflow">if</span> <span class="keyword">set</span>, &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_submaps]&lt;/code&gt; = read 4 bits as <span class="keywordtype">unsigned</span> integer and add one&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> unset, &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_submaps]&lt;/code&gt; = 1&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00939"></a>00939       &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;read 1 bit as a <span class="keywordtype">boolean</span> flag
<a name="l00940"></a>00940        &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;A&quot;</span>&gt;&lt;li&gt;&lt;p&gt;<span class="keywordflow">if</span> <span class="keyword">set</span>, square polar channel mapping is in use:
<a name="l00941"></a>00941            &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;I&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_coupling_steps]&lt;/code&gt; = read 8 bits as <span class="keywordtype">unsigned</span> integer and add one&lt;/li&gt;&lt;li&gt;&lt;p&gt;<span class="keywordflow">for</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[j]&lt;/code&gt; each of &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_coupling_steps]&lt;/code&gt; steps:
<a name="l00942"></a>00942                &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;1&quot;</span>&gt;&lt;li&gt;vector &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_magnitude]&lt;/code&gt; element &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[j]&lt;/code&gt;= read &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-ilog&quot;</span> title=<span class="stringliteral">&quot;9.2.1. ilog&quot;</span>&gt;ilog&lt;/a&gt;(&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[audio_channels]&lt;/code&gt; - 1) bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_angle]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt;= read &lt;a href=&quot;#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;(&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[audio_channels]&lt;/code&gt; - 1) bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;the numbers read in the above two steps are channel numbers representing the channel to treat as magnitude and the channel to treat as angle, respectively.  If <a class="code" href="interfacefor.html">for</a> any coupling step the angle channel number equals the magnitude channel number, the magnitude channel number is greater than &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt;-1, or the angle channel is greater than &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt;-1, the stream is undecodable.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00943"></a>00943                &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00944"></a>00944            &lt;/p&gt;&lt;/li&gt;&lt;li&gt;if unset, &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_coupling_steps]&lt;/code&gt; = 0&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00945"></a>00945        &lt;/p&gt;&lt;/li&gt;&lt;li&gt;read 2 bits (reserved field); if the value is nonzero, the stream is undecodable&lt;/li&gt;&lt;li&gt;&lt;p&gt;if &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submaps]&lt;/code&gt; is greater than one, we read channel multiplex settings. For each &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; of &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt; channels:&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_mux]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; = read 4 bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;if the value is greater than the highest numbered submap (&lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submaps]&lt;/code&gt; - 1), this in an error condition rendering the stream undecodable&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a class="code" href="interfacefor.html">for</a> each submap &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; of &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submaps]&lt;/code&gt; submaps, read the floor and residue numbers <a class="code" href="interfacefor.html">for</a> use in decoding that submap:&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;read and discard 8 bits (the unused time configuration placeholder)&lt;/li&gt;&lt;li&gt;read 8 bits as <span class="keywordtype">unsigned</span> integer <a class="code" href="interfacefor.html">for</a> the floor number; save in vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submap_floor]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;verify the floor number is not greater than the highest number floor configured <a class="code" href="interfacefor.html">for</a> the bitstream. If it is, the bitstream is undecodable&lt;/li&gt;&lt;li&gt;read 8 bits as <span class="keywordtype">unsigned</span> integer <a class="code" href="interfacefor.html">for</a> the residue number; save in vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submap_residue]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;verify the residue number is not greater than the highest number residue configured <a class="code" href="interfacefor.html">for</a> the bitstream.  If it is, the bitstream is undecodable&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;save this mapping configuration in slot &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of the mapping configuration array &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00946"></a>00946  &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2528009&quot;&gt;&lt;/a&gt;4.2.4.6. Modes&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mode_count]&lt;/code&gt; = read 6 bits as <span class="keywordtype">unsigned</span> integer and add one&lt;/li&gt;&lt;li&gt;&lt;p&gt;For each of &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_count]&lt;/code&gt; mode numbers:&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mode_blockflag]&lt;/code&gt; = read 1 bit&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mode_windowtype]&lt;/code&gt; = read 16 bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mode_transformtype]&lt;/code&gt; = read 16 bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[vorbis_mode_mapping]&lt;/code&gt; = read 8 bits as <span class="keywordtype">unsigned</span> integer&lt;/li&gt;&lt;li&gt;verify ranges; zero is the only legal value in Vorbis I <a class="code" href="interfacefor.html">for</a>
<a name="l00947"></a>00947 &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_windowtype]&lt;/code&gt;
<a name="l00948"></a>00948 and &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_transformtype]&lt;/code&gt;.  &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_mapping]&lt;/code&gt; must not be greater than the highest number mapping in use.  Any illegal values render the stream undecodable.&lt;/li&gt;&lt;li&gt;save this mode configuration in slot &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of the mode configuration array
<a name="l00949"></a>00949 &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_configurations]&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;read 1 bit as a framing flag.  If unset, a framing error occurred and the stream is not
<a name="l00950"></a>00950 decodable.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00951"></a>00951 After reading mode descriptions, setup header decode is complete.
<a name="l00952"></a>00952 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2545699&quot;&gt;&lt;/a&gt;4.3. Audio packet decode and synthesis&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00953"></a>00953 Following the three header packets, all packets in a Vorbis I stream
<a name="l00954"></a>00954 are audio.  The first step of audio packet decode is to read and
<a name="l00955"></a>00955 verify the packet type. &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;A non-audio packet when audio is expected
<a name="l00956"></a>00956 indicates stream corruption or a non-compliant stream. The decoder
<a name="l00957"></a>00957 must ignore the packet and not attempt decoding it to audio&lt;/em&gt;&lt;/span&gt;.
<a name="l00958"></a>00958 &lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2545717&quot;&gt;&lt;/a&gt;4.3.1. packet type, mode and window decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;read 1 bit &lt;code class=&quot;varname&quot;&gt;[packet_type]&lt;/code&gt;; check that packet type is 0 (audio)&lt;/li&gt;&lt;li&gt;read &lt;a href=&quot;<span class="preprocessor">#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;([vorbis_mode_count]-1) bits</span>
<a name="l00959"></a>00959 <span class="preprocessor"></span>&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[mode_number]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;decode blocksize &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt; is equal to &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt; <span class="keywordflow">if</span> 
<a name="l00960"></a>00960 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mode_blockflag]&lt;/code&gt; is 0, <span class="keywordflow">else</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt; is equal to &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_1]&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;p&gt;perform window selection and setup; <span class="keyword">this</span> window is used later by the inverse MDCT:&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;p&gt;<span class="keywordflow">if</span> <span class="keyword">this</span> is a <span class="keywordtype">long</span> window (the &lt;code class=&quot;varname&quot;&gt;[vorbis_mode_blockflag]&lt;/code&gt; flag of <span class="keyword">this</span> mode is
<a name="l00961"></a>00961 <span class="keyword">set</span>):&lt;/p&gt;&lt;div class=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;i&quot;</span>&gt;&lt;li&gt;read 1 bit <a class="code" href="interfacefor.html">for</a> &lt;code class=<span class="stringliteral">&quot;varname&quot;</span>&gt;[previous_window_flag]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;read 1 bit <a class="code" href="interfacefor.html">for</a> &lt;code class=<span class="stringliteral">&quot;varname&quot;</span>&gt;[next_window_flag]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;if &lt;code class=<span class="stringliteral">&quot;varname&quot;</span>&gt;[previous_window_flag]&lt;/code&gt; is not set, the left half
<a name="l00962"></a>00962          of the window will be a hybrid window <a class="code" href="interfacefor.html">for</a> lapping with a
<a name="l00963"></a>00963          short block.  See &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-window&quot;</span> title=<span class="stringliteral">&quot;1.3.2.3. Window shape decode (long windows only)&quot;</span>&gt;Section 1.3.2.3, &amp;#8220;Window shape decode (<span class="keywordtype">long</span> windows only)&amp;#8221;&lt;/a&gt; <span class="keywordflow">for</span> an illustration of overlapping
<a name="l00964"></a>00964 dissimilar
<a name="l00965"></a>00965          windows. Else, the left half window will have normal <span class="keywordtype">long</span>
<a name="l00966"></a>00966          shape.&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[next_window_flag]&lt;/code&gt; is not <span class="keyword">set</span>, the right half of
<a name="l00967"></a>00967          the window will be a hybrid window <span class="keywordflow">for</span> lapping with a <span class="keywordtype">short</span>
<a name="l00968"></a>00968          block.  See &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-window&quot;</span> title=<span class="stringliteral">&quot;1.3.2.3. Window shape decode (long windows only)&quot;</span>&gt;Section 1.3.2.3, &amp;#8220;Window shape decode (<span class="keywordtype">long</span> windows only)&amp;#8221;&lt;/a&gt; <span class="keywordflow">for</span> an
<a name="l00969"></a>00969 illustration of overlapping dissimilar
<a name="l00970"></a>00970          windows. Else, the left right window will have normal <span class="keywordtype">long</span>
<a name="l00971"></a>00971          shape.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt; <span class="keywordflow">if</span> <span class="keyword">this</span> is a <span class="keywordtype">short</span> window, the window is always the same 
<a name="l00972"></a>00972        <span class="keywordtype">short</span>-window shape.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00973"></a>00973 Vorbis windows all use the slope function y=sin(0.5 * &amp;#960; * sin^2((x+.5)/n * &amp;#960;)),
<a name="l00974"></a>00974 where n is window size and x ranges 0...n-1, but dissimilar
<a name="l00975"></a>00975 lapping requirements can affect overall shape.  Window generation
<a name="l00976"></a>00976 proceeds as follows:&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;1&quot;</span>&gt;&lt;li&gt; &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[window_center]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt; / 2&lt;/li&gt;&lt;li&gt;&lt;p&gt; <span class="keywordflow">if</span> (&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mode_blockflag]&lt;/code&gt; is <span class="keyword">set</span> and &lt;code class=&quot;varname&quot;&gt;[previous_window_flag]&lt;/code&gt; is
<a name="l00977"></a>00977 not <span class="keyword">set</span>) then
<a name="l00978"></a>00978   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_start]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;/4 -
<a name="l00979"></a>00979 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/4&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_end]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;/4 + &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/4&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_n]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/2&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00980"></a>00980  <span class="keywordflow">else</span>
<a name="l00981"></a>00981   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_start]&lt;/code&gt; = 0&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_end]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[window_center]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_n]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;/2&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; <span class="keywordflow">if</span> (&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mode_blockflag]&lt;/code&gt; is <span class="keyword">set</span> and &lt;code class=&quot;varname&quot;&gt;[next_window_flag]&lt;/code&gt; is not
<a name="l00982"></a>00982 <span class="keyword">set</span>) then 
<a name="l00983"></a>00983   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]*3&lt;/code&gt;/4 -
<a name="l00984"></a>00984 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/4&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_end]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]*3&lt;/code&gt;/4 +
<a name="l00985"></a>00985 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/4&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_n]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[blocksize_0]&lt;/code&gt;/2&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00986"></a>00986  <span class="keywordflow">else</span>
<a name="l00987"></a>00987   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[window_center]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_end]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_n]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;/2&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt; window from range 0 ... &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_start]&lt;/code&gt;-1 inclusive is zero&lt;/li&gt;&lt;li&gt; <span class="keywordflow">for</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; in range &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_start]&lt;/code&gt; ...
<a name="l00988"></a>00988 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_end]&lt;/code&gt;-1, window(&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;) = sin(.5 * &amp;#960; * sin^2( (&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;-&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_start]&lt;/code&gt;+.5) / &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_n]&lt;/code&gt; * .5 * &amp;#960;) )&lt;/li&gt;&lt;li&gt; window from range &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[left_window_end]&lt;/code&gt; ... &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt;-1
<a name="l00989"></a>00989 inclusive is one&lt;/li&gt;&lt;li&gt; <span class="keywordflow">for</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; in range &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt; ... &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_end]&lt;/code&gt;-1, window(&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;) = sin(.5 * &amp;#960; * sin^2( (&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;-&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt;+.5) / &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_n]&lt;/code&gt; * .5 * &amp;#960; + .5 * &amp;#960;) )&lt;/li&gt;&lt;li&gt; window from range &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[right_window_start]&lt;/code&gt; ... &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt;-1 is
<a name="l00990"></a>00990 zero&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00991"></a>00991 An end-of-packet condition up to <span class="keyword">this</span> point should be considered an
<a name="l00992"></a>00992 error that discards <span class="keyword">this</span> packet from the stream.  An end of packet
<a name="l00993"></a>00993 condition past <span class="keyword">this</span> point is to be considered a possible nominal
<a name="l00994"></a>00994 occurrence.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2546181&quot;</span>&gt;&lt;/a&gt;4.3.2. floor curve decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l00995"></a>00995 From <span class="keyword">this</span> point on, we assume out decode context is <span class="keyword">using</span> mode number
<a name="l00996"></a>00996 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[mode_number]&lt;/code&gt; from configuration array
<a name="l00997"></a>00997 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mode_configurations]&lt;/code&gt; and the map number
<a name="l00998"></a>00998 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mode_mapping]&lt;/code&gt; (specified by the current mode) taken
<a name="l00999"></a>00999 from the mapping configuration array
<a name="l01000"></a>01000 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_configurations]&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;
<a name="l01001"></a>01001 Floor curves are decoded one-by-one in channel order.&lt;/p&gt;&lt;p&gt;
<a name="l01002"></a>01002 For each floor &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt;
<a name="l01003"></a>01003  &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;1&quot;</span>&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[submap_number]&lt;/code&gt; = element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; of vector [vorbis_mapping_mux]&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor_number]&lt;/code&gt; = element &lt;code class=&quot;varname&quot;&gt;[submap_number]&lt;/code&gt; of vector
<a name="l01004"></a>01004 [vorbis_submap_floor]&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> the floor type of <span class="keyword">this</span>
<a name="l01005"></a>01005 floor (vector &lt;code class=&quot;varname&quot;&gt;[vorbis_floor_types]&lt;/code&gt; element
<a name="l01006"></a>01006 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor_number]&lt;/code&gt;) is zero then decode the floor <span class="keywordflow">for</span>
<a name="l01007"></a>01007 channel &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; according to the
<a name="l01008"></a>01008 &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-floor0-decode&quot;</span> title=<span class="stringliteral">&quot;6.2.2. packet decode&quot;</span>&gt;Section 6.2.2, &amp;#8220;packet decode&amp;#8221;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> the type of <span class="keyword">this</span> floor
<a name="l01009"></a>01009 is one then decode the floor <span class="keywordflow">for</span> channel &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; according
<a name="l01010"></a>01010 to the &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-floor1-decode&quot;</span> title=<span class="stringliteral">&quot;7.2.2.1. packet decode&quot;</span>&gt;Section 7.2.2.1, &amp;#8220;packet decode&amp;#8221;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;save the needed decoded floor information <span class="keywordflow">for</span> channel <span class="keywordflow">for</span> later synthesis&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> the decoded floor returned <span class="stringliteral">&#39;unused&#39;</span>, <span class="keyword">set</span> vector &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[no_residue]&lt;/code&gt; element
<a name="l01011"></a>01011 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; to <span class="keyword">true</span>, <span class="keywordflow">else</span> <span class="keyword">set</span> vector &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[no_residue]&lt;/code&gt; element &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; to
<a name="l01012"></a>01012 <span class="keyword">false</span>&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01013"></a>01013 &lt;/p&gt;&lt;p&gt;
<a name="l01014"></a>01014 An end-of-packet condition during floor decode shall result in packet
<a name="l01015"></a>01015 decode zeroing all channel output vectors and skipping to the
<a name="l01016"></a>01016 add/overlap output stage.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2546321&quot;</span>&gt;&lt;/a&gt;4.3.3. nonzero vector propagate&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01017"></a>01017 A possible result of floor decode is that a specific vector is marked
<a name="l01018"></a>01018 <span class="stringliteral">&#39;unused&#39;</span> which indicates that that <span class="keyword">final</span> output vector is all-zero
<a name="l01019"></a>01019 values (and the floor is zero).  The residue <span class="keywordflow">for</span> that vector is not
<a name="l01020"></a>01020 coded in the stream, save <span class="keywordflow">for</span> one complication.  If some vectors are
<a name="l01021"></a>01021 used and some are not, channel coupling could result in mixing a
<a name="l01022"></a>01022 zeroed and nonzeroed vector to produce two nonzeroed vectors.&lt;/p&gt;&lt;p&gt;
<a name="l01023"></a>01023 <span class="keywordflow">for each</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; from 0 ... &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_coupling_steps]&lt;/code&gt;-1
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;1&quot;</span>&gt;&lt;li&gt;<span class="keywordflow">if</span> either &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[no_residue]&lt;/code&gt; entry <span class="keywordflow">for</span> channel
<a name="l01026"></a>01026 (&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[vorbis_mapping_magnitude]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)
<a name="l01027"></a>01027 or channel
<a name="l01028"></a>01028 (&lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_angle]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)
<a name="l01029"></a>01029 are set to false, then both must be set to false.  Note that an &#39;unused&#39; 
<a name="l01030"></a>01030 floor has no decoded floor information; it is important that this is 
<a name="l01031"></a>01031 remembered at floor curve synthesis time.&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01032"></a>01032 &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2546383&quot;&gt;&lt;/a&gt;4.3.4. residue decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01033"></a>01033 Unlike floors, which are decoded in channel order, the residue vectors
<a name="l01034"></a>01034 are decoded in submap order.&lt;/p&gt;&lt;p&gt;
<a name="l01035"></a>01035 <a class="code" href="interfacefor.html">for</a> each submap &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; in order from 0 ... &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submaps]&lt;/code&gt;-1&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; = 0&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a class="code" href="interfacefor.html">for</a> each channel &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; in order from 0 ... &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt; - 1&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;&lt;p&gt;if channel &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; in submap &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; (vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_mux]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; is equal to &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;&lt;p&gt;if vector &lt;code class=&quot;varname&quot;&gt;[no_residue]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; is true
<a name="l01036"></a>01036       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;vector &lt;code class=&quot;varname&quot;&gt;[do_not_decode_flag]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; is set&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01037"></a>01037      else
<a name="l01038"></a>01038       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;vector &lt;code class=&quot;varname&quot;&gt;[do_not_decode_flag]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; is unset&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;increment &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[residue_number]&lt;/code&gt; = vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_submap_residue]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[residue_type]&lt;/code&gt; = vector &lt;code class=&quot;varname&quot;&gt;[vorbis_residue_types]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[residue_number]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;decode &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; vectors using residue &lt;code class=&quot;varname&quot;&gt;[residue_number]&lt;/code&gt;, according to type &lt;code class=&quot;varname&quot;&gt;[residue_type]&lt;/code&gt;, also passing vector &lt;code class=&quot;varname&quot;&gt;[do_not_decode_flag]&lt;/code&gt; to indicate which vectors in the bundle should not be decoded. Correct per-vector decode length is &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt;/2.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; = 0&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a class="code" href="interfacefor.html">for</a> each channel &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; in order from 0 ... &lt;code class=&quot;varname&quot;&gt;[audio_channels]&lt;/code&gt;&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;&lt;p&gt;if channel &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; is in submap &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; (vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_mux]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; is equal to &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;residue vector <a class="code" href="interfacefor.html">for</a> channel &lt;code class=&quot;varname&quot;&gt;[j]&lt;/code&gt; is set to decoded residue vector &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;increment &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2546633&quot;&gt;&lt;/a&gt;4.3.5. inverse coupling&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01039"></a>01039 <a class="code" href="interfacefor.html">for</a> each &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; from &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_coupling_steps]&lt;/code&gt;-1 descending to 0
<a name="l01040"></a>01040 
<a name="l01041"></a>01041 &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[magnitude_vector]&lt;/code&gt; = the residue vector <a class="code" href="interfacefor.html">for</a> channel
<a name="l01042"></a>01042 (vector &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_magnitude]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[angle_vector]&lt;/code&gt; = the residue vector <a class="code" href="interfacefor.html">for</a> channel (vector
<a name="l01043"></a>01043 &lt;code class=&quot;varname&quot;&gt;[vorbis_mapping_angle]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt;)&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a class="code" href="interfacefor.html">for</a> each scalar value &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt; in vector &lt;code class=&quot;varname&quot;&gt;[magnitude_vector]&lt;/code&gt; and the corresponding scalar value &lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt; in vector &lt;code class=&quot;varname&quot;&gt;[angle_vector]&lt;/code&gt;:&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;&lt;p&gt;if (&lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt; is greater than zero)
<a name="l01044"></a>01044     &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;&lt;p&gt;if (&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt; is greater than zero)
<a name="l01045"></a>01045       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_M]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_A]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;-&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01046"></a>01046      else
<a name="l01047"></a>01047       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_A]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_M]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;+&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01048"></a>01048      &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01049"></a>01049    else
<a name="l01050"></a>01050     &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;&lt;p&gt;if (&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt; is greater than zero)
<a name="l01051"></a>01051       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_M]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_A]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;+&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01052"></a>01052      else
<a name="l01053"></a>01053       &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;A&quot;&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_A]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[new_M]&lt;/code&gt; = &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt;-&lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01054"></a>01054      &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01055"></a>01055    &lt;/p&gt;&lt;/li&gt;&lt;li&gt;set scalar value &lt;code class=&quot;varname&quot;&gt;[M]&lt;/code&gt; in vector &lt;code class=&quot;varname&quot;&gt;[magnitude_vector]&lt;/code&gt; to &lt;code class=&quot;varname&quot;&gt;[new_M]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;set scalar value &lt;code class=&quot;varname&quot;&gt;[A]&lt;/code&gt; in vector &lt;code class=&quot;varname&quot;&gt;[angle_vector]&lt;/code&gt; to &lt;code class=&quot;varname&quot;&gt;[new_A]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01056"></a>01056 &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2546883&quot;&gt;&lt;/a&gt;4.3.6. dot product&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01057"></a>01057 For each channel, synthesize the floor curve from the decoded floor
<a name="l01058"></a>01058 information, according to packet type. Note that the vector synthesis
<a name="l01059"></a>01059 length <a class="code" href="interfacefor.html">for</a> floor computation is &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt;/2.&lt;/p&gt;&lt;p&gt;
<a name="l01060"></a>01060 For each channel, multiply each element of the floor curve by each
<a name="l01061"></a>01061 element of that channel&#39;s residue vector.  The result is the dot
<a name="l01062"></a>01062 product of the floor and residue vectors <a class="code" href="interfacefor.html">for</a> each channel; the produced
<a name="l01063"></a>01063 vectors are the length &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt;/2 audio spectrum <a class="code" href="interfacefor.html">for</a> each
<a name="l01064"></a>01064 channel.&lt;/p&gt;&lt;p&gt;
<a name="l01065"></a>01065 One point is worth mentioning about this dot product; a common mistake
<a name="l01066"></a>01066 in a fixed point implementation might be to assume that a 32 bit
<a name="l01067"></a>01067 fixed-point representation <a class="code" href="interfacefor.html">for</a> floor and residue and direct
<a name="l01068"></a>01068 multiplication of the vectors is sufficient <a class="code" href="interfacefor.html">for</a> acceptable spectral
<a name="l01069"></a>01069 depth in all cases because it happens to mostly work with the current
<a name="l01070"></a>01070 Xiph.Org reference encoder. &lt;/p&gt;&lt;p&gt;
<a name="l01071"></a>01071 However, floor vector values can span ~140dB (~24 bits <span class="keywordtype">unsigned</span>), and
<a name="l01072"></a>01072 the audio spectrum vector should represent a minimum of 120dB (~21
<a name="l01073"></a>01073 bits with sign), even when output is to a 16 bit PCM device.  For the
<a name="l01074"></a>01074 residue vector to represent full scale if the floor is nailed to
<a name="l01075"></a>01075 -140dB, it must be able to span 0 to +140dB.  For the residue vector
<a name="l01076"></a>01076 to reach full scale if the floor is nailed at 0dB, it must be able to
<a name="l01077"></a>01077 represent -140dB to +0dB.  Thus, in order to handle full range
<a name="l01078"></a>01078 dynamics, a residue vector may span -140dB to +140dB entirely within
<a name="l01079"></a>01079 spec.  A 280dB range is approximately 48 bits with sign; thus the
<a name="l01080"></a>01080 residue vector must be able to represent a 48 bit range and the dot
<a name="l01081"></a>01081 product must be able to handle an effective 48 bit times 24 bit
<a name="l01082"></a>01082 multiplication.  This range may be achieved using large (64 bit or
<a name="l01083"></a>01083 larger) integers, or implementing a movable binary point
<a name="l01084"></a>01084 representation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2546936&quot;&gt;&lt;/a&gt;4.3.7. inverse MDCT&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01085"></a>01085 Convert the audio spectrum vector of each channel back into time
<a name="l01086"></a>01086 domain PCM audio via an inverse Modified Discrete Cosine Transform
<a name="l01087"></a>01087 (MDCT).  A detailed description of the MDCT is available in the paper
<a name="l01088"></a>01088 &lt;a href=&quot;http:<span class="comment">//www.iocon.com/resource/docs/ps/eusipco_corrected.ps&quot; target=&quot;_top&quot;&gt;&amp;#8220;&lt;span class=&quot;citetitle&quot;&gt;The</span>
<a name="l01089"></a>01089 use of multirate filter banks <a class="code" href="interfacefor.html">for</a> coding of high quality digital
<a name="l01090"></a>01090 audio&lt;/span&gt;&amp;<span class="preprocessor">#8221;&lt;/a&gt;, by T. Sporer, K. Brandenburg and B. Edler.  The window</span>
<a name="l01091"></a>01091 <span class="preprocessor"></span>function used <span class="keywordflow">for</span> the MDCT is the function described earlier.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2546961&quot;</span>&gt;&lt;/a&gt;4.3.8. overlap_add&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01092"></a>01092 Windowed MDCT output is overlapped and added with the right hand data
<a name="l01093"></a>01093 of the previous window such that the 3/4 point of the previous window
<a name="l01094"></a>01094 is aligned with the 1/4 point of the current window (as illustrated in
<a name="l01095"></a>01095 &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-window&quot;</span> title=<span class="stringliteral">&quot;1.3.2.3. Window shape decode (long windows only)&quot;</span>&gt;Section 1.3.2.3, &amp;#8220;Window shape decode (<span class="keywordtype">long</span> windows only)&amp;#8221;&lt;/a&gt;).  The overlapped portion
<a name="l01096"></a>01096 produced from overlapping the previous and current frame data is
<a name="l01097"></a>01097 finished data to be returned by the decoder.  This data spans from the
<a name="l01098"></a>01098 center of the previous window to the center of the current window.  In
<a name="l01099"></a>01099 the <span class="keywordflow">case</span> of same-sized windows, the amount of data to <span class="keywordflow">return</span> is
<a name="l01100"></a>01100 one-half block consisting of and only of the overlapped portions. When
<a name="l01101"></a>01101 overlapping a <span class="keywordtype">short</span> and <span class="keywordtype">long</span> window, much of the returned range does not
<a name="l01102"></a>01102 actually overlap.  This does not damage transform orthogonality.  Pay
<a name="l01103"></a>01103 attention however to returning the correct data range; the amount of
<a name="l01104"></a>01104 data to be returned is:
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;programlisting&quot;</span>&gt;
<a name="l01107"></a>01107 window_blocksize(previous_window)/4+window_blocksize(current_window)/4
<a name="l01108"></a>01108 &lt;/pre&gt;&lt;p&gt;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 from the center (element windowsize/2) of the previous window to the
<a name="l01111"></a>01111 center (element windowsize/2-1, inclusive) of the current window.&lt;/p&gt;&lt;p&gt;
<a name="l01112"></a>01112 Data is not returned from the first frame; it must be used to &#39;prime&#39;
<a name="l01113"></a>01113 the decode engine.  The encoder accounts <a class="code" href="interfacefor.html">for</a> this priming when
<a name="l01114"></a>01114 calculating PCM offsets; after the first frame, the proper PCM output
<a name="l01115"></a>01115 offset is &#39;0&#39; (as no data has been returned yet).&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2547004&quot;&gt;&lt;/a&gt;4.3.9. output channel order&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01116"></a>01116 Vorbis I specifies only a channel mapping type 0.  In mapping type 0,
<a name="l01117"></a>01117 channel mapping is implicitly defined as follows <a class="code" href="interfacefor.html">for</a> standard audio
<a name="l01118"></a>01118 applications:&lt;/p&gt;&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;one channel&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is monophonic&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;two channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is stereo.  channel order: left, right&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;three channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is a 1d-surround encoding.  channel order: left,
<a name="l01119"></a>01119 center, right&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;four channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is quadraphonic surround.  channel order: front left,
<a name="l01120"></a>01120 front right, rear left, rear right&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;five channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is five-channel surround.  channel order: front left,
<a name="l01121"></a>01121 front center, front right, rear left, rear right&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;six channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;the stream is 5.1 surround.  channel order: front left, front
<a name="l01122"></a>01122 center, front right, rear left, rear right, LFE&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;greater than six channels&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;channel use and order is defined by the application&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01123"></a>01123 Applications using Vorbis <a class="code" href="interfacefor.html">for</a> dedicated purposes may define channel
<a name="l01124"></a>01124 mapping as seen fit.  Future channel mappings (such as three and four
<a name="l01125"></a>01125 channel &lt;a href=&quot;http:<span class="comment">//www.ambisonic.net/&quot; target=&quot;_top&quot;&gt;Ambisonics&lt;/a&gt;) will</span>
<a name="l01126"></a>01126 make use of channel mappings other than mapping 0.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-comment&quot;&gt;&lt;/a&gt;5. comment field and header specification&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;
<a name="l01127"></a>01127  $Id: 05-comment.xml 10465 2005-11-28 00:33:05Z giles $
<a name="l01128"></a>01128 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2541891&quot;&gt;&lt;/a&gt;5.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The Vorbis text comment header is the second (of three) header
<a name="l01129"></a>01129 packets that begin a Vorbis bitstream. It is meant <a class="code" href="interfacefor.html">for</a> <span class="keywordtype">short</span> text
<a name="l01130"></a>01130 comments, not arbitrary metadata; arbitrary metadata belongs in a
<a name="l01131"></a>01131 separate logical bitstream (usually an XML stream type) that provides
<a name="l01132"></a>01132 greater structure and machine parseability.&lt;/p&gt;&lt;p&gt;The comment field is meant to be used much like someone jotting a
<a name="l01133"></a>01133 quick note on the bottom of a CDR. It should be a little information to
<a name="l01134"></a>01134 remember the disc by and explain it to others; a <span class="keywordtype">short</span>, to-the-point
<a name="l01135"></a>01135 text note that need not only be a couple words, but isn&#39;t going to be
<a name="l01136"></a>01136 more than a <span class="keywordtype">short</span> paragraph.  The essentials, in other words, whatever
<a name="l01137"></a>01137 they turn out to be, eg:
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 &lt;/p&gt;&lt;div class=&quot;blockquote&quot;&gt;&lt;blockquote class=&quot;blockquote&quot;&gt;&lt;p&gt;Honest Bob and the Factory-to-Dealer-Incentives, &lt;em class=&quot;citetitle&quot;&gt;I&#39;m Still
<a name="l01140"></a>01140 Around&lt;/em&gt;, opening <a class="code" href="interfacefor.html">for</a> Moxy Früvous, 1997.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01141"></a>01141 &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2541925&quot;&gt;&lt;/a&gt;5.2. Comment encoding&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2541929&quot;&gt;&lt;/a&gt;5.2.1. Structure&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01142"></a>01142 The comment header is logically a list of eight-bit-clean vectors; the
<a name="l01143"></a>01143 number of vectors is bounded to 2^32-1 and the length of each vector
<a name="l01144"></a>01144 is limited to 2^32-1 bytes. The vector length is encoded; the vector
<a name="l01145"></a>01145 contents themselves are not null terminated. In addition to the vector
<a name="l01146"></a>01146 list, there is a single vector <a class="code" href="interfacefor.html">for</a> vendor name (also 8 bit clean,
<a name="l01147"></a>01147 length encoded in 32 bits). For example, the 1.0 release of libvorbis 
<a name="l01148"></a>01148 set the vendor <span class="keywordtype">string</span> to &quot;Xiph.Org libVorbis I 20020717&quot;.&lt;/p&gt;&lt;p&gt;The comment header is decoded as follows:
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 &lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;
<a name="l01151"></a>01151   1) [vendor_length] = read an <span class="keywordtype">unsigned</span> integer of 32 bits
<a name="l01152"></a>01152   2) [vendor_string] = read a UTF-8 vector as [vendor_length] octets
<a name="l01153"></a>01153   3) [user_comment_list_length] = read an <span class="keywordtype">unsigned</span> integer of 32 bits
<a name="l01154"></a>01154   4) iterate [user_comment_list_length] times {
<a name="l01155"></a>01155        5) [length] = read an <span class="keywordtype">unsigned</span> integer of 32 bits
<a name="l01156"></a>01156        6) <span class="keyword">this</span> iteration<span class="stringliteral">&#39;s user comment = read a UTF-8 vector as [length] octets</span>
<a name="l01157"></a>01157 <span class="stringliteral">     }</span>
<a name="l01158"></a>01158 <span class="stringliteral">  7) [framing_bit] = read a single bit as boolean</span>
<a name="l01159"></a>01159 <span class="stringliteral">  8) if ( [framing_bit] unset or end-of-packet ) then ERROR</span>
<a name="l01160"></a>01160 <span class="stringliteral">  9) done.</span>
<a name="l01161"></a>01161 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01162"></a>01162 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2498376&quot;&gt;&lt;/a&gt;5.2.2. Content vector format&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01163"></a>01163 <span class="stringliteral">The comment vectors are structured similarly to a UNIX environment variable.</span>
<a name="l01164"></a>01164 <span class="stringliteral">That is, comment fields consist of a field name and a corresponding value and</span>
<a name="l01165"></a>01165 <span class="stringliteral">look like:&lt;/p&gt;&lt;div class=&quot;blockquote&quot;&gt;&lt;blockquote class=&quot;blockquote&quot;&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01166"></a>01166 <span class="stringliteral">comment[0]=&quot;ARTIST=me&quot;; </span>
<a name="l01167"></a>01167 <span class="stringliteral">comment[1]=&quot;TITLE=the sound of Vorbis&quot;; </span>
<a name="l01168"></a>01168 <span class="stringliteral">&lt;/pre&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01169"></a>01169 <span class="stringliteral">The field name is case-insensitive and may consist of ASCII 0x20</span>
<a name="l01170"></a>01170 <span class="stringliteral">through 0x7D, 0x3D (&#39;</span>=<span class="stringliteral">&#39;) excluded. ASCII 0x41 through 0x5A inclusive</span>
<a name="l01171"></a>01171 <span class="stringliteral">(characters A-Z) is to be considered equivalent to ASCII 0x61 through </span>
<a name="l01172"></a>01172 <span class="stringliteral">0x7A inclusive (characters a-z).</span>
<a name="l01173"></a>01173 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l01174"></a>01174 <span class="stringliteral">The field name is immediately followed by ASCII 0x3D (&#39;</span>=<span class="stringliteral">&#39;);</span>
<a name="l01175"></a>01175 <span class="stringliteral">this equals sign is used to terminate the field name.</span>
<a name="l01176"></a>01176 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l01177"></a>01177 <span class="stringliteral">0x3D is followed by 8 bit clean UTF-8 encoded value of the</span>
<a name="l01178"></a>01178 <span class="stringliteral">field contents to the end of the field.</span>
<a name="l01179"></a>01179 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2529464&quot;&gt;&lt;/a&gt;5.2.2.1. Field names&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Below is a proposed, minimal list of standard field names with a</span>
<a name="l01180"></a>01180 <span class="stringliteral">description of intended use.  No single or group of field names is</span>
<a name="l01181"></a>01181 <span class="stringliteral">mandatory; a comment header may contain one, all or none of the names</span>
<a name="l01182"></a>01182 <span class="stringliteral">in this list.&lt;/p&gt;&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;TITLE&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Track/Work name&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;VERSION&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;The version field may be used to</span>
<a name="l01183"></a>01183 <span class="stringliteral">differentiate multiple</span>
<a name="l01184"></a>01184 <span class="stringliteral">versions of the same track title in a single collection. (e.g. remix</span>
<a name="l01185"></a>01185 <span class="stringliteral">info)</span>
<a name="l01186"></a>01186 <span class="stringliteral">&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;ALBUM&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;The collection name to which this track belongs</span>
<a name="l01187"></a>01187 <span class="stringliteral">&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;TRACKNUMBER&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;The track number of this piece if part of a specific larger collection or album</span>
<a name="l01188"></a>01188 <span class="stringliteral">&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;ARTIST&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;The artist generally considered responsible for the work. In popular music this is usually the performing band or singer. For classical music it would be the composer. For an audio book it would be the author of the original text.</span>
<a name="l01189"></a>01189 <span class="stringliteral">&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;PERFORMER&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;The artist(s) who performed the work. In classical music this would be the conductor, orchestra, soloists. In an audio book it would be the actor who did the reading. In popular music this is typically the same as the ARTIST and is omitted.</span>
<a name="l01190"></a>01190 <span class="stringliteral">&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;COPYRIGHT&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Copyright attribution, e.g., &#39;</span>2001 Nobody<span class="stringliteral">&#39;s Band&#39;</span> or <span class="stringliteral">&#39;1999 Jack Moffitt&#39;</span>
<a name="l01191"></a>01191 &lt;/dd&gt;&lt;dt&gt;&lt;span <span class="keyword">class</span>=<span class="stringliteral">&quot;term&quot;</span>&gt;LICENSE&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;License information, eg, <span class="stringliteral">&#39;All Rights Reserved&#39;</span>, <span class="stringliteral">&#39;Any</span>
<a name="l01192"></a>01192 <span class="stringliteral">Use Permitted&#39;</span>, a URL to a license such as a Creative Commons license
<a name="l01193"></a>01193 (<span class="stringliteral">&quot;www.creativecommons.org/blahblah/license.html&quot;</span>) or the EFF Open
<a name="l01194"></a>01194 Audio License (&#39;distributed under the terms of the Open Audio
<a name="l01195"></a>01195 License. see http:<span class="comment">//www.eff.org/IP/Open_licenses/eff_oal.html for</span>
<a name="l01196"></a>01196 details&#39;), etc.
<a name="l01197"></a>01197 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;ORGANIZATION&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Name of the organization producing the track (i.e.
<a name="l01198"></a>01198 the &#39;record label&#39;)
<a name="l01199"></a>01199 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;DESCRIPTION&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;A <span class="keywordtype">short</span> text description of the contents
<a name="l01200"></a>01200 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;GENRE&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;A <span class="keywordtype">short</span> text indication of music genre
<a name="l01201"></a>01201 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;DATE&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Date the track was recorded
<a name="l01202"></a>01202 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;LOCATION&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Location where track was recorded
<a name="l01203"></a>01203 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;CONTACT&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;Contact information <a class="code" href="interfacefor.html">for</a> the creators or distributors of the track. This could be a URL, an email address, the physical address of the producing label.
<a name="l01204"></a>01204 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;ISRC&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;International Standard Recording Code <a class="code" href="interfacefor.html">for</a> the
<a name="l01205"></a>01205 track; see &lt;a href=&quot;http:<span class="comment">//www.ifpi.org/site-content/online/isrc_intro.html&quot; target=&quot;_top&quot;&gt;the ISRC</span>
<a name="l01206"></a>01206 intro page&lt;/a&gt; <a class="code" href="interfacefor.html">for</a> more information on ISRC numbers.
<a name="l01207"></a>01207 &lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h5 class=&quot;title&quot;&gt;&lt;a name=&quot;id2527296&quot;&gt;&lt;/a&gt;5.2.2.2. Implications&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Field names should not be &#39;internationalized&#39;; this is a
<a name="l01208"></a>01208 concession to simplicity not an attempt to exclude the majority of
<a name="l01209"></a>01209 the world that doesn&#39;t speak English. Field &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;contents&lt;/em&gt;&lt;/span&gt;
<a name="l01210"></a>01210 however, use the UTF-8 character encoding to allow easy representation of any
<a name="l01211"></a>01211 language.&lt;/p&gt;&lt;p&gt;We have the length of the entirety of the field and restrictions on
<a name="l01212"></a>01212 the field name so that the field name is bounded in a known way. Thus
<a name="l01213"></a>01213 we also have the length of the field contents.&lt;/p&gt;&lt;p&gt;Individual &#39;vendors&#39; may use non-standard field names within
<a name="l01214"></a>01214 reason. The proper use of comment fields should be clear through
<a name="l01215"></a>01215 context at this point.  Abuse will be discouraged.&lt;/p&gt;&lt;p&gt;There is no vendor-specific prefix to &#39;nonstandard&#39; field names.
<a name="l01216"></a>01216 Vendors should make some effort to avoid arbitrarily polluting the
<a name="l01217"></a>01217 common namespace. We will generally collect the more useful tags
<a name="l01218"></a>01218 here to help with standardization.&lt;/p&gt;&lt;p&gt;Field names are not required to be unique (occur once) within a
<a name="l01219"></a>01219 comment header.  As an example, assume a track was recorded by three
<a name="l01220"></a>01220 well know artists; the following is permissible, and encouraged:
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 &lt;/p&gt;&lt;div class=&quot;blockquote&quot;&gt;&lt;blockquote class=&quot;blockquote&quot;&gt;&lt;pre class=&quot;programlisting&quot;&gt;
<a name="l01223"></a>01223 ARTIST=Dizzy Gillespie 
<a name="l01224"></a>01224 ARTIST=Sonny Rollins 
<a name="l01225"></a>01225 ARTIST=Sonny Stitt 
<a name="l01226"></a>01226 &lt;/pre&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2525558&quot;&gt;&lt;/a&gt;5.2.3. Encoding&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01229"></a>01229 The comment header comprises the entirety of the second bitstream
<a name="l01230"></a>01230 header packet.  Unlike the first bitstream header packet, it is not
<a name="l01231"></a>01231 generally the only packet on the second page and may not be restricted
<a name="l01232"></a>01232 to within the second bitstream page.  The length of the comment header
<a name="l01233"></a>01233 packet is (practically) unbounded.  The comment header packet is not
<a name="l01234"></a>01234 optional; it must be present in the bitstream even if it is
<a name="l01235"></a>01235 effectively empty.&lt;/p&gt;&lt;p&gt;
<a name="l01236"></a>01236 The comment header is encoded as follows (as per Ogg&#39;s standard
<a name="l01237"></a>01237 bitstream mapping which renders least-significant-bit of the word to be
<a name="l01238"></a>01238 coded into the least significant available bit of the current
<a name="l01239"></a>01239 bitstream octet first):
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 &lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;
<a name="l01242"></a>01242   Vendor <span class="keywordtype">string</span> length (32 bit <span class="keywordtype">unsigned</span> quantity specifying number of octets)
<a name="l01243"></a>01243  &lt;/li&gt;&lt;li&gt;
<a name="l01244"></a>01244   Vendor <span class="keywordtype">string</span> ([vendor <span class="keywordtype">string</span> length] octets coded from beginning of <span class="keywordtype">string</span> to end of <span class="keywordtype">string</span>, not null terminated)
<a name="l01245"></a>01245  &lt;/li&gt;&lt;li&gt;
<a name="l01246"></a>01246   Number of comment fields (32 bit <span class="keywordtype">unsigned</span> quantity specifying number of fields)
<a name="l01247"></a>01247  &lt;/li&gt;&lt;li&gt;
<a name="l01248"></a>01248   Comment field 0 length (if [Number of comment fields]&amp;gt;0; 32 bit <span class="keywordtype">unsigned</span> quantity specifying number of octets)
<a name="l01249"></a>01249  &lt;/li&gt;&lt;li&gt;
<a name="l01250"></a>01250   Comment field 0 ([Comment field 0 length] octets coded from beginning of <span class="keywordtype">string</span> to end of <span class="keywordtype">string</span>, not null terminated)
<a name="l01251"></a>01251  &lt;/li&gt;&lt;li&gt;
<a name="l01252"></a>01252   Comment field 1 length (if [Number of comment fields]&amp;gt;1...)...
<a name="l01253"></a>01253  &lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01254"></a>01254 &lt;/p&gt;&lt;p&gt;
<a name="l01255"></a>01255 This is actually somewhat easier to describe in code; implementation of the above can be found in &lt;code class=&quot;filename&quot;&gt;vorbis/lib/info.c&lt;/code&gt;, &lt;code class=&quot;function&quot;&gt;_vorbis_pack_comment()&lt;/code&gt; and &lt;code class=&quot;function&quot;&gt;_vorbis_unpack_comment()&lt;/code&gt;.
<a name="l01256"></a>01256 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-floor0&quot;&gt;&lt;/a&gt;6. Floor type 0 setup and decode&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;
<a name="l01257"></a>01257   $Id: 06-floor0.xml 10424 2005-11-23 08:44:18Z xiphmont $
<a name="l01258"></a>01258 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2512128&quot;&gt;&lt;/a&gt;6.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01259"></a>01259 Vorbis floor type zero uses Line Spectral Pair (LSP, also alternately
<a name="l01260"></a>01260 known as Line Spectral Frequency or LSF) representation to encode a
<a name="l01261"></a>01261 smooth spectral envelope curve as the frequency response of the LSP
<a name="l01262"></a>01262 filter.  This representation is equivalent to a traditional all-pole
<a name="l01263"></a>01263 infinite impulse response filter as would be used in linear predictive
<a name="l01264"></a>01264 coding; LSP representation may be converted to LPC representation and
<a name="l01265"></a>01265 vice-versa.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2505686&quot;&gt;&lt;/a&gt;6.2. Floor 0 format&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01266"></a>01266 Floor zero configuration consists of six integer fields and a list of
<a name="l01267"></a>01267 VQ codebooks <a class="code" href="interfacefor.html">for</a> use in coding/decoding the LSP filter coefficient
<a name="l01268"></a>01268 values used by each frame. &lt;/p&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2515774&quot;&gt;&lt;/a&gt;6.2.1. header decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01269"></a>01269 Configuration information <a class="code" href="interfacefor.html">for</a> instances of floor zero decodes from the
<a name="l01270"></a>01270 codec setup header (third packet).  configuration decode proceeds as
<a name="l01271"></a>01271 follows:&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;
<a name="l01272"></a>01272   1) [floor0_order] = read an <span class="keywordtype">unsigned</span> integer of 8 bits
<a name="l01273"></a>01273   2) [floor0_rate] = read an <span class="keywordtype">unsigned</span> integer of 16 bits
<a name="l01274"></a>01274   3) [floor0_bark_map_size] = read an <span class="keywordtype">unsigned</span> integer of 16 bits
<a name="l01275"></a>01275   4) [floor0_amplitude_bits] = read an <span class="keywordtype">unsigned</span> integer of six bits
<a name="l01276"></a>01276   5) [floor0_amplitude_offset] = read an <span class="keywordtype">unsigned</span> integer of eight bits
<a name="l01277"></a>01277   6) [floor0_number_of_books] = read an <span class="keywordtype">unsigned</span> integer of four bits and add 1
<a name="l01278"></a>01278   7) if any of [floor0_order], [floor0_rate], [floor0_bark_map_size], [floor0_amplitude_bits],
<a name="l01279"></a>01279      [floor0_amplitude_offset] or [floor0_number_of_books] are less than zero, the stream is not decodable
<a name="l01280"></a>01280   8) array [floor0_book_list] = read a list of [floor0_number_of_books] <span class="keywordtype">unsigned</span> integers of eight bits each;
<a name="l01281"></a>01281 &lt;/pre&gt;&lt;p&gt;
<a name="l01282"></a>01282 An end-of-packet condition during any of these bitstream reads renders
<a name="l01283"></a>01283 this stream undecodable.  In addition, any element of the array
<a name="l01284"></a>01284 &lt;code class=&quot;varname&quot;&gt;[floor0_book_list]&lt;/code&gt; that is greater than the maximum <a class="code" href="structcodebook.html">codebook</a>
<a name="l01285"></a>01285 number <a class="code" href="interfacefor.html">for</a> this bitstream is an error condition that also renders the
<a name="l01286"></a>01286 stream undecodable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;vorbis-spec-floor0-decode&quot;&gt;&lt;/a&gt;6.2.2. packet decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01287"></a>01287 Extracting a floor0 curve from an audio packet consists of first
<a name="l01288"></a>01288 decoding the curve amplitude and &lt;code class=&quot;varname&quot;&gt;[floor0_order]&lt;/code&gt; LSP
<a name="l01289"></a>01289 coefficient values from the bitstream, and then computing the floor
<a name="l01290"></a>01290 curve, which is defined as the frequency response of the decoded LSP
<a name="l01291"></a>01291 filter.&lt;/p&gt;&lt;p&gt;
<a name="l01292"></a>01292 Packet decode proceeds as follows:&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;
<a name="l01293"></a>01293   1) [amplitude] = read an <span class="keywordtype">unsigned</span> integer of [floor0_amplitude_bits] bits
<a name="l01294"></a>01294   2) if ( [amplitude] is greater than zero ) {
<a name="l01295"></a>01295        3) [coefficients] is an empty, zero length vector
<a name="l01296"></a>01296        4) [booknumber] = read an <span class="keywordtype">unsigned</span> integer of &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-ilog&quot;</span> title=<span class="stringliteral">&quot;9.2.1. ilog&quot;</span>&gt;ilog&lt;/a&gt;( [floor0_number_of_books] ) bits
<a name="l01297"></a>01297        5) if ( [booknumber] is greater than the highest number decode <a class="code" href="structcodebook.html">codebook</a> ) then packet is undecodable
<a name="l01298"></a>01298        6) [last] = zero;
<a name="l01299"></a>01299        7) vector [temp_vector] = read vector from bitstream using <a class="code" href="structcodebook.html">codebook</a> number [floor0_book_list] element [booknumber] in VQ context.
<a name="l01300"></a>01300        8) add the scalar value [last] to each scalar in vector [temp_vector]
<a name="l01301"></a>01301        9) [last] = the value of the last scalar in vector [temp_vector]
<a name="l01302"></a>01302       10) concatenate [temp_vector] onto the end of the [coefficients] vector
<a name="l01303"></a>01303       11) if (length of vector [coefficients] is less than [floor0_order], continue at step 6
<a name="l01304"></a>01304 
<a name="l01305"></a>01305      }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307  12) done.
<a name="l01308"></a>01308  
<a name="l01309"></a>01309 &lt;/pre&gt;&lt;p&gt;
<a name="l01310"></a>01310 Take note of the following properties of decode:
<a name="l01311"></a>01311 &lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;An &lt;code class=&quot;varname&quot;&gt;[amplitude]&lt;/code&gt; value of zero must result in a return code that indicates this channel is unused in this frame (the output of the channel will be all-zeroes in synthesis).  Several later stages of decode don&#39;t occur <a class="code" href="interfacefor.html">for</a> an unused channel.&lt;/li&gt;&lt;li&gt;An end-of-packet condition during decode should be considered a
<a name="l01312"></a>01312 nominal occruence; if end-of-packet is reached during any read
<a name="l01313"></a>01313 operation above, floor decode is to return &#39;unused&#39; status as if the
<a name="l01314"></a>01314 &lt;code class=&quot;varname&quot;&gt;[amplitude]&lt;/code&gt; value had read zero at the beginning of decode.&lt;/li&gt;&lt;li&gt;The book number used <a class="code" href="interfacefor.html">for</a> decode
<a name="l01315"></a>01315 can, in fact, be stored in the bitstream in &lt;a href=&quot;<span class="preprocessor">#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;( &lt;code class=&quot;varname&quot;&gt;[floor0_number_of_books]&lt;/code&gt; -</span>
<a name="l01316"></a>01316 <span class="preprocessor"></span>1 ) bits.  Nevertheless, the above specification is correct and values
<a name="l01317"></a>01317 greater than the maximum possible book value are reserved.&lt;/li&gt;&lt;li&gt;The number of scalars read into the vector &lt;code class=&quot;varname&quot;&gt;[coefficients]&lt;/code&gt;
<a name="l01318"></a>01318 may be greater than &lt;code class=&quot;varname&quot;&gt;[floor0_order]&lt;/code&gt;, the number actually
<a name="l01319"></a>01319 required <span class="keywordflow">for</span> curve computation.  For example, <span class="keywordflow">if</span> the VQ <a class="code" href="structcodebook.html">codebook</a> used
<a name="l01320"></a>01320 <span class="keywordflow">for</span> the floor currently being decoded has a
<a name="l01321"></a>01321 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[codebook_dimensions]&lt;/code&gt; value of three and
<a name="l01322"></a>01322 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor0_order]&lt;/code&gt; is ten, the only way to fill all the needed
<a name="l01323"></a>01323 scalars in &lt;code class=&quot;varname&quot;&gt;[coefficients]&lt;/code&gt; is to to read a total of twelve
<a name="l01324"></a>01324 scalars as four vectors of three scalars each.  This is not an error
<a name="l01325"></a>01325 condition, and care must be taken not to allow a buffer overflow in
<a name="l01326"></a>01326 decode. The extra values are not used and may be ignored or discarded.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01327"></a>01327 &lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-floor0-synth&quot;</span>&gt;&lt;/a&gt;6.2.3. curve computation&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01328"></a>01328 Given an &lt;code class=&quot;varname&quot;&gt;[amplitude]&lt;/code&gt; integer and &lt;code class=&quot;varname&quot;&gt;[coefficients]&lt;/code&gt;
<a name="l01329"></a>01329 vector from packet decode as well as the [floor0_order],
<a name="l01330"></a>01330 [floor0_rate], [floor0_bark_map_size], [floor0_amplitude_bits] and
<a name="l01331"></a>01331 [floor0_amplitude_offset] values from floor setup, and an output
<a name="l01332"></a>01332 vector size &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; specified by the decode process, we compute a
<a name="l01333"></a>01333 floor output vector.&lt;/p&gt;&lt;p&gt;
<a name="l01334"></a>01334 If the value &lt;code class=&quot;varname&quot;&gt;[amplitude]&lt;/code&gt; is zero, the <span class="keywordflow">return</span> value is a
<a name="l01335"></a>01335 length &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; vector with all-zero scalars.  Otherwise, begin by
<a name="l01336"></a>01336 assuming the following definitions <span class="keywordflow">for</span> the given vector to be
<a name="l01337"></a>01337 synthesized:&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;informalequation&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;mediaobject&quot;</span>&gt;&lt;img src=<span class="stringliteral">&quot;lspmap.png&quot;</span> alt=<span class="stringliteral">&quot;[lsp map equation]&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01338"></a>01338 The above is used to synthesize the LSP curve on a Bark-scale frequency
<a name="l01339"></a>01339 axis, then map the result to a linear-scale frequency axis.
<a name="l01340"></a>01340 Similarly, the below calculation synthesizes the output LSP curve &lt;code class=&quot;varname&quot;&gt;[output]&lt;/code&gt; on a log
<a name="l01341"></a>01341 (dB) amplitude scale, mapping it to linear amplitude in the last step:&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;1&quot;</span>&gt;&lt;li&gt; &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; = 0 &lt;/li&gt;&lt;li&gt;&lt;p&gt;<span class="keywordflow">if</span> ( &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor0_order]&lt;/code&gt; is odd ) {
<a name="l01342"></a>01342   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;p&gt;calculate &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[p]&lt;/code&gt; and &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[q]&lt;/code&gt; according to:
<a name="l01343"></a>01343         &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;informalequation&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;mediaobject&quot;</span>&gt;&lt;img src=<span class="stringliteral">&quot;oddlsp.png&quot;</span> alt=<span class="stringliteral">&quot;[equation for odd lsp]&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01344"></a>01344    &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01345"></a>01345   } <span class="keywordflow">else</span> &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor0_order]&lt;/code&gt; is even {
<a name="l01346"></a>01346   &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;orderedlist&quot;</span>&gt;&lt;ol type=<span class="stringliteral">&quot;a&quot;</span>&gt;&lt;li&gt;&lt;p&gt;calculate &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[p]&lt;/code&gt; and &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[q]&lt;/code&gt; according to:
<a name="l01347"></a>01347         &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;informalequation&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;mediaobject&quot;</span>&gt;&lt;img src=<span class="stringliteral">&quot;evenlsp.png&quot;</span> alt=<span class="stringliteral">&quot;[equation for even lsp]&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01348"></a>01348    &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;p&gt; 
<a name="l01349"></a>01349   }
<a name="l01350"></a>01350  &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;calculate &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[linear_floor_value]&lt;/code&gt; according to:
<a name="l01351"></a>01351      &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;informalequation&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;mediaobject&quot;</span>&gt;&lt;img src=<span class="stringliteral">&quot;floorval.png&quot;</span> alt=<span class="stringliteral">&quot;[expression for floorval]&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01352"></a>01352  &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[iteration_condition]&lt;/code&gt; = map element &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[output]&lt;/code&gt; element &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; = &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[linear_floor_value]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;increment &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> ( map element &lt;code class=&quot;varname&quot;&gt;[i]&lt;/code&gt; is equal to &lt;code class=&quot;varname&quot;&gt;[iteration_condition]&lt;/code&gt; ) <span class="keywordflow">continue</span> at step 5&lt;/li&gt;&lt;li&gt;<span class="keywordflow">if</span> ( &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[i]&lt;/code&gt; is less than &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; ) <span class="keywordflow">continue</span> at step 2&lt;/li&gt;&lt;li&gt;done&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h2 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span> style=<span class="stringliteral">&quot;clear: both&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-floor1&quot;</span>&gt;&lt;/a&gt;7. Floor type 1 setup and decode&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p <span class="keyword">class</span>=<span class="stringliteral">&quot;releaseinfo&quot;</span>&gt;
<a name="l01353"></a>01353  $Id: 07-floor1.xml 10466 2005-11-28 00:34:44Z giles $
<a name="l01354"></a>01354 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2541060&quot;</span>&gt;&lt;/a&gt;7.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01355"></a>01355 Vorbis floor type one uses a piecewise straight-line representation to
<a name="l01356"></a>01356 encode a spectral envelope curve. The representation plots <span class="keyword">this</span> curve
<a name="l01357"></a>01357 mechanically on a linear frequency axis and a logarithmic (dB)
<a name="l01358"></a>01358 amplitude axis. The integer plotting algorithm used is similar to
<a name="l01359"></a>01359 Bresenham&#39;s algorithm.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2540135&quot;&gt;&lt;/a&gt;7.2. Floor 1 format&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2451267&quot;&gt;&lt;/a&gt;7.2.1. model&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01360"></a>01360 Floor type one represents a spectral curve as a series of
<a name="l01361"></a>01361 line segments.  Synthesis constructs a floor curve using iterative
<a name="l01362"></a>01362 prediction in a process roughly equivalent to the following simplified
<a name="l01363"></a>01363 description:&lt;/p&gt;&lt;p&gt;
<a name="l01364"></a>01364 &lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt; the first line segment (base case) is a logical line spanning
<a name="l01365"></a>01365 from x_0,y_0 to x_1,y_1 where in the base case x_0=0 and x_1=[n], the
<a name="l01366"></a>01366 full range of the spectral floor to be computed.&lt;/li&gt;&lt;li&gt;the induction step chooses a point x_new within an existing
<a name="l01367"></a>01367 logical line segment and produces a y_new value at that point computed
<a name="l01368"></a>01368 from the existing line&#39;s y value at x_new (as plotted by the line) and
<a name="l01369"></a>01369 a difference value decoded from the bitstream packet.&lt;/li&gt;&lt;li&gt;floor computation produces two new line segments, one running from
<a name="l01370"></a>01370 x_0,y_0 to x_new,y_new and from x_new,y_new to x_1,y_1. This step is
<a name="l01371"></a>01371 performed logically even if y_new represents no change to the
<a name="l01372"></a>01372 amplitude value at x_new so that later refinement is additionally
<a name="l01373"></a>01373 bounded at x_new.&lt;/li&gt;&lt;li&gt;the induction step repeats, using a list of x values specified in
<a name="l01374"></a>01374 the codec setup header at floor 1 initialization time.  Computation
<a name="l01375"></a>01375 is completed at the end of the x value list.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01376"></a>01376 &lt;/p&gt;&lt;p&gt;
<a name="l01377"></a>01377 Consider the following example, with values chosen <a class="code" href="interfacefor.html">for</a> ease of
<a name="l01378"></a>01378 understanding rather than representing typical configuration:&lt;/p&gt;&lt;p&gt;
<a name="l01379"></a>01379 For the below example, we assume a floor setup with an [n] of 128.
<a name="l01380"></a>01380 The list of selected X values in increasing order is
<a name="l01381"></a>01381 0,16,32,48,64,80,96,112 and 128.  In list order, the values interleave
<a name="l01382"></a>01382 as 0, 128, 64, 32, 96, 16, 48, 80 and 112.  The corresponding
<a name="l01383"></a>01383 list-order Y values as decoded from an example packet are 110, 20, -5,
<a name="l01384"></a>01384 -45, 0, -25, -10, 30 and -10.  We compute the floor in the following
<a name="l01385"></a>01385 way, beginning with the first line:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;floor1-1.png&quot; alt=&quot;[graph of example floor]&quot;&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01386"></a>01386 We now draw new logical lines to reflect the correction to new_Y, and
<a name="l01387"></a>01387 iterate <a class="code" href="interfacefor.html">for</a> X positions 32 and 96:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;floor1-2.png&quot; alt=&quot;[graph of example floor]&quot;&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01388"></a>01388 Although the new Y value at X position 96 is unchanged, it is still
<a name="l01389"></a>01389 used later as an endpoint <a class="code" href="interfacefor.html">for</a> further refinement.  From here on, the
<a name="l01390"></a>01390 pattern should be clear; we complete the floor computation as follows:&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;floor1-3.png&quot; alt=&quot;[graph of example floor]&quot;&gt;&lt;/div&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;floor1-4.png&quot; alt=&quot;[graph of example floor]&quot;&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01391"></a>01391 A more efficient algorithm with carefully defined integer rounding
<a name="l01392"></a>01392 behavior is used <a class="code" href="interfacefor.html">for</a> actual decode, as described later.  The actual
<a name="l01393"></a>01393 algorithm splits Y value computation and line plotting into two steps
<a name="l01394"></a>01394 with modifications to the above algorithm to eliminate noise
<a name="l01395"></a>01395 accumulation through integer roundoff/truncation. &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2516615&quot;&gt;&lt;/a&gt;7.2.2. header decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01396"></a>01396 A list of floor X values is stored in the packet header in interleaved
<a name="l01397"></a>01397 format (used in list order during packet decode and synthesis).  This
<a name="l01398"></a>01398 list is split into partitions, and each partition is assigned to a
<a name="l01399"></a>01399 partition class.  X positions 0 and [n] are implicit and do not belong
<a name="l01400"></a>01400 to an explicit partition or partition class.&lt;/p&gt;&lt;p&gt;
<a name="l01401"></a>01401 A partition class consists of a representation vector width (the
<a name="l01402"></a>01402 number of Y values which the partition class encodes at once), a
<a name="l01403"></a>01403 &#39;subclass&#39; value representing the number of alternate entropy books
<a name="l01404"></a>01404 the partition class may use in representing Y values, the list of
<a name="l01405"></a>01405 [subclass] books and a master book used to encode which alternate
<a name="l01406"></a>01406 books were chosen <a class="code" href="interfacefor.html">for</a> representation in a given packet.  The
<a name="l01407"></a>01407 master/subclass mechanism is meant to be used as a flexible
<a name="l01408"></a>01408 representation cascade while still using codebooks only in a scalar
<a name="l01409"></a>01409 context.&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   1) [floor1_partitions] = read 5 bits as <span class="keywordtype">unsigned</span> integer
<a name="l01412"></a>01412   2) [maximum_class] = -1
<a name="l01413"></a>01413   3) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l01414"></a>01414        
<a name="l01415"></a>01415         4) vector [floor1_partition_class_list] element [i] = read 4 bits as <span class="keywordtype">unsigned</span> integer
<a name="l01416"></a>01416 
<a name="l01417"></a>01417      }
<a name="l01418"></a>01418 
<a name="l01419"></a>01419   5) [maximum_class] = largest integer scalar value in vector [floor1_partition_class_list]
<a name="l01420"></a>01420   6) iterate [i] over the range 0 ... [maximum_class] {
<a name="l01421"></a>01421 
<a name="l01422"></a>01422         7) vector [floor1_class_dimensions] element [i] = read 3 bits as <span class="keywordtype">unsigned</span> integer and add 1
<a name="l01423"></a>01423         8) vector [floor1_class_subclasses] element [i] = read 2 bits as <span class="keywordtype">unsigned</span> integer
<a name="l01424"></a>01424         9) <span class="keywordflow">if</span> ( vector [floor1_class_subclasses] element [i] is nonzero ) {
<a name="l01425"></a>01425             
<a name="l01426"></a>01426              10) vector [floor1_class_masterbooks] element [i] = read 8 bits as <span class="keywordtype">unsigned</span> integer
<a name="l01427"></a>01427            
<a name="l01428"></a>01428            }
<a name="l01429"></a>01429 
<a name="l01430"></a>01430        11) iterate [j] over the range 0 ... (2 exponent [floor1_class_subclasses] element [i]) - 1  {
<a name="l01431"></a>01431 
<a name="l01432"></a>01432              12) array [floor1_subclass_books] element [i],[j] = 
<a name="l01433"></a>01433                  read 8 bits as <span class="keywordtype">unsigned</span> integer and subtract one
<a name="l01434"></a>01434            }
<a name="l01435"></a>01435       }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437  13) [floor1_multiplier] = read 2 bits as <span class="keywordtype">unsigned</span> integer and add one
<a name="l01438"></a>01438  14) [rangebits] = read 4 bits as <span class="keywordtype">unsigned</span> integer
<a name="l01439"></a>01439  15) vector [floor1_X_list] element [0] = 0
<a name="l01440"></a>01440  16) vector [floor1_X_list] element [1] = 2 exponent [rangebits];
<a name="l01441"></a>01441  17) [floor1_values] = 2
<a name="l01442"></a>01442  18) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l01443"></a>01443 
<a name="l01444"></a>01444        19) [current_class_number] = vector [floor1_partition_class_list] element [i]
<a name="l01445"></a>01445        20) iterate [j] over the range 0 ... ([floor1_class_dimensions] element [current_class_number])-1 {
<a name="l01446"></a>01446              21) vector [floor1_X_list] element ([floor1_values]) = 
<a name="l01447"></a>01447                  read [rangebits] bits as <span class="keywordtype">unsigned</span> integer
<a name="l01448"></a>01448              22) increment [floor1_values] by one
<a name="l01449"></a>01449            }
<a name="l01450"></a>01450      }
<a name="l01451"></a>01451  
<a name="l01452"></a>01452  23) done
<a name="l01453"></a>01453 &lt;/pre&gt;&lt;p&gt;
<a name="l01454"></a>01454 An end-of-packet condition <span class="keywordflow">while</span> reading any aspect of a floor 1
<a name="l01455"></a>01455 configuration during setup renders a stream undecodable.  In
<a name="l01456"></a>01456 addition, a &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_class_masterbooks]&lt;/code&gt; or
<a name="l01457"></a>01457 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_subclass_books]&lt;/code&gt; scalar element greater than the
<a name="l01458"></a>01458 highest numbered <a class="code" href="structcodebook.html">codebook</a> configured in <span class="keyword">this</span> stream is an error
<a name="l01459"></a>01459 condition that renders the stream undecodable.&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h5 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-floor1-decode&quot;</span>&gt;&lt;/a&gt;7.2.2.1. packet decode&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01460"></a>01460 Packet decode begins by checking the &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[nonzero]&lt;/code&gt; flag:&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l01461"></a>01461   1) [nonzero] = read 1 bit as <span class="keywordtype">boolean</span>
<a name="l01462"></a>01462 &lt;/pre&gt;&lt;p&gt;
<a name="l01463"></a>01463 If &lt;code class=&quot;varname&quot;&gt;[nonzero]&lt;/code&gt; is unset, that indicates <span class="keyword">this</span> channel contained
<a name="l01464"></a>01464 no audio energy in <span class="keyword">this</span> frame.  Decode immediately returns a status
<a name="l01465"></a>01465 indicating <span class="keyword">this</span> floor curve (and thus <span class="keyword">this</span> channel) is unused <span class="keyword">this</span>
<a name="l01466"></a>01466 frame.  (A <span class="keywordflow">return</span> status of <span class="stringliteral">&#39;unused&#39;</span> is different from decoding a
<a name="l01467"></a>01467 floor that has all points <span class="keyword">set</span> to minimum representation amplitude,
<a name="l01468"></a>01468 which happens to be approximately -140dB).
<a name="l01469"></a>01469 &lt;/p&gt;&lt;p&gt;
<a name="l01470"></a>01470 Assuming &lt;code class=&quot;varname&quot;&gt;[nonzero]&lt;/code&gt; is <span class="keyword">set</span>, decode proceeds as follows:&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l01471"></a>01471   1) [range] = vector { 256, 128, 86, 64 } element ([floor1_multiplier]-1)
<a name="l01472"></a>01472   2) vector [floor1_Y] element [0] = read &lt;a href=&quot;#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;([range]-1) bits as <span class="keywordtype">unsigned</span> integer
<a name="l01473"></a>01473   3) vector [floor1_Y] element [1] = read &lt;a href=&quot;#vorbis-spec-ilog&quot; title=&quot;9.2.1. ilog&quot;&gt;ilog&lt;/a&gt;([range]-1) bits as <span class="keywordtype">unsigned</span> integer
<a name="l01474"></a>01474   4) [offset] = 2;
<a name="l01475"></a>01475   5) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l01476"></a>01476 
<a name="l01477"></a>01477        6) [<span class="keyword">class</span>] = vector [floor1_partition_class]  element [i]
<a name="l01478"></a>01478        7) [cdim]  = vector [floor1_class_dimensions] element [<span class="keyword">class</span>]
<a name="l01479"></a>01479        8) [cbits] = vector [floor1_class_subclasses] element [<span class="keyword">class</span>]
<a name="l01480"></a>01480        9) [csub]  = (2 exponent [cbits])-1
<a name="l01481"></a>01481       10) [cval]  = 0
<a name="l01482"></a>01482       11) <span class="keywordflow">if</span> ( [cbits] is greater than zero ) {
<a name="l01483"></a>01483  
<a name="l01484"></a>01484              12) [cval] = read from packet <span class="keyword">using</span> <a class="code" href="structcodebook.html">codebook</a> number
<a name="l01485"></a>01485                  (vector [floor1_class_masterbooks] element [<span class="keyword">class</span>]) in scalar context
<a name="l01486"></a>01486           }
<a name="l01487"></a>01487       
<a name="l01488"></a>01488       13) iterate [j] over the range 0 ... [cdim]-1 {
<a name="l01489"></a>01489        
<a name="l01490"></a>01490              14) [book] = array [floor1_subclass_books] element [<span class="keyword">class</span>],([cval] bitwise AND [csub])
<a name="l01491"></a>01491              15) [cval] = [cval] right shifted [cbits] bits
<a name="l01492"></a>01492              16) <span class="keywordflow">if</span> ( [book] is not less than zero ) {
<a name="l01493"></a>01493              
<a name="l01494"></a>01494                    17) vector [floor1_Y] element ([j]+[offset]) = read from packet <span class="keyword">using</span> <a class="code" href="structcodebook.html">codebook</a> 
<a name="l01495"></a>01495                        [book] in scalar context
<a name="l01496"></a>01496 
<a name="l01497"></a>01497                  } <span class="keywordflow">else</span> [book] is less than zero {
<a name="l01498"></a>01498 
<a name="l01499"></a>01499                    18) vector [floor1_Y] element ([j]+[offset]) = 0
<a name="l01500"></a>01500 
<a name="l01501"></a>01501                  }
<a name="l01502"></a>01502           }
<a name="l01503"></a>01503              
<a name="l01504"></a>01504       19) [offset] = [offset] + [cdim]
<a name="l01505"></a>01505          
<a name="l01506"></a>01506      }
<a name="l01507"></a>01507   
<a name="l01508"></a>01508  20) done
<a name="l01509"></a>01509 &lt;/pre&gt;&lt;p&gt;
<a name="l01510"></a>01510 An end-of-packet condition during curve decode should be considered a
<a name="l01511"></a>01511 nominal occurrence; <span class="keywordflow">if</span> end-of-packet is reached during any read
<a name="l01512"></a>01512 operation above, floor decode is to <span class="keywordflow">return</span> <span class="stringliteral">&#39;unused&#39;</span> status as <span class="keywordflow">if</span> the
<a name="l01513"></a>01513 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[nonzero]&lt;/code&gt; flag had been unset at the beginning of decode.
<a name="l01514"></a>01514 &lt;/p&gt;&lt;p&gt;
<a name="l01515"></a>01515 Vector &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_Y]&lt;/code&gt; contains the values from packet decode
<a name="l01516"></a>01516 needed <span class="keywordflow">for</span> floor 1 synthesis.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h5 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-floor1-synth&quot;</span>&gt;&lt;/a&gt;7.2.2.2. curve computation&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01517"></a>01517 Curve computation is split into two logical steps; the first step
<a name="l01518"></a>01518 derives <span class="keyword">final</span> Y amplitude values from the encoded, wrapped difference
<a name="l01519"></a>01519 values taken from the bitstream.  The second step plots the curve
<a name="l01520"></a>01520 lines.  Also, although zero-difference values are used in the
<a name="l01521"></a>01521 iterative prediction to find <span class="keyword">final</span> Y values, these points are
<a name="l01522"></a>01522 conditionally skipped during <span class="keyword">final</span> line computation in step two.
<a name="l01523"></a>01523 Skipping zero-difference values allows a smoother line fit.  &lt;/p&gt;&lt;p&gt;
<a name="l01524"></a>01524 Although some aspects of the below algorithm look like inconsequential
<a name="l01525"></a>01525 optimizations, implementors are warned to follow the details closely.
<a name="l01526"></a>01526 Deviation from implementing a strictly equivalent algorithm can result
<a name="l01527"></a>01527 in serious decoding errors.&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h6 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2521765&quot;</span>&gt;&lt;/a&gt;7.2.2.2.1. step 1: amplitude value synthesis&lt;/h6&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01528"></a>01528 Unwrap the always-positive-or-zero values read from the packet into
<a name="l01529"></a>01529 +/- difference values, then apply to line prediction.&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l01530"></a>01530   1) [range] = vector { 256, 128, 86, 64 } element ([floor1_multiplier]-1)
<a name="l01531"></a>01531   2) vector [floor1_step2_flag] element [0] = <span class="keyword">set</span>
<a name="l01532"></a>01532   3) vector [floor1_step2_flag] element [1] = <span class="keyword">set</span>
<a name="l01533"></a>01533   4) vector [floor1_final_Y] element [0] = vector [floor1_Y] element [0]
<a name="l01534"></a>01534   5) vector [floor1_final_Y] element [1] = vector [floor1_Y] element [1]
<a name="l01535"></a>01535   6) iterate [i] over the range 2 ... [floor1_values]-1 {
<a name="l01536"></a>01536     
<a name="l01537"></a>01537        7) [low_neighbor_offset] = &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-low_neighbor&quot;</span> title=<span class="stringliteral">&quot;9.2.4. low_neighbor&quot;</span>&gt;low_neighbor&lt;/a&gt;([floor1_X_list],[i])
<a name="l01538"></a>01538        8) [high_neighbor_offset] = &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-high_neighbor&quot;</span> title=<span class="stringliteral">&quot;9.2.4.1. high_neighbor&quot;</span>&gt;high_neighbor&lt;/a&gt;([floor1_X_list],[i])
<a name="l01539"></a>01539 
<a name="l01540"></a>01540        9) [predicted] = &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-render_point&quot;</span> title=<span class="stringliteral">&quot;9.2.4.2. render_point&quot;</span>&gt;render_point&lt;/a&gt;( vector [floor1_X_list] element [low_neighbor_offset],
<a name="l01541"></a>01541                                       vector [floor1_final_Y] element [low_neighbor_offset],
<a name="l01542"></a>01542                                       vector [floor1_X_list] element [high_neighbor_offset],
<a name="l01543"></a>01543                                       vector [floor1_final_Y] element [high_neighbor_offset],
<a name="l01544"></a>01544                                       vector [floor1_X_list] element [i] )
<a name="l01545"></a>01545 
<a name="l01546"></a>01546       10) [val] = vector [floor1_Y] element [i]
<a name="l01547"></a>01547       11) [highroom] = [range] - [predicted]
<a name="l01548"></a>01548       12) [lowroom]  = [predicted]
<a name="l01549"></a>01549       13) <span class="keywordflow">if</span> ( [highroom] is less than [lowroom] ) {
<a name="l01550"></a>01550 
<a name="l01551"></a>01551             14) [room] = [highroom] * 2
<a name="l01552"></a>01552          
<a name="l01553"></a>01553           } <span class="keywordflow">else</span> [highroom] is not less than [lowroom] {
<a name="l01554"></a>01554                       
<a name="l01555"></a>01555             15) [room] = [lowroom] * 2
<a name="l01556"></a>01556         
<a name="l01557"></a>01557           }
<a name="l01558"></a>01558 
<a name="l01559"></a>01559       16) <span class="keywordflow">if</span> ( [val] is nonzero ) {
<a name="l01560"></a>01560 
<a name="l01561"></a>01561             17) vector [floor1_step2_flag] element [low_neighbor_offset] = <span class="keyword">set</span>
<a name="l01562"></a>01562             18) vector [floor1_step2_flag] element [high_neighbor_offset] = <span class="keyword">set</span>
<a name="l01563"></a>01563             19) vector [floor1_step2_flag] element [i] = <span class="keyword">set</span>
<a name="l01564"></a>01564             20) <span class="keywordflow">if</span> ( [val] is greater than or equal to [room] ) {
<a name="l01565"></a>01565  
<a name="l01566"></a>01566                   21) <span class="keywordflow">if</span> ( [highroom] is greater than [lowroom] ) {
<a name="l01567"></a>01567 
<a name="l01568"></a>01568                         22) vector [floor1_final_Y] element [i] = [val] - [lowroom] + [predicted]
<a name="l01569"></a>01569                      
<a name="l01570"></a>01570                       } <span class="keywordflow">else</span> [highroom] is not greater than [lowroom] {
<a name="l01571"></a>01571               
<a name="l01572"></a>01572                         23) vector [floor1_final_Y] element [i] = [predicted] - [val] + [highroom] - 1
<a name="l01573"></a>01573                    
<a name="l01574"></a>01574                       }
<a name="l01575"></a>01575                
<a name="l01576"></a>01576                 } <span class="keywordflow">else</span> [val] is less than [room] {
<a name="l01577"></a>01577                  
<a name="l01578"></a>01578                   24) <span class="keywordflow">if</span> ([val] is odd) {
<a name="l01579"></a>01579                  
<a name="l01580"></a>01580                         25) vector [floor1_final_Y] element [i] = 
<a name="l01581"></a>01581                             [predicted] - (([val] + 1) divided by  2 <span class="keyword">using</span> integer division)
<a name="l01582"></a>01582 
<a name="l01583"></a>01583                       } <span class="keywordflow">else</span> [val] is even {
<a name="l01584"></a>01584 
<a name="l01585"></a>01585                         26) vector [floor1_final_Y] element [i] = 
<a name="l01586"></a>01586                             [predicted] + ([val] / 2 <span class="keyword">using</span> integer division)
<a name="l01587"></a>01587                           
<a name="l01588"></a>01588                       }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590                 }      
<a name="l01591"></a>01591 
<a name="l01592"></a>01592           } <span class="keywordflow">else</span> [val] is zero {
<a name="l01593"></a>01593 
<a name="l01594"></a>01594             27) vector [floor1_step2_flag] element [i] = unset
<a name="l01595"></a>01595             28) vector [floor1_final_Y] element [i] = [predicted]
<a name="l01596"></a>01596 
<a name="l01597"></a>01597           }
<a name="l01598"></a>01598 
<a name="l01599"></a>01599      }
<a name="l01600"></a>01600 
<a name="l01601"></a>01601  29) done
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 &lt;/pre&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h6 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2521846&quot;</span>&gt;&lt;/a&gt;7.2.2.2.2. step 2: curve synthesis&lt;/h6&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01604"></a>01604 Curve synthesis generates a <span class="keywordflow">return</span> vector &lt;code class=&quot;varname&quot;&gt;[floor]&lt;/code&gt; of length
<a name="l01605"></a>01605 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[n]&lt;/code&gt; (where &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; is provided by the decode process
<a name="l01606"></a>01606 calling to floor decode).  Floor 1 curve synthesis makes use of the
<a name="l01607"></a>01607 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_X_list]&lt;/code&gt;, &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_final_Y]&lt;/code&gt; and
<a name="l01608"></a>01608 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_step2_flag]&lt;/code&gt; vectors, as well as [floor1_multiplier]
<a name="l01609"></a>01609 and [floor1_values] values.&lt;/p&gt;&lt;p&gt;
<a name="l01610"></a>01610 Decode begins by sorting the scalars from vectors
<a name="l01611"></a>01611 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_X_list]&lt;/code&gt;, &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_final_Y]&lt;/code&gt; and
<a name="l01612"></a>01612 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_step2_flag]&lt;/code&gt; together into <span class="keyword">new</span> vectors
<a name="l01613"></a>01613 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_X_list]<span class="stringliteral">&#39;&lt;/code&gt;, &lt;code class=&quot;varname&quot;&gt;[floor1_final_Y]&#39;</span>&lt;/code&gt; and
<a name="l01614"></a>01614 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_step2_flag]<span class="stringliteral">&#39;&lt;/code&gt; according to ascending sort order of the</span>
<a name="l01615"></a>01615 <span class="stringliteral">values in &lt;code class=&quot;varname&quot;&gt;[floor1_X_list]&lt;/code&gt;.  That is, sort the values of</span>
<a name="l01616"></a>01616 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[floor1_X_list]&lt;/code&gt; and then apply the same permutation to</span>
<a name="l01617"></a>01617 <span class="stringliteral">elements of the other two vectors so that the X, Y and step2_flag</span>
<a name="l01618"></a>01618 <span class="stringliteral">values still match.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01619"></a>01619 <span class="stringliteral">Then compute the final curve in one pass:&lt;/p&gt;&lt;pre class=&quot;screen&quot;&gt;</span>
<a name="l01620"></a>01620 <span class="stringliteral">  1) [hx] = 0</span>
<a name="l01621"></a>01621 <span class="stringliteral">  2) [lx] = 0</span>
<a name="l01622"></a>01622 <span class="stringliteral">  3) [ly] = vector [floor1_final_Y]&#39;</span> element [0] * [floor1_multiplier]
<a name="l01623"></a>01623   4) iterate [i] over the range 1 ... [floor1_values]-1 {
<a name="l01624"></a>01624 
<a name="l01625"></a>01625        5) <span class="keywordflow">if</span> ( [floor1_step2_flag]<span class="stringliteral">&#39; element [i] is set ) {</span>
<a name="l01626"></a>01626 <span class="stringliteral"></span>
<a name="l01627"></a>01627 <span class="stringliteral">             6) [hy] = [floor1_final_Y]&#39;</span> element [i] * [floor1_multiplier]
<a name="l01628"></a>01628              7) [hx] = [floor1_X_list]<span class="stringliteral">&#39; element [i]</span>
<a name="l01629"></a>01629 <span class="stringliteral">             8) &lt;a href=&quot;#vorbis-spec-render_line&quot; title=&quot;9.2.4.3. render_line&quot;&gt;render_line&lt;/a&gt;( [lx], [ly], [hx], [hy], [floor] )</span>
<a name="l01630"></a>01630 <span class="stringliteral">             9) [lx] = [hx]</span>
<a name="l01631"></a>01631 <span class="stringliteral">            10) [ly] = [hy]</span>
<a name="l01632"></a>01632 <span class="stringliteral">          }</span>
<a name="l01633"></a>01633 <span class="stringliteral">     }</span>
<a name="l01634"></a>01634 <span class="stringliteral"> </span>
<a name="l01635"></a>01635 <span class="stringliteral"> 11) if ( [hx] is less than [n] ) {</span>
<a name="l01636"></a>01636 <span class="stringliteral"></span>
<a name="l01637"></a>01637 <span class="stringliteral">        12) &lt;a href=&quot;#vorbis-spec-render_line&quot; title=&quot;9.2.4.3. render_line&quot;&gt;render_line&lt;/a&gt;( [hx], [hy], [n], [hy], [floor] )</span>
<a name="l01638"></a>01638 <span class="stringliteral"></span>
<a name="l01639"></a>01639 <span class="stringliteral">     }</span>
<a name="l01640"></a>01640 <span class="stringliteral"></span>
<a name="l01641"></a>01641 <span class="stringliteral"> 13) if ( [hx] is greater than [n] ) {</span>
<a name="l01642"></a>01642 <span class="stringliteral"></span>
<a name="l01643"></a>01643 <span class="stringliteral">            14) truncate vector [floor] to [n] elements</span>
<a name="l01644"></a>01644 <span class="stringliteral"></span>
<a name="l01645"></a>01645 <span class="stringliteral">     }</span>
<a name="l01646"></a>01646 <span class="stringliteral"> </span>
<a name="l01647"></a>01647 <span class="stringliteral"> 15) for each scalar in vector [floor], perform a lookup substitution using </span>
<a name="l01648"></a>01648 <span class="stringliteral">     the scalar value from [floor] as an offset into the vector &lt;a href=&quot;#vorbis-spec-floor1_inverse_dB_table&quot; title=&quot;10.1. floor1_inverse_dB_table&quot;&gt;[floor1_inverse_dB_static_table]&lt;/a&gt;</span>
<a name="l01649"></a>01649 <span class="stringliteral"></span>
<a name="l01650"></a>01650 <span class="stringliteral"> 16) done</span>
<a name="l01651"></a>01651 <span class="stringliteral"></span>
<a name="l01652"></a>01652 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-residue&quot;&gt;&lt;/a&gt;8. Residue setup and decode&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;</span>
<a name="l01653"></a>01653 <span class="stringliteral">  $Id: 08-residue.xml 10466 2005-11-28 00:34:44Z giles $</span>
<a name="l01654"></a>01654 <span class="stringliteral"> &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2524422&quot;&gt;&lt;/a&gt;8.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01655"></a>01655 <span class="stringliteral">A residue vector represents the fine detail of the audio spectrum of</span>
<a name="l01656"></a>01656 <span class="stringliteral">one channel in an audio frame after the encoder subtracts the floor</span>
<a name="l01657"></a>01657 <span class="stringliteral">curve and performs any channel coupling.  A residue vector may</span>
<a name="l01658"></a>01658 <span class="stringliteral">represent spectral lines, spectral magnitude, spectral phase or</span>
<a name="l01659"></a>01659 <span class="stringliteral">hybrids as mixed by channel coupling.  The exact semantic content of</span>
<a name="l01660"></a>01660 <span class="stringliteral">the vector does not matter to the residue abstraction.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01661"></a>01661 <span class="stringliteral">Whatever the exact qualities, the Vorbis residue abstraction codes the</span>
<a name="l01662"></a>01662 <span class="stringliteral">residue vectors into the bitstream packet, and then reconstructs the</span>
<a name="l01663"></a>01663 <span class="stringliteral">vectors during decode.  Vorbis makes use of three different encoding</span>
<a name="l01664"></a>01664 <span class="stringliteral">variants (numbered 0, 1 and 2) of the same basic vector encoding</span>
<a name="l01665"></a>01665 <span class="stringliteral">abstraction.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2517330&quot;&gt;&lt;/a&gt;8.2. Residue format&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01666"></a>01666 <span class="stringliteral">Residue format partitions each vector in the vector bundle into chunks,</span>
<a name="l01667"></a>01667 <span class="stringliteral">classifies each chunk, encodes the chunk classifications and finally</span>
<a name="l01668"></a>01668 <span class="stringliteral">encodes the chunks themselves using the the specific VQ arrangement</span>
<a name="l01669"></a>01669 <span class="stringliteral">defined for each selected classification.</span>
<a name="l01670"></a>01670 <span class="stringliteral">The exact interleaving and partitioning vary by residue encoding number,</span>
<a name="l01671"></a>01671 <span class="stringliteral">however the high-level process used to classify and encode the residue </span>
<a name="l01672"></a>01672 <span class="stringliteral">vector is the same in all three variants.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01673"></a>01673 <span class="stringliteral">A set of coded residue vectors are all of the same length.  High level</span>
<a name="l01674"></a>01674 <span class="stringliteral">coding structure, ignoring for the moment exactly how a partition is</span>
<a name="l01675"></a>01675 <span class="stringliteral">encoded and simply trusting that it is, is as follows:&lt;/p&gt;&lt;p&gt;</span>
<a name="l01676"></a>01676 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;p&gt;Each vector is partitioned into multiple equal sized chunks</span>
<a name="l01677"></a>01677 <span class="stringliteral">according to configuration specified.  If we have a vector size of</span>
<a name="l01678"></a>01678 <span class="stringliteral">&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;, a partition size &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;residue_partition_size&lt;/em&gt;&lt;/span&gt;, and a total</span>
<a name="l01679"></a>01679 <span class="stringliteral">of &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt; residue vectors, the total number of partitioned chunks</span>
<a name="l01680"></a>01680 <span class="stringliteral">coded is &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;/&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;residue_partition_size&lt;/em&gt;&lt;/span&gt;*&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt;.  It is</span>
<a name="l01681"></a>01681 <span class="stringliteral">important to note that the integer division truncates.  In the below</span>
<a name="l01682"></a>01682 <span class="stringliteral">example, we assume an example &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;residue_partition_size&lt;/em&gt;&lt;/span&gt; of 8.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Each partition in each vector has a classification number that</span>
<a name="l01683"></a>01683 <span class="stringliteral">specifies which of multiple configured VQ codebook setups are used to</span>
<a name="l01684"></a>01684 <span class="stringliteral">decode that partition.  The classification numbers of each partition</span>
<a name="l01685"></a>01685 <span class="stringliteral">can be thought of as forming a vector in their own right, as in the</span>
<a name="l01686"></a>01686 <span class="stringliteral">illustration below.  Just as the residue vectors are coded in grouped</span>
<a name="l01687"></a>01687 <span class="stringliteral">partitions to increase encoding efficiency, the classification vector</span>
<a name="l01688"></a>01688 <span class="stringliteral">is also partitioned into chunks.  The integer elements of each scalar</span>
<a name="l01689"></a>01689 <span class="stringliteral">in a classification chunk are built into a single scalar that</span>
<a name="l01690"></a>01690 <span class="stringliteral">represents the classification numbers in that chunk.  In the below</span>
<a name="l01691"></a>01691 <span class="stringliteral">example, the classification codeword encodes two classification</span>
<a name="l01692"></a>01692 <span class="stringliteral">numbers.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The values in a residue vector may be encoded monolithically in a</span>
<a name="l01693"></a>01693 <span class="stringliteral">single pass through the residue vector, but more often efficient</span>
<a name="l01694"></a>01694 <span class="stringliteral">codebook design dictates that each vector is encoded as the additive</span>
<a name="l01695"></a>01695 <span class="stringliteral">sum of several passes through the residue vector using more than one</span>
<a name="l01696"></a>01696 <span class="stringliteral">VQ codebook.  Thus, each residue value potentially accumulates values</span>
<a name="l01697"></a>01697 <span class="stringliteral">from multiple decode passes.  The classification value associated with</span>
<a name="l01698"></a>01698 <span class="stringliteral">a partition is the same in each pass, thus the classification codeword</span>
<a name="l01699"></a>01699 <span class="stringliteral">is coded only in the first pass.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01700"></a>01700 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;residue-pack.png&quot; alt=&quot;[illustration of residue vector format]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2506346&quot;&gt;&lt;/a&gt;8.3. residue 0&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01701"></a>01701 <span class="stringliteral">Residue 0 and 1 differ only in the way the values within a residue</span>
<a name="l01702"></a>01702 <span class="stringliteral">partition are interleaved during partition encoding (visually treated</span>
<a name="l01703"></a>01703 <span class="stringliteral">as a black box--or cyan box or brown box--in the above figure).&lt;/p&gt;&lt;p&gt;</span>
<a name="l01704"></a>01704 <span class="stringliteral">Residue encoding 0 interleaves VQ encoding according to the</span>
<a name="l01705"></a>01705 <span class="stringliteral">dimension of the codebook used to encode a partition in a specific</span>
<a name="l01706"></a>01706 <span class="stringliteral">pass.  The dimension of the codebook need not be the same in multiple</span>
<a name="l01707"></a>01707 <span class="stringliteral">passes, however the partition size must be an even multiple of the</span>
<a name="l01708"></a>01708 <span class="stringliteral">codebook dimension.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01709"></a>01709 <span class="stringliteral">As an example, assume a partition vector of size eight, to be encoded</span>
<a name="l01710"></a>01710 <span class="stringliteral">by residue 0 using codebook sizes of 8, 4, 2 and 1:&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01711"></a>01711 <span class="stringliteral"></span>
<a name="l01712"></a>01712 <span class="stringliteral">            original residue vector: [ 0 1 2 3 4 5 6 7 ]</span>
<a name="l01713"></a>01713 <span class="stringliteral"></span>
<a name="l01714"></a>01714 <span class="stringliteral">codebook dimensions = 8  encoded as: [ 0 1 2 3 4 5 6 7 ]</span>
<a name="l01715"></a>01715 <span class="stringliteral"></span>
<a name="l01716"></a>01716 <span class="stringliteral">codebook dimensions = 4  encoded as: [ 0 2 4 6 ], [ 1 3 5 7 ]</span>
<a name="l01717"></a>01717 <span class="stringliteral"></span>
<a name="l01718"></a>01718 <span class="stringliteral">codebook dimensions = 2  encoded as: [ 0 4 ], [ 1 5 ], [ 2 6 ], [ 3 7 ]</span>
<a name="l01719"></a>01719 <span class="stringliteral"></span>
<a name="l01720"></a>01720 <span class="stringliteral">codebook dimensions = 1  encoded as: [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ]</span>
<a name="l01721"></a>01721 <span class="stringliteral"></span>
<a name="l01722"></a>01722 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01723"></a>01723 <span class="stringliteral">It is worth mentioning at this point that no configurable value in the</span>
<a name="l01724"></a>01724 <span class="stringliteral">residue coding setup is restricted to a power of two.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2517602&quot;&gt;&lt;/a&gt;8.4. residue 1&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01725"></a>01725 <span class="stringliteral">Residue 1 does not interleave VQ encoding.  It represents partition</span>
<a name="l01726"></a>01726 <span class="stringliteral">vector scalars in order.  As with residue 0, however, partition length</span>
<a name="l01727"></a>01727 <span class="stringliteral">must be an integer multiple of the codebook dimension, although</span>
<a name="l01728"></a>01728 <span class="stringliteral">dimension may vary from pass to pass.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01729"></a>01729 <span class="stringliteral">As an example, assume a partition vector of size eight, to be encoded</span>
<a name="l01730"></a>01730 <span class="stringliteral">by residue 0 using codebook sizes of 8, 4, 2 and 1:&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01731"></a>01731 <span class="stringliteral"></span>
<a name="l01732"></a>01732 <span class="stringliteral">            original residue vector: [ 0 1 2 3 4 5 6 7 ]</span>
<a name="l01733"></a>01733 <span class="stringliteral"></span>
<a name="l01734"></a>01734 <span class="stringliteral">codebook dimensions = 8  encoded as: [ 0 1 2 3 4 5 6 7 ]</span>
<a name="l01735"></a>01735 <span class="stringliteral"></span>
<a name="l01736"></a>01736 <span class="stringliteral">codebook dimensions = 4  encoded as: [ 0 1 2 3 ], [ 4 5 6 7 ]</span>
<a name="l01737"></a>01737 <span class="stringliteral"></span>
<a name="l01738"></a>01738 <span class="stringliteral">codebook dimensions = 2  encoded as: [ 0 1 ], [ 2 3 ], [ 4 5 ], [ 6 7 ]</span>
<a name="l01739"></a>01739 <span class="stringliteral"></span>
<a name="l01740"></a>01740 <span class="stringliteral">codebook dimensions = 1  encoded as: [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ]</span>
<a name="l01741"></a>01741 <span class="stringliteral"></span>
<a name="l01742"></a>01742 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2517633&quot;&gt;&lt;/a&gt;8.5. residue 2&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01743"></a>01743 <span class="stringliteral">Residue type two can be thought of as a variant of residue type 1.</span>
<a name="l01744"></a>01744 <span class="stringliteral">Rather than encoding multiple passed-in vectors as in residue type 1,</span>
<a name="l01745"></a>01745 <span class="stringliteral">the &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt; passed in vectors of length &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; are first</span>
<a name="l01746"></a>01746 <span class="stringliteral">interleaved and flattened into a single vector of length</span>
<a name="l01747"></a>01747 <span class="stringliteral">&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt;*&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;.  Encoding then proceeds as in type 1. Decoding is</span>
<a name="l01748"></a>01748 <span class="stringliteral">as in type 1 with decode interleave reversed. If operating on a single</span>
<a name="l01749"></a>01749 <span class="stringliteral">vector to begin with, residue type 1 and type 2 are equivalent.&lt;/p&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;residue2.png&quot; alt=&quot;[illustration of residue type 2]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2538870&quot;&gt;&lt;/a&gt;8.6. Residue decode&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2538876&quot;&gt;&lt;/a&gt;8.6.1. header decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01750"></a>01750 <span class="stringliteral">Header decode for all three residue types is identical.&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01751"></a>01751 <span class="stringliteral">  1) [residue_begin] = read 24 bits as unsigned integer</span>
<a name="l01752"></a>01752 <span class="stringliteral">  2) [residue_end] = read 24 bits as unsigned integer</span>
<a name="l01753"></a>01753 <span class="stringliteral">  3) [residue_partition_size] = read 24 bits as unsigned integer and add one</span>
<a name="l01754"></a>01754 <span class="stringliteral">  4) [residue_classifications] = read 6 bits as unsigned integer and add one</span>
<a name="l01755"></a>01755 <span class="stringliteral">  5) [residue_classbook] = read 8 bits as unsigned integer</span>
<a name="l01756"></a>01756 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01757"></a>01757 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_begin]&lt;/code&gt; and &lt;code class=&quot;varname&quot;&gt;[residue_end]&lt;/code&gt; select the specific</span>
<a name="l01758"></a>01758 <span class="stringliteral">sub-portion of each vector that is actually coded; it implements akin</span>
<a name="l01759"></a>01759 <span class="stringliteral">to a bandpass where, for coding purposes, the vector effectively</span>
<a name="l01760"></a>01760 <span class="stringliteral">begins at element &lt;code class=&quot;varname&quot;&gt;[residue_begin]&lt;/code&gt; and ends at</span>
<a name="l01761"></a>01761 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_end]&lt;/code&gt;.  Preceding and following values in the unpacked</span>
<a name="l01762"></a>01762 <span class="stringliteral">vectors are zeroed.  Note that for residue type 2, these values as</span>
<a name="l01763"></a>01763 <span class="stringliteral">well as &lt;code class=&quot;varname&quot;&gt;[residue_partition_size]&lt;/code&gt;apply to the interleaved</span>
<a name="l01764"></a>01764 <span class="stringliteral">vector, not the individual vectors before interleave.</span>
<a name="l01765"></a>01765 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_partition_size]&lt;/code&gt; is as explained above,</span>
<a name="l01766"></a>01766 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_classifications]&lt;/code&gt; is the number of possible</span>
<a name="l01767"></a>01767 <span class="stringliteral">classification to which a partition can belong and</span>
<a name="l01768"></a>01768 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_classbook]&lt;/code&gt; is the codebook number used to code</span>
<a name="l01769"></a>01769 <span class="stringliteral">classification codewords.  The number of dimensions in book</span>
<a name="l01770"></a>01770 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_classbook]&lt;/code&gt; determines how many classification values</span>
<a name="l01771"></a>01771 <span class="stringliteral">are grouped into a single classification codeword.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01772"></a>01772 <span class="stringliteral">Next we read a bitmap pattern that specifies which partition classes</span>
<a name="l01773"></a>01773 <span class="stringliteral">code values in which passes.&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01774"></a>01774 <span class="stringliteral">  1) iterate [i] over the range 0 ... [residue_classifications]-1 {</span>
<a name="l01775"></a>01775 <span class="stringliteral">  </span>
<a name="l01776"></a>01776 <span class="stringliteral">       2) [high_bits] = 0</span>
<a name="l01777"></a>01777 <span class="stringliteral">       3) [low_bits] = read 3 bits as unsigned integer</span>
<a name="l01778"></a>01778 <span class="stringliteral">       4) [bitflag] = read one bit as boolean</span>
<a name="l01779"></a>01779 <span class="stringliteral">       5) if ( [bitflag] is set ) then [high_bits] = read five bits as unsigned integer</span>
<a name="l01780"></a>01780 <span class="stringliteral">       6) vector [residue_cascade] element [i] = [high_bits] * 8 + [low_bits]</span>
<a name="l01781"></a>01781 <span class="stringliteral">     }</span>
<a name="l01782"></a>01782 <span class="stringliteral">  7) done</span>
<a name="l01783"></a>01783 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01784"></a>01784 <span class="stringliteral">Finally, we read in a list of book numbers, each corresponding to</span>
<a name="l01785"></a>01785 <span class="stringliteral">specific bit set in the cascade bitmap.  We loop over the possible</span>
<a name="l01786"></a>01786 <span class="stringliteral">codebook classifications and the maximum possible number of encoding</span>
<a name="l01787"></a>01787 <span class="stringliteral">stages (8 in Vorbis I, as constrained by the elements of the cascade</span>
<a name="l01788"></a>01788 <span class="stringliteral">bitmap being eight bits):&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01789"></a>01789 <span class="stringliteral">  1) iterate [i] over the range 0 ... [residue_classifications]-1 {</span>
<a name="l01790"></a>01790 <span class="stringliteral">  </span>
<a name="l01791"></a>01791 <span class="stringliteral">       2) iterate [j] over the range 0 ... 7 {</span>
<a name="l01792"></a>01792 <span class="stringliteral">  </span>
<a name="l01793"></a>01793 <span class="stringliteral">            3) if ( vector [residue_cascade] element [i] bit [j] is set ) {</span>
<a name="l01794"></a>01794 <span class="stringliteral"></span>
<a name="l01795"></a>01795 <span class="stringliteral">                 4) array [residue_books] element [i][j] = read 8 bits as unsigned integer</span>
<a name="l01796"></a>01796 <span class="stringliteral"></span>
<a name="l01797"></a>01797 <span class="stringliteral">               } else {</span>
<a name="l01798"></a>01798 <span class="stringliteral"></span>
<a name="l01799"></a>01799 <span class="stringliteral">                 5) array [residue_books] element [i][j] = unused</span>
<a name="l01800"></a>01800 <span class="stringliteral"></span>
<a name="l01801"></a>01801 <span class="stringliteral">               }</span>
<a name="l01802"></a>01802 <span class="stringliteral">          }</span>
<a name="l01803"></a>01803 <span class="stringliteral">      }</span>
<a name="l01804"></a>01804 <span class="stringliteral"></span>
<a name="l01805"></a>01805 <span class="stringliteral">  6) done</span>
<a name="l01806"></a>01806 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01807"></a>01807 <span class="stringliteral">An end-of-packet condition at any point in header decode renders the</span>
<a name="l01808"></a>01808 <span class="stringliteral">stream undecodable.  In addition, any codebook number greater than the</span>
<a name="l01809"></a>01809 <span class="stringliteral">maximum numbered codebook set up in this stream also renders the</span>
<a name="l01810"></a>01810 <span class="stringliteral">stream undecodable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2538992&quot;&gt;&lt;/a&gt;8.6.2. packet decode&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01811"></a>01811 <span class="stringliteral">Format 0 and 1 packet decode is identical except for specific</span>
<a name="l01812"></a>01812 <span class="stringliteral">partition interleave.  Format 2 packet decode can be built out of the</span>
<a name="l01813"></a>01813 <span class="stringliteral">format 1 decode process.  Thus we describe first the decode</span>
<a name="l01814"></a>01814 <span class="stringliteral">infrastructure identical to all three formats.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01815"></a>01815 <span class="stringliteral">In addition to configuration information, the residue decode process</span>
<a name="l01816"></a>01816 <span class="stringliteral">is passed the number of vectors in the submap bundle and a vector of</span>
<a name="l01817"></a>01817 <span class="stringliteral">flags indicating if any of the vectors are not to be decoded.  If the</span>
<a name="l01818"></a>01818 <span class="stringliteral">passed in number of vectors is 3 and vector number 1 is marked &#39;</span><span class="keywordflow">do</span> not
<a name="l01819"></a>01819 decode<span class="stringliteral">&#39;, decode skips vector 1 during the decode loop.  However, even</span>
<a name="l01820"></a>01820 <span class="stringliteral">&#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39; vectors are allocated and zeroed.&lt;/p&gt;&lt;p&gt;</span>
<a name="l01821"></a>01821 <span class="stringliteral">The following convenience values are conceptually useful to clarifying</span>
<a name="l01822"></a>01822 <span class="stringliteral">the decode process:&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01823"></a>01823 <span class="stringliteral">  1) [classwords_per_codeword] = [codebook_dimensions] value of codebook [residue_classbook]</span>
<a name="l01824"></a>01824 <span class="stringliteral">  2) [n_to_read] = [residue_end] - [residue_begin]</span>
<a name="l01825"></a>01825 <span class="stringliteral">  3) [partitions_to_read] = [n_to_read] / [residue_partition_size]</span>
<a name="l01826"></a>01826 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01827"></a>01827 <span class="stringliteral">Packet decode proceeds as follows, matching the description offered earlier in the document.  We assume that the number of vectors being encoded, &lt;code class=&quot;varname&quot;&gt;[ch]&lt;/code&gt; is provided by the higher level decoding process.&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01828"></a>01828 <span class="stringliteral">  1) allocate and zero all vectors that will be returned.</span>
<a name="l01829"></a>01829 <span class="stringliteral">  2) iterate [pass] over the range 0 ... 7 {</span>
<a name="l01830"></a>01830 <span class="stringliteral"></span>
<a name="l01831"></a>01831 <span class="stringliteral">       3) [partition_count] = 0</span>
<a name="l01832"></a>01832 <span class="stringliteral"></span>
<a name="l01833"></a>01833 <span class="stringliteral">       4) while [partition_count] is less than [partitions_to_read]</span>
<a name="l01834"></a>01834 <span class="stringliteral"></span>
<a name="l01835"></a>01835 <span class="stringliteral">            5) if ([pass] is zero) {</span>
<a name="l01836"></a>01836 <span class="stringliteral">     </span>
<a name="l01837"></a>01837 <span class="stringliteral">                 6) iterate [j] over the range 0 .. [ch]-1 {</span>
<a name="l01838"></a>01838 <span class="stringliteral"></span>
<a name="l01839"></a>01839 <span class="stringliteral">                      7) if vector [j] is not marked &#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39; {</span>
<a name="l01840"></a>01840 <span class="stringliteral"></span>
<a name="l01841"></a>01841 <span class="stringliteral">                           8) [temp] = read from packet using codebook [residue_classbook] in scalar context</span>
<a name="l01842"></a>01842 <span class="stringliteral">                           9) iterate [i] descending over the range [classwords_per_codeword]-1 ... 0 {</span>
<a name="l01843"></a>01843 <span class="stringliteral"></span>
<a name="l01844"></a>01844 <span class="stringliteral">                               10) array [classifications] element [j],([i]+[partition_count]) =</span>
<a name="l01845"></a>01845 <span class="stringliteral">                                   [temp] integer modulo [residue_classifications]</span>
<a name="l01846"></a>01846 <span class="stringliteral">                               11) [temp] = [temp] / [residue_classifications] using integer division</span>
<a name="l01847"></a>01847 <span class="stringliteral"></span>
<a name="l01848"></a>01848 <span class="stringliteral">                              }</span>
<a name="l01849"></a>01849 <span class="stringliteral">      </span>
<a name="l01850"></a>01850 <span class="stringliteral">                         }</span>
<a name="l01851"></a>01851 <span class="stringliteral">            </span>
<a name="l01852"></a>01852 <span class="stringliteral">                    }</span>
<a name="l01853"></a>01853 <span class="stringliteral">          </span>
<a name="l01854"></a>01854 <span class="stringliteral">               }</span>
<a name="l01855"></a>01855 <span class="stringliteral"></span>
<a name="l01856"></a>01856 <span class="stringliteral">           12) iterate [i] over the range 0 .. ([classwords_per_codeword] - 1) while [partition_count] </span>
<a name="l01857"></a>01857 <span class="stringliteral">               is also less than [partitions_to_read] {</span>
<a name="l01858"></a>01858 <span class="stringliteral"></span>
<a name="l01859"></a>01859 <span class="stringliteral">                 13) iterate [j] over the range 0 .. [ch]-1 {</span>
<a name="l01860"></a>01860 <span class="stringliteral">   </span>
<a name="l01861"></a>01861 <span class="stringliteral">                      14) if vector [j] is not marked &#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39; {</span>
<a name="l01862"></a>01862 <span class="stringliteral">   </span>
<a name="l01863"></a>01863 <span class="stringliteral">                           15) [vqclass] = array [classifications] element [j],[partition_count]</span>
<a name="l01864"></a>01864 <span class="stringliteral">                           16) [vqbook] = array [residue_books] element [vqclass],[pass]</span>
<a name="l01865"></a>01865 <span class="stringliteral">                           17) if ([vqbook] is not &#39;</span>unused<span class="stringliteral">&#39;) {</span>
<a name="l01866"></a>01866 <span class="stringliteral">   </span>
<a name="l01867"></a>01867 <span class="stringliteral">                                18) decode partition into output vector number [j], starting at scalar </span>
<a name="l01868"></a>01868 <span class="stringliteral">                                    offset [residue_begin]+[partition_count]*[residue_partition_size] using </span>
<a name="l01869"></a>01869 <span class="stringliteral">                                    codebook number [vqbook] in VQ context</span>
<a name="l01870"></a>01870 <span class="stringliteral">                          }</span>
<a name="l01871"></a>01871 <span class="stringliteral">                     }</span>
<a name="l01872"></a>01872 <span class="stringliteral">   </span>
<a name="l01873"></a>01873 <span class="stringliteral">                 19) increment [partition_count] by one</span>
<a name="l01874"></a>01874 <span class="stringliteral"></span>
<a name="l01875"></a>01875 <span class="stringliteral">               }</span>
<a name="l01876"></a>01876 <span class="stringliteral">          }</span>
<a name="l01877"></a>01877 <span class="stringliteral">     }</span>
<a name="l01878"></a>01878 <span class="stringliteral"> </span>
<a name="l01879"></a>01879 <span class="stringliteral"> 20) done</span>
<a name="l01880"></a>01880 <span class="stringliteral"></span>
<a name="l01881"></a>01881 <span class="stringliteral">&lt;/pre&gt;&lt;p&gt;</span>
<a name="l01882"></a>01882 <span class="stringliteral">An end-of-packet condition during packet decode is to be considered a</span>
<a name="l01883"></a>01883 <span class="stringliteral">nominal occurrence.  Decode returns the result of vector decode up to</span>
<a name="l01884"></a>01884 <span class="stringliteral">that point.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2498601&quot;&gt;&lt;/a&gt;8.6.3. format 0 specifics&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01885"></a>01885 <span class="stringliteral">Format zero decodes partitions exactly as described earlier in the</span>
<a name="l01886"></a>01886 <span class="stringliteral">&#39;</span>Residue Format: residue 0<span class="stringliteral">&#39; section.  The following pseudocode</span>
<a name="l01887"></a>01887 <span class="stringliteral">presents the same algorithm. Assume:&lt;/p&gt;&lt;p&gt;</span>
<a name="l01888"></a>01888 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt; &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; is the value in &lt;code class=&quot;varname&quot;&gt;[residue_partition_size]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; is the residue vector&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[offset]&lt;/code&gt; is the beginning read offset in [v]&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01889"></a>01889 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01890"></a>01890 <span class="stringliteral"> 1) [step] = [n] / [codebook_dimensions]</span>
<a name="l01891"></a>01891 <span class="stringliteral"> 2) iterate [i] over the range 0 ... [step]-1 {</span>
<a name="l01892"></a>01892 <span class="stringliteral"></span>
<a name="l01893"></a>01893 <span class="stringliteral">      3) vector [entry_temp] = read vector from packet using current codebook in VQ context</span>
<a name="l01894"></a>01894 <span class="stringliteral">      4) iterate [j] over the range 0 ... [codebook_dimensions]-1 {</span>
<a name="l01895"></a>01895 <span class="stringliteral"></span>
<a name="l01896"></a>01896 <span class="stringliteral">           5) vector [v] element ([offset]+[i]+[j]*[step]) =</span>
<a name="l01897"></a>01897 <span class="stringliteral">                vector [v] element ([offset]+[i]+[j]*[step]) +</span>
<a name="l01898"></a>01898 <span class="stringliteral">                vector [entry_temp] element [j]</span>
<a name="l01899"></a>01899 <span class="stringliteral"></span>
<a name="l01900"></a>01900 <span class="stringliteral">         }</span>
<a name="l01901"></a>01901 <span class="stringliteral"></span>
<a name="l01902"></a>01902 <span class="stringliteral">    }</span>
<a name="l01903"></a>01903 <span class="stringliteral"></span>
<a name="l01904"></a>01904 <span class="stringliteral">  6) done</span>
<a name="l01905"></a>01905 <span class="stringliteral"></span>
<a name="l01906"></a>01906 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2498659&quot;&gt;&lt;/a&gt;8.6.4. format 1 specifics&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01907"></a>01907 <span class="stringliteral">Format 1 decodes partitions exactly as described earlier in the</span>
<a name="l01908"></a>01908 <span class="stringliteral">&#39;</span>Residue Format: residue 1<span class="stringliteral">&#39; section.  The following pseudocode</span>
<a name="l01909"></a>01909 <span class="stringliteral">presents the same algorithm. Assume:&lt;/p&gt;&lt;p&gt;</span>
<a name="l01910"></a>01910 <span class="stringliteral">&lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt; &lt;code class=&quot;varname&quot;&gt;[n]&lt;/code&gt; is the value in</span>
<a name="l01911"></a>01911 <span class="stringliteral">&lt;code class=&quot;varname&quot;&gt;[residue_partition_size]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; is the residue vector&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;varname&quot;&gt;[offset]&lt;/code&gt; is the beginning read offset in [v]&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01912"></a>01912 <span class="stringliteral">&lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01913"></a>01913 <span class="stringliteral"> 1) [i] = 0</span>
<a name="l01914"></a>01914 <span class="stringliteral"> 2) vector [entry_temp] = read vector from packet using current codebook in VQ context</span>
<a name="l01915"></a>01915 <span class="stringliteral"> 3) iterate [j] over the range 0 ... [codebook_dimensions]-1 {</span>
<a name="l01916"></a>01916 <span class="stringliteral"></span>
<a name="l01917"></a>01917 <span class="stringliteral">      4) vector [v] element ([offset]+[i]) =</span>
<a name="l01918"></a>01918 <span class="stringliteral">          vector [v] element ([offset]+[i]) +</span>
<a name="l01919"></a>01919 <span class="stringliteral">          vector [entry_temp] element [j]</span>
<a name="l01920"></a>01920 <span class="stringliteral">      5) increment [i]</span>
<a name="l01921"></a>01921 <span class="stringliteral"></span>
<a name="l01922"></a>01922 <span class="stringliteral">    }</span>
<a name="l01923"></a>01923 <span class="stringliteral"> </span>
<a name="l01924"></a>01924 <span class="stringliteral">  6) if ( [i] is less than [n] ) continue at step 2</span>
<a name="l01925"></a>01925 <span class="stringliteral">  7) done</span>
<a name="l01926"></a>01926 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;id2498716&quot;&gt;&lt;/a&gt;8.6.5. format 2 specifics&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01927"></a>01927 <span class="stringliteral">Format 2 is reducible to format 1.  It may be implemented as an additional step prior to and an additional post-decode step after a normal format 1 decode.</span>
<a name="l01928"></a>01928 <span class="stringliteral">&lt;/p&gt;&lt;p&gt;</span>
<a name="l01929"></a>01929 <span class="stringliteral">Format 2 handles &#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39; vectors differently than residue 0 or</span>
<a name="l01930"></a>01930 <span class="stringliteral">1; if all vectors are marked &#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39;, no decode occurrs.</span>
<a name="l01931"></a>01931 <span class="stringliteral">However, if at least one vector is to be decoded, all the vectors are</span>
<a name="l01932"></a>01932 <span class="stringliteral">decoded.  We then request normal format 1 to decode a single vector</span>
<a name="l01933"></a>01933 <span class="stringliteral">representing all output channels, rather than a vector for each</span>
<a name="l01934"></a>01934 <span class="stringliteral">channel.  After decode, deinterleave the vector into independent vectors, one for each output channel.  That is:&lt;/p&gt;&lt;div class=&quot;orderedlist&quot;&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;If all vectors 0 through &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt;-1 are marked &#39;</span><span class="keywordflow">do</span> not decode<span class="stringliteral">&#39;, allocate and clear a single vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt;of length &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch*n&lt;/em&gt;&lt;/span&gt; and skip step 2 below; proceed directly to the post-decode step.&lt;/li&gt;&lt;li&gt;Rather than performing format 1 decode to produce &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt; vectors of length &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; each, call format 1 decode to produce a single vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; of length &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch*n&lt;/em&gt;&lt;/span&gt;. &lt;/li&gt;&lt;li&gt;&lt;p&gt;Post decode: Deinterleave the single vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; returned by format 1 decode as described above into &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;ch&lt;/em&gt;&lt;/span&gt; independent vectors, one for each outputchannel, according to:</span>
<a name="l01935"></a>01935 <span class="stringliteral">  &lt;/p&gt;&lt;pre class=&quot;programlisting&quot;&gt;</span>
<a name="l01936"></a>01936 <span class="stringliteral">  1) iterate [i] over the range 0 ... [n]-1 {</span>
<a name="l01937"></a>01937 <span class="stringliteral"></span>
<a name="l01938"></a>01938 <span class="stringliteral">       2) iterate [j] over the range 0 ... [ch]-1 {</span>
<a name="l01939"></a>01939 <span class="stringliteral"></span>
<a name="l01940"></a>01940 <span class="stringliteral">            3) output vector number [j] element [i] = vector [v] element ([i] * [ch] + [j])</span>
<a name="l01941"></a>01941 <span class="stringliteral"></span>
<a name="l01942"></a>01942 <span class="stringliteral">          }</span>
<a name="l01943"></a>01943 <span class="stringliteral">     }</span>
<a name="l01944"></a>01944 <span class="stringliteral"></span>
<a name="l01945"></a>01945 <span class="stringliteral">  4) done</span>
<a name="l01946"></a>01946 <span class="stringliteral">  &lt;/pre&gt;&lt;p&gt;</span>
<a name="l01947"></a>01947 <span class="stringliteral"> &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-spec-helper&quot;&gt;&lt;/a&gt;9. Helper equations&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;releaseinfo&quot;&gt;</span>
<a name="l01948"></a>01948 <span class="stringliteral"> $Id: 09-helper.xml 7186 2004-07-20 07:19:25Z xiphmont $</span>
<a name="l01949"></a>01949 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2507758&quot;&gt;&lt;/a&gt;9.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01950"></a>01950 <span class="stringliteral">The equations below are used in multiple places by the Vorbis codec</span>
<a name="l01951"></a>01951 <span class="stringliteral">specification.  Rather than cluttering up the main specification</span>
<a name="l01952"></a>01952 <span class="stringliteral">documents, they are defined here and referenced where appropriate.</span>
<a name="l01953"></a>01953 <span class="stringliteral">&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id2512257&quot;&gt;&lt;/a&gt;9.2. Functions&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;section&quot; lang=&quot;en&quot;&gt;&lt;div class=&quot;titlepage&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;h4 class=&quot;title&quot;&gt;&lt;a name=&quot;vorbis-spec-ilog&quot;&gt;&lt;/a&gt;9.2.1. ilog&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l01954"></a>01954 <span class="stringliteral">The &quot;ilog(x)&quot; function returns the position number (1 through n) of the highest set bit in the two&#39;</span>s complement integer value
<a name="l01955"></a>01955 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[x]&lt;/code&gt;.  Values of &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[x]&lt;/code&gt; less than zero are defined to <span class="keywordflow">return</span> zero.&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;programlisting&quot;</span>&gt;
<a name="l01956"></a>01956   1) [return_value] = 0;
<a name="l01957"></a>01957   2) <span class="keywordflow">if</span> ( [x] is greater than zero ){
<a name="l01958"></a>01958       
<a name="l01959"></a>01959        3) increment [return_value];
<a name="l01960"></a>01960        4) logical shift [x] one bit to the right, padding the MSb with zero
<a name="l01961"></a>01961        5) repeat at step 2)
<a name="l01962"></a>01962 
<a name="l01963"></a>01963      }
<a name="l01964"></a>01964 
<a name="l01965"></a>01965    6) done
<a name="l01966"></a>01966 &lt;/pre&gt;&lt;p&gt;
<a name="l01967"></a>01967 Examples:
<a name="l01968"></a>01968 
<a name="l01969"></a>01969 &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;itemizedlist&quot;</span>&gt;&lt;ul type=<span class="stringliteral">&quot;disc&quot;</span>&gt;&lt;li&gt;ilog(0) = 0;&lt;/li&gt;&lt;li&gt;ilog(1) = 1;&lt;/li&gt;&lt;li&gt;ilog(2) = 2;&lt;/li&gt;&lt;li&gt;ilog(3) = 2;&lt;/li&gt;&lt;li&gt;ilog(4) = 3;&lt;/li&gt;&lt;li&gt;ilog(7) = 3;&lt;/li&gt;&lt;li&gt;ilog(negative number) = 0;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01970"></a>01970 &lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-float32_unpack&quot;</span>&gt;&lt;/a&gt;9.2.2. float32_unpack&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01971"></a>01971 <span class="stringliteral">&quot;float32_unpack(x)&quot;</span> is intended to translate the packed binary
<a name="l01972"></a>01972 representation of a Vorbis <a class="code" href="structcodebook.html">codebook</a> <span class="keywordtype">float</span> value into the
<a name="l01973"></a>01973 representation used by the decoder <span class="keywordflow">for</span> floating point numbers.  For
<a name="l01974"></a>01974 purposes of <span class="keyword">this</span> example, we will unpack a Vorbis float32 into a
<a name="l01975"></a>01975 host-native floating point number.&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;programlisting&quot;</span>&gt;
<a name="l01976"></a>01976   1) [mantissa] = [x] bitwise AND 0x1fffff (<span class="keywordtype">unsigned</span> result)
<a name="l01977"></a>01977   2) [sign] = [x] bitwise AND 0x80000000 (<span class="keywordtype">unsigned</span> result)
<a name="l01978"></a>01978   3) [exponent] = ( [x] bitwise AND 0x7fe00000) shifted right 21 bits (<span class="keywordtype">unsigned</span> result)
<a name="l01979"></a>01979   4) <span class="keywordflow">if</span> ( [sign] is nonzero ) then negate [mantissa]
<a name="l01980"></a>01980   5) <span class="keywordflow">return</span> [mantissa] * ( 2 ^ ( [exponent] - 788 ) )
<a name="l01981"></a>01981 &lt;/pre&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-lookup1_values&quot;</span>&gt;&lt;/a&gt;9.2.3. lookup1_values&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01982"></a>01982 <span class="stringliteral">&quot;lookup1_values(codebook_entries,codebook_dimensions)&quot;</span> is used to
<a name="l01983"></a>01983 compute the correct length of the value index <span class="keywordflow">for</span> a <a class="code" href="structcodebook.html">codebook</a> VQ lookup
<a name="l01984"></a>01984 table of lookup type 1.  The values on <span class="keyword">this</span> list are permuted to
<a name="l01985"></a>01985 construct the VQ vector lookup table of size
<a name="l01986"></a>01986 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[codebook_entries]&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;
<a name="l01987"></a>01987 The <span class="keywordflow">return</span> value <span class="keywordflow">for</span> <span class="keyword">this</span> function is defined to be <span class="stringliteral">&#39;the greatest</span>
<a name="l01988"></a>01988 <span class="stringliteral">integer value for which &lt;code class=&quot;varname&quot;&gt;[return_value] to the power of</span>
<a name="l01989"></a>01989 <span class="stringliteral">[codebook_dimensions] is less than or equal to</span>
<a name="l01990"></a>01990 <span class="stringliteral">[codebook_entries]&lt;/code&gt;&#39;</span>.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-low_neighbor&quot;</span>&gt;&lt;/a&gt;9.2.4. low_neighbor&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01991"></a>01991 <span class="stringliteral">&quot;low_neighbor(v,x)&quot;</span> finds the position &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; in vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; of
<a name="l01992"></a>01992 the greatest value scalar element <span class="keywordflow">for</span> which &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; is less than
<a name="l01993"></a>01993 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[x]&lt;/code&gt; and vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; is less
<a name="l01994"></a>01994 than vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[x]&lt;/code&gt;.&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h5 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-high_neighbor&quot;</span>&gt;&lt;/a&gt;9.2.4.1. high_neighbor&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01995"></a>01995 <span class="stringliteral">&quot;high_neighbor(v,x)&quot;</span> finds the position &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; in vector [v] of
<a name="l01996"></a>01996 the lowest value scalar element <span class="keywordflow">for</span> which &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; is less than
<a name="l01997"></a>01997 &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[x]&lt;/code&gt; and vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;n&lt;/code&gt; is greater
<a name="l01998"></a>01998 than vector &lt;code class=&quot;varname&quot;&gt;[v]&lt;/code&gt; element &lt;code class=&quot;varname&quot;&gt;[x]&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h5 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-render_point&quot;</span>&gt;&lt;/a&gt;9.2.4.2. render_point&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l01999"></a>01999 <span class="stringliteral">&quot;render_point(x0,y0,x1,y1,X)&quot;</span> is used to find the Y value at point X
<a name="l02000"></a>02000 along the line specified by x0, x1, y0 and y1.  This function uses an
<a name="l02001"></a>02001 integer algorithm to solve <span class="keywordflow">for</span> the point directly without calculating
<a name="l02002"></a>02002 intervening values along the line.&lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;programlisting&quot;</span>&gt;
<a name="l02003"></a>02003   1)  [dy] = [y1] - [y0]
<a name="l02004"></a>02004   2) [adx] = [x1] - [x0]
<a name="l02005"></a>02005   3) [ady] = absolute value of [dy]
<a name="l02006"></a>02006   4) [err] = [ady] * ([X] - [x0])
<a name="l02007"></a>02007   5) [off] = [err] / [adx] <span class="keyword">using</span> integer division
<a name="l02008"></a>02008   6) <span class="keywordflow">if</span> ( [dy] is less than zero ) {
<a name="l02009"></a>02009 
<a name="l02010"></a>02010        7) [Y] = [y0] - [off]
<a name="l02011"></a>02011 
<a name="l02012"></a>02012      } <span class="keywordflow">else</span> {
<a name="l02013"></a>02013 
<a name="l02014"></a>02014        8) [Y] = [y0] + [off]
<a name="l02015"></a>02015   
<a name="l02016"></a>02016      }
<a name="l02017"></a>02017 
<a name="l02018"></a>02018   9) done
<a name="l02019"></a>02019 &lt;/pre&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h5 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-render_line&quot;</span>&gt;&lt;/a&gt;9.2.4.3. render_line&lt;/h5&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02020"></a>02020 Floor decode type one uses the integer line drawing algorithm of
<a name="l02021"></a>02021 <span class="stringliteral">&quot;render_line(x0, y0, x1, y1, v)&quot;</span> to construct an integer floor
<a name="l02022"></a>02022 curve <span class="keywordflow">for</span> contiguous piecewise line segments. Note that it has not
<a name="l02023"></a>02023 been relevant elsewhere, but here we must define integer division as
<a name="l02024"></a>02024 rounding division of both positive and negative numbers toward zero.
<a name="l02025"></a>02025 &lt;/p&gt;&lt;pre <span class="keyword">class</span>=<span class="stringliteral">&quot;programlisting&quot;</span>&gt;
<a name="l02026"></a>02026   1)   [dy] = [y1] - [y0]
<a name="l02027"></a>02027   2)  [adx] = [x1] - [x0]
<a name="l02028"></a>02028   3)  [ady] = absolute value of [dy]
<a name="l02029"></a>02029   4) [base] = [dy] / [adx] <span class="keyword">using</span> integer division
<a name="l02030"></a>02030   5)    [x] = [x0]
<a name="l02031"></a>02031   6)    [y] = [y0]
<a name="l02032"></a>02032   7)  [err] = 0
<a name="l02033"></a>02033 
<a name="l02034"></a>02034   8) <span class="keywordflow">if</span> ( [dy] is less than 0 ) {
<a name="l02035"></a>02035 
<a name="l02036"></a>02036         9) [sy] = [base] - 1
<a name="l02037"></a>02037 
<a name="l02038"></a>02038      } <span class="keywordflow">else</span> {
<a name="l02039"></a>02039 
<a name="l02040"></a>02040        10) [sy] = [base] + 1
<a name="l02041"></a>02041 
<a name="l02042"></a>02042      }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044  11) [ady] = [ady] - (absolute value of [base]) * [adx]
<a name="l02045"></a>02045  12) vector [v] element [x] = [y]
<a name="l02046"></a>02046 
<a name="l02047"></a>02047  13) iterate [x] over the range [x0]+1 ... [x1]-1 {
<a name="l02048"></a>02048 
<a name="l02049"></a>02049        14) [err] = [err] + [ady];
<a name="l02050"></a>02050        15) <span class="keywordflow">if</span> ( [err] &amp;gt;= [adx] ) {
<a name="l02051"></a>02051 
<a name="l02052"></a>02052              16) [err] = [err] - [adx]
<a name="l02053"></a>02053              17)   [y] = [y] + [sy]
<a name="l02054"></a>02054 
<a name="l02055"></a>02055            } <span class="keywordflow">else</span> {
<a name="l02056"></a>02056 
<a name="l02057"></a>02057              18) [y] = [y] + [base]
<a name="l02058"></a>02058    
<a name="l02059"></a>02059            }
<a name="l02060"></a>02060 
<a name="l02061"></a>02061        19) vector [v] element [x] = [y]
<a name="l02062"></a>02062 
<a name="l02063"></a>02063      }
<a name="l02064"></a>02064 &lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h2 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span> style=<span class="stringliteral">&quot;clear: both&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-tables&quot;</span>&gt;&lt;/a&gt;10. Tables&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;&lt;p <span class="keyword">class</span>=<span class="stringliteral">&quot;releaseinfo&quot;</span>&gt;
<a name="l02065"></a>02065   $Id: 10-tables.xml 7186 2004-07-20 07:19:25Z xiphmont $
<a name="l02066"></a>02066  &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-spec-floor1_inverse_dB_table&quot;</span>&gt;&lt;/a&gt;10.1. floor1_inverse_dB_table&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02067"></a>02067 The vector &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;varname&quot;</span>&gt;[floor1_inverse_dB_table]&lt;/code&gt; is a 256 element <span class="keyword">static</span>
<a name="l02068"></a>02068 lookup table consiting of the following values (read left to right
<a name="l02069"></a>02069 then top to bottom):&lt;/p&gt;&lt;pre class=<span class="stringliteral">&quot;screen&quot;</span>&gt;
<a name="l02070"></a>02070   1.0649863e-07, 1.1341951e-07, 1.2079015e-07, 1.2863978e-07, 
<a name="l02071"></a>02071   1.3699951e-07, 1.4590251e-07, 1.5538408e-07, 1.6548181e-07, 
<a name="l02072"></a>02072   1.7623575e-07, 1.8768855e-07, 1.9988561e-07, 2.1287530e-07, 
<a name="l02073"></a>02073   2.2670913e-07, 2.4144197e-07, 2.5713223e-07, 2.7384213e-07, 
<a name="l02074"></a>02074   2.9163793e-07, 3.1059021e-07, 3.3077411e-07, 3.5226968e-07, 
<a name="l02075"></a>02075   3.7516214e-07, 3.9954229e-07, 4.2550680e-07, 4.5315863e-07, 
<a name="l02076"></a>02076   4.8260743e-07, 5.1396998e-07, 5.4737065e-07, 5.8294187e-07, 
<a name="l02077"></a>02077   6.2082472e-07, 6.6116941e-07, 7.0413592e-07, 7.4989464e-07, 
<a name="l02078"></a>02078   7.9862701e-07, 8.5052630e-07, 9.0579828e-07, 9.6466216e-07, 
<a name="l02079"></a>02079   1.0273513e-06, 1.0941144e-06, 1.1652161e-06, 1.2409384e-06, 
<a name="l02080"></a>02080   1.3215816e-06, 1.4074654e-06, 1.4989305e-06, 1.5963394e-06, 
<a name="l02081"></a>02081   1.7000785e-06, 1.8105592e-06, 1.9282195e-06, 2.0535261e-06, 
<a name="l02082"></a>02082   2.1869758e-06, 2.3290978e-06, 2.4804557e-06, 2.6416497e-06, 
<a name="l02083"></a>02083   2.8133190e-06, 2.9961443e-06, 3.1908506e-06, 3.3982101e-06, 
<a name="l02084"></a>02084   3.6190449e-06, 3.8542308e-06, 4.1047004e-06, 4.3714470e-06, 
<a name="l02085"></a>02085   4.6555282e-06, 4.9580707e-06, 5.2802740e-06, 5.6234160e-06, 
<a name="l02086"></a>02086   5.9888572e-06, 6.3780469e-06, 6.7925283e-06, 7.2339451e-06, 
<a name="l02087"></a>02087   7.7040476e-06, 8.2047000e-06, 8.7378876e-06, 9.3057248e-06, 
<a name="l02088"></a>02088   9.9104632e-06, 1.0554501e-05, 1.1240392e-05, 1.1970856e-05, 
<a name="l02089"></a>02089   1.2748789e-05, 1.3577278e-05, 1.4459606e-05, 1.5399272e-05, 
<a name="l02090"></a>02090   1.6400004e-05, 1.7465768e-05, 1.8600792e-05, 1.9809576e-05, 
<a name="l02091"></a>02091   2.1096914e-05, 2.2467911e-05, 2.3928002e-05, 2.5482978e-05, 
<a name="l02092"></a>02092   2.7139006e-05, 2.8902651e-05, 3.0780908e-05, 3.2781225e-05, 
<a name="l02093"></a>02093   3.4911534e-05, 3.7180282e-05, 3.9596466e-05, 4.2169667e-05, 
<a name="l02094"></a>02094   4.4910090e-05, 4.7828601e-05, 5.0936773e-05, 5.4246931e-05, 
<a name="l02095"></a>02095   5.7772202e-05, 6.1526565e-05, 6.5524908e-05, 6.9783085e-05, 
<a name="l02096"></a>02096   7.4317983e-05, 7.9147585e-05, 8.4291040e-05, 8.9768747e-05, 
<a name="l02097"></a>02097   9.5602426e-05, 0.00010181521, 0.00010843174, 0.00011547824, 
<a name="l02098"></a>02098   0.00012298267, 0.00013097477, 0.00013948625, 0.00014855085, 
<a name="l02099"></a>02099   0.00015820453, 0.00016848555, 0.00017943469, 0.00019109536, 
<a name="l02100"></a>02100   0.00020351382, 0.00021673929, 0.00023082423, 0.00024582449, 
<a name="l02101"></a>02101   0.00026179955, 0.00027881276, 0.00029693158, 0.00031622787, 
<a name="l02102"></a>02102   0.00033677814, 0.00035866388, 0.00038197188, 0.00040679456, 
<a name="l02103"></a>02103   0.00043323036, 0.00046138411, 0.00049136745, 0.00052329927, 
<a name="l02104"></a>02104   0.00055730621, 0.00059352311, 0.00063209358, 0.00067317058, 
<a name="l02105"></a>02105   0.00071691700, 0.00076350630, 0.00081312324, 0.00086596457, 
<a name="l02106"></a>02106   0.00092223983, 0.00098217216, 0.0010459992,  0.0011139742, 
<a name="l02107"></a>02107   0.0011863665,  0.0012634633,  0.0013455702,  0.0014330129, 
<a name="l02108"></a>02108   0.0015261382,  0.0016253153,  0.0017309374,  0.0018434235, 
<a name="l02109"></a>02109   0.0019632195,  0.0020908006,  0.0022266726,  0.0023713743, 
<a name="l02110"></a>02110   0.0025254795,  0.0026895994,  0.0028643847,  0.0030505286, 
<a name="l02111"></a>02111   0.0032487691,  0.0034598925,  0.0036847358,  0.0039241906, 
<a name="l02112"></a>02112   0.0041792066,  0.0044507950,  0.0047400328,  0.0050480668, 
<a name="l02113"></a>02113   0.0053761186,  0.0057254891,  0.0060975636,  0.0064938176, 
<a name="l02114"></a>02114   0.0069158225,  0.0073652516,  0.0078438871,  0.0083536271, 
<a name="l02115"></a>02115   0.0088964928,  0.009474637,   0.010090352,   0.010746080, 
<a name="l02116"></a>02116   0.011444421,   0.012188144,   0.012980198,   0.013823725, 
<a name="l02117"></a>02117   0.014722068,   0.015678791,   0.016697687,   0.017782797, 
<a name="l02118"></a>02118   0.018938423,   0.020169149,   0.021479854,   0.022875735, 
<a name="l02119"></a>02119   0.024362330,   0.025945531,   0.027631618,   0.029427276, 
<a name="l02120"></a>02120   0.031339626,   0.033376252,   0.035545228,   0.037855157, 
<a name="l02121"></a>02121   0.040315199,   0.042935108,   0.045725273,   0.048696758, 
<a name="l02122"></a>02122   0.051861348,   0.055231591,   0.058820850,   0.062643361, 
<a name="l02123"></a>02123   0.066714279,   0.071049749,   0.075666962,   0.080584227, 
<a name="l02124"></a>02124   0.085821044,   0.091398179,   0.097337747,   0.10366330, 
<a name="l02125"></a>02125   0.11039993,    0.11757434,    0.12521498,    0.13335215, 
<a name="l02126"></a>02126   0.14201813,    0.15124727,    0.16107617,    0.17154380, 
<a name="l02127"></a>02127   0.18269168,    0.19456402,    0.20720788,    0.22067342, 
<a name="l02128"></a>02128   0.23501402,    0.25028656,    0.26655159,    0.28387361, 
<a name="l02129"></a>02129   0.30232132,    0.32196786,    0.34289114,    0.36517414, 
<a name="l02130"></a>02130   0.38890521,    0.41417847,    0.44109412,    0.46975890, 
<a name="l02131"></a>02131   0.50028648,    0.53279791,    0.56742212,    0.60429640, 
<a name="l02132"></a>02132   0.64356699,    0.68538959,    0.72993007,    0.77736504, 
<a name="l02133"></a>02133   0.82788260,    0.88168307,    0.9389798,     1.
<a name="l02134"></a>02134 &lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=<span class="stringliteral">&quot;appendix&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;h2 class=<span class="stringliteral">&quot;title&quot;</span> style=<span class="stringliteral">&quot;clear: both&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;vorbis-over-ogg&quot;</span>&gt;&lt;/a&gt;A. Embedding Vorbis into an Ogg stream&lt;/h2&gt;&lt;div class=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div class=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h3 class=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2520211&quot;</span>&gt;&lt;/a&gt;A.1. Overview&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02135"></a>02135 This document describes using Ogg logical and physical transport
<a name="l02136"></a>02136 streams to encapsulate Vorbis compressed audio packet data into file
<a name="l02137"></a>02137 form.&lt;/p&gt;&lt;p&gt;
<a name="l02138"></a>02138 The &lt;a href=<span class="stringliteral">&quot;#vorbis-spec-intro&quot;</span> title=<span class="stringliteral">&quot;1. Introduction and Description&quot;</span>&gt;Section 1, &amp;#8220;Introduction and Description&amp;#8221;&lt;/a&gt; provides an overview of the construction
<a name="l02139"></a>02139 of Vorbis audio packets.&lt;/p&gt;&lt;p&gt;
<a name="l02140"></a>02140 The &lt;a href=<span class="stringliteral">&quot;oggstream.html&quot;</span> target=<span class="stringliteral">&quot;_top&quot;</span>&gt;Ogg
<a name="l02141"></a>02141 bitstream overview&lt;/a&gt; and &lt;a href=<span class="stringliteral">&quot;framing.html&quot;</span> target=<span class="stringliteral">&quot;_top&quot;</span>&gt;Ogg logical
<a name="l02142"></a>02142 bitstream and framing spec&lt;/a&gt; provide detailed descriptions of Ogg
<a name="l02143"></a>02143 transport streams. This specification document assumes a working
<a name="l02144"></a>02144 knowledge of the concepts covered in these named backround
<a name="l02145"></a>02145 documents.  Please read them first.&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2530380&quot;</span>&gt;&lt;/a&gt;A.1.1. Restrictions&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02146"></a>02146 The Ogg/Vorbis I specification currently dictates that Ogg/Vorbis
<a name="l02147"></a>02147 streams use Ogg transport streams in degenerate, unmultiplexed
<a name="l02148"></a>02148 form only. That is:
<a name="l02149"></a>02149 
<a name="l02150"></a>02150 &lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;itemizedlist&quot;</span>&gt;&lt;ul type=<span class="stringliteral">&quot;disc&quot;</span>&gt;&lt;li&gt;
<a name="l02151"></a>02151   A meta-headerless Ogg file encapsulates the Vorbis I packets
<a name="l02152"></a>02152  &lt;/li&gt;&lt;li&gt;
<a name="l02153"></a>02153   The Ogg stream may be chained, i.e. contain multiple, contigous logical streams (links).
<a name="l02154"></a>02154  &lt;/li&gt;&lt;li&gt;
<a name="l02155"></a>02155   The Ogg stream must be unmultiplexed (only one stream, a Vorbis audio stream, per link)
<a name="l02156"></a>02156  &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02157"></a>02157 &lt;/p&gt;&lt;p&gt;
<a name="l02158"></a>02158 This is not to say that it is not currently possible to multiplex
<a name="l02159"></a>02159 Vorbis with other media types into a multi-stream Ogg file.  At the
<a name="l02160"></a>02160 time <span class="keyword">this</span> document was written, Ogg was becoming a popular container
<a name="l02161"></a>02161 <span class="keywordflow">for</span> low-bitrate movies consisting of DiVX video and Vorbis audio.
<a name="l02162"></a>02162 However, a <span class="stringliteral">&#39;Vorbis I audio file&#39;</span> is taken to imply Vorbis audio
<a name="l02163"></a>02163 existing alone within a degenerate Ogg stream.  A compliant <span class="stringliteral">&#39;Vorbis</span>
<a name="l02164"></a>02164 <span class="stringliteral">audio player&#39;</span> is not required to implement Ogg support beyond the
<a name="l02165"></a>02165 specific support of Vorbis within a degenrate ogg stream (naturally,
<a name="l02166"></a>02166 application authors are encouraged to support full multiplexed Ogg
<a name="l02167"></a>02167 handling).
<a name="l02168"></a>02168 &lt;/p&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h4 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2512176&quot;</span>&gt;&lt;/a&gt;A.1.2. MIME type&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02169"></a>02169 The correct MIME type of any Ogg file is &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;literal&quot;</span>&gt;application/ogg&lt;/code&gt;.
<a name="l02170"></a>02170 However, <span class="keywordflow">if</span> a file is a Vorbis I audio file (which implies a
<a name="l02171"></a>02171 degenerate Ogg stream including only unmultiplexed Vorbis audio), the
<a name="l02172"></a>02172 mime type &lt;code <span class="keyword">class</span>=<span class="stringliteral">&quot;literal&quot;</span>&gt;audio/x-vorbis&lt;/code&gt; is also allowed.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;section&quot;</span> lang=<span class="stringliteral">&quot;en&quot;</span>&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;titlepage&quot;</span>&gt;&lt;div&gt;&lt;div&gt;&lt;h3 <span class="keyword">class</span>=<span class="stringliteral">&quot;title&quot;</span>&gt;&lt;a name=<span class="stringliteral">&quot;id2520628&quot;</span>&gt;&lt;/a&gt;A.2. Encapsulation&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;
<a name="l02173"></a>02173 Ogg encapsulation of a Vorbis packet stream is straightforward.&lt;/p&gt;&lt;div <span class="keyword">class</span>=<span class="stringliteral">&quot;itemizedlist&quot;</span>&gt;&lt;ul type=<span class="stringliteral">&quot;disc&quot;</span>&gt;&lt;li&gt;
<a name="l02174"></a>02174   The first Vorbis packet (the identification header), which
<a name="l02175"></a>02175   uniquely identifies a stream as Vorbis audio, is placed alone in the
<a name="l02176"></a>02176   first page of the logical Ogg stream.  This results in a first Ogg
<a name="l02177"></a>02177   page of exactly 58 bytes at the very beginning of the logical stream.
<a name="l02178"></a>02178 &lt;/li&gt;&lt;li&gt;
<a name="l02179"></a>02179   This first page is marked <span class="stringliteral">&#39;beginning of stream&#39;</span> in the page flags.
<a name="l02180"></a>02180 &lt;/li&gt;&lt;li&gt;
<a name="l02181"></a>02181   The second and third vorbis packets (comment and setup
<a name="l02182"></a>02182   headers) may span one or more pages beginning on the second page of
<a name="l02183"></a>02183   the logical stream.  However many pages they span, the third header
<a name="l02184"></a>02184   packet finishes the page on which it ends.  The next (first audio) packet
<a name="l02185"></a>02185   must begin on a fresh page.
<a name="l02186"></a>02186 &lt;/li&gt;&lt;li&gt;
<a name="l02187"></a>02187   The granule position of these first pages containing only headers is zero.
<a name="l02188"></a>02188 &lt;/li&gt;&lt;li&gt;
<a name="l02189"></a>02189   The first audio packet of the logical stream begins a fresh Ogg page.
<a name="l02190"></a>02190 &lt;/li&gt;&lt;li&gt;
<a name="l02191"></a>02191   Packets are placed into ogg pages in order until the end of stream.
<a name="l02192"></a>02192 &lt;/li&gt;&lt;li&gt;
<a name="l02193"></a>02193   The last page is marked <span class="stringliteral">&#39;end of stream&#39;</span> in the page flags.
<a name="l02194"></a>02194 &lt;/li&gt;&lt;li&gt;
<a name="l02195"></a>02195   Vorbis packets may span page boundaries.
<a name="l02196"></a>02196 &lt;/li&gt;&lt;li&gt;
<a name="l02197"></a>02197   The granule position of pages containing Vorbis audio is in units
<a name="l02198"></a>02198   of PCM audio samples (per channel; a stereo stream<span class="stringliteral">&#39;s granule position</span>
<a name="l02199"></a>02199 <span class="stringliteral">  does not increment at twice the speed of a mono stream).</span>
<a name="l02200"></a>02200 <span class="stringliteral">&lt;/li&gt;&lt;li&gt;</span>
<a name="l02201"></a>02201 <span class="stringliteral">  The granule position of a page represents the end PCM sample</span>
<a name="l02202"></a>02202 <span class="stringliteral">  position of the last packet &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;completed&lt;/em&gt;&lt;/span&gt; on that page.</span>
<a name="l02203"></a>02203 <span class="stringliteral">  A page that is entirely spanned by a single packet (that completes on a</span>
<a name="l02204"></a>02204 <span class="stringliteral">  subsequent page) has no granule position, and the granule position is</span>
<a name="l02205"></a>02205 <span class="stringliteral">  set to &#39;</span>-1<span class="stringliteral">&#39;.</span>
<a name="l02206"></a>02206 <span class="stringliteral">&lt;/li&gt;&lt;li&gt;&lt;p&gt;</span>
<a name="l02207"></a>02207 <span class="stringliteral">    The granule (PCM) position of the first page need not indicate</span>
<a name="l02208"></a>02208 <span class="stringliteral">    that the stream started at position zero.  Although the granule</span>
<a name="l02209"></a>02209 <span class="stringliteral">    position belongs to the last completed packet on the page and a </span>
<a name="l02210"></a>02210 <span class="stringliteral">    valid granule position must be positive, by</span>
<a name="l02211"></a>02211 <span class="stringliteral">    inference it may indicate that the PCM position of the beginning</span>
<a name="l02212"></a>02212 <span class="stringliteral">    of audio is positive or negative.</span>
<a name="l02213"></a>02213 <span class="stringliteral">  &lt;/p&gt;&lt;div class=&quot;itemizedlist&quot;&gt;&lt;ul type=&quot;circle&quot;&gt;&lt;li&gt;</span>
<a name="l02214"></a>02214 <span class="stringliteral">        A positive starting value simply indicates that this stream begins at</span>
<a name="l02215"></a>02215 <span class="stringliteral">        some positive time offset, potentially within a larger</span>
<a name="l02216"></a>02216 <span class="stringliteral">        program. This is a common case when connecting to the middle</span>
<a name="l02217"></a>02217 <span class="stringliteral">        of broadcast stream.</span>
<a name="l02218"></a>02218 <span class="stringliteral">    &lt;/li&gt;&lt;li&gt;</span>
<a name="l02219"></a>02219 <span class="stringliteral">        A negative value indicates that</span>
<a name="l02220"></a>02220 <span class="stringliteral">        output samples preceeding time zero should be discarded during</span>
<a name="l02221"></a>02221 <span class="stringliteral">        decoding; this technique is used to allow sample-granularity</span>
<a name="l02222"></a>02222 <span class="stringliteral">        editing of the stream start time of already-encoded Vorbis</span>
<a name="l02223"></a>02223 <span class="stringliteral">        streams.  The number of samples to be discarded must not exceed </span>
<a name="l02224"></a>02224 <span class="stringliteral">        the overlap-add span of the first two audio packets.</span>
<a name="l02225"></a>02225 <span class="stringliteral">    &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l02226"></a>02226 <span class="stringliteral">    In both of these cases in which the initial audio PCM starting</span>
<a name="l02227"></a>02227 <span class="stringliteral">    offset is nonzero, the second finished audio packet must flush the</span>
<a name="l02228"></a>02228 <span class="stringliteral">    page on which it appears and the third packet begin a fresh page.</span>
<a name="l02229"></a>02229 <span class="stringliteral">    This allows the decoder to always be able to perform PCM position</span>
<a name="l02230"></a>02230 <span class="stringliteral">    adjustments before needing to return any PCM data from synthesis, </span>
<a name="l02231"></a>02231 <span class="stringliteral">    resulting in correct positioning information without any aditional</span>
<a name="l02232"></a>02232 <span class="stringliteral">    seeking logic.</span>
<a name="l02233"></a>02233 <span class="stringliteral">  &lt;/p&gt;&lt;div class=&quot;note&quot; style=&quot;margin-left: 0.5in; margin-right: 0.5in;&quot;&gt;&lt;h3 class=&quot;title&quot;&gt;Note&lt;/h3&gt;&lt;p&gt;</span>
<a name="l02234"></a>02234 <span class="stringliteral">    Failure to do so should, at worst, cause a</span>
<a name="l02235"></a>02235 <span class="stringliteral">    decoder implementation to return incorrect positioning information</span>
<a name="l02236"></a>02236 <span class="stringliteral">    for seeking operations at the very beginning of the stream.</span>
<a name="l02237"></a>02237 <span class="stringliteral">  &lt;/p&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;</span>
<a name="l02238"></a>02238 <span class="stringliteral">  A granule position on the final page in a stream that indicates</span>
<a name="l02239"></a>02239 <span class="stringliteral">  less audio data than the final packet would normally return is used to</span>
<a name="l02240"></a>02240 <span class="stringliteral">  end the stream on other than even frame boundaries.  The difference</span>
<a name="l02241"></a>02241 <span class="stringliteral">  between the actual available data returned and the declared amount</span>
<a name="l02242"></a>02242 <span class="stringliteral">  indicates how many trailing samples to discard from the decoding</span>
<a name="l02243"></a>02243 <span class="stringliteral">  process.</span>
<a name="l02244"></a>02244 <span class="stringliteral"> &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;appendix&quot; lang=&quot;en&quot;&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;vorbis-over-rtp&quot;&gt;&lt;/a&gt;B. Vorbis encapsulation in RTP&lt;/h2&gt;&lt;pre class=&quot;literallayout&quot;&gt;</span>
<a name="l02245"></a>02245 <span class="stringliteral"></span>
<a name="l02246"></a>02246 <span class="stringliteral"></span>
<a name="l02247"></a>02247 <span class="stringliteral"></span>
<a name="l02248"></a>02248 <span class="stringliteral">    &lt;p&gt;Please consult the internet draft &lt;em class=&quot;citetitle&quot;&gt;RTP Payload Format for Vorbis Encoded</span>
<a name="l02249"></a>02249 <span class="stringliteral">    Audio&lt;/em&gt; for description of how to embed Vorbis audio in an RTP stream.&lt;/p&gt;</span>
<a name="l02250"></a>02250 <span class="stringliteral">  </span>
<a name="l02251"></a>02251 <span class="stringliteral">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;appendix&quot; lang=&quot;en&quot;&gt;&lt;h2 class=&quot;title&quot; style=&quot;clear: both&quot;&gt;&lt;a name=&quot;footer&quot;&gt;&lt;/a&gt;C. Colophon&lt;/h2&gt;&lt;div class=&quot;mediaobject&quot;&gt;&lt;img src=&quot;white-xifish.png&quot; alt=&quot;[Xiph.org logo]&quot;&gt;&lt;/div&gt;&lt;p&gt;</span>
<a name="l02252"></a>02252 <span class="stringliteral">Ogg is a &lt;a href=&quot;http://www.xiph.org/&quot; target=&quot;_top&quot;&gt;Xiph.org Foundation&lt;/a&gt; effort</span>
<a name="l02253"></a>02253 <span class="stringliteral">to protect essential tenets of Internet multimedia from corporate</span>
<a name="l02254"></a>02254 <span class="stringliteral">hostage-taking; Open Source is the net&#39;</span>s greatest tool to keep
<a name="l02255"></a>02255 everyone honest. See &lt;a href=<span class="stringliteral">&quot;http://www.xiph.org/about.html&quot;</span> target=<span class="stringliteral">&quot;_top&quot;</span>&gt;About
<a name="l02256"></a>02256 the Xiph.org Foundation&lt;/a&gt; <span class="keywordflow">for</span> details.
<a name="l02257"></a>02257 &lt;/p&gt;&lt;p&gt;
<a name="l02258"></a>02258 Ogg Vorbis is the first Ogg audio CODEC.  Anyone may freely use and
<a name="l02259"></a>02259 distribute the Ogg and Vorbis specification, whether in a <span class="keyword">private</span>,
<a name="l02260"></a>02260 <span class="keyword">public</span> or corporate capacity.  However, the Xiph.org Foundation and
<a name="l02261"></a>02261 the Ogg project (xiph.org) reserve the right to set the Ogg Vorbis
<a name="l02262"></a>02262 specification and certify specification compliance.&lt;/p&gt;&lt;p&gt;
<a name="l02263"></a>02263 Xiph.org&#39;s Vorbis software CODEC implementation is distributed under a
<a name="l02264"></a>02264 BSD-like license.  This does not restrict third parties from
<a name="l02265"></a>02265 distributing independent implementations of Vorbis software under
<a name="l02266"></a>02266 other licenses.&lt;/p&gt;&lt;p&gt;
<a name="l02267"></a>02267 Ogg, Vorbis, Xiph.org Foundation and their logos are trademarks (tm)
<a name="l02268"></a>02268 of the &lt;a href=&quot;http:<span class="comment">//www.xiph.org/&quot; target=&quot;_top&quot;&gt;Xiph.org Foundation&lt;/a&gt;.  These</span>
<a name="l02269"></a>02269 pages are copyright (C) 1994-2004 Xiph.org Foundation. All rights
<a name="l02270"></a>02270 reserved.&lt;/p&gt;&lt;p&gt;
<a name="l02271"></a>02271 This document is set in DocBook XML.
<a name="l02272"></a>02272 &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/s3/guid-6013a680-57f9-415b-8851-c4fa63356636/_vorbis___i__spec_8html_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:31 GMT -->
</html>
