
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-AA2A730E-A7C9-5647-AD42-11C3BAF4C38D.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:59:26 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Filters" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-C0D38954-2FC5-4E8B-BC11-229464DCF16C" /><meta name="DC.Relation" scheme="URI" content="GUID-1E8904E3-43AC-5332-A2EF-F11F5728DBE8" /><meta name="DC.Relation" scheme="URI" content="GUID-B4A54501-4AA4-5ACB-96D7-4427C7752639" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-AA2A730E-A7C9-5647-AD42-11C3BAF4C38D" /><meta name="DC.Language" content="en" /><title>Filters </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-AA2A730E-A7C9-5647-AD42-11C3BAF4C38D">Filters</h1><div><p>A filter is used to alter a transaction moving to or from the server. Behaviours can be implemented in filters to modify transactions, for example, change headers, add headers, and remove headers. The transaction body can also be changed to terminate or cancel a transaction, either to resubmit a replacement, or perform other operations on the client device using information from transaction headers or body. </p> <p>HTTP filters can be loaded explicitly (by the client) or implicitly. The way the filter is loaded is dependent on the <code class="codeph">default_data</code> setting in the <em>IMPLEMENTATION_INFO</em> section of the filter's resource file. The options are: </p> <ul><li id="GUID-1802931A-BEEB-5D0C-A512-AE884DA30D56"><a name="GUID-1802931A-BEEB-5D0C-A512-AE884DA30D56"><!-- --></a><p> <code class="codeph">HTTP/+FILTERNAME</code>: The filter is always loaded </p> </li> <li id="GUID-D9096021-077B-53A3-AFB3-D4F72428246D"><a name="GUID-D9096021-077B-53A3-AFB3-D4F72428246D"><!-- --></a><p> <code class="codeph">HTTP/FILTERNAME</code>: The filter is loaded unless the client removes it </p> </li> <li id="GUID-CFF97C97-8500-551A-80E8-81CE73999E01"><a name="GUID-CFF97C97-8500-551A-80E8-81CE73999E01"><!-- --></a><p> <code class="codeph">HTTP/-FILTERNAME</code>: The filter is not loaded unless the client adds it </p> </li> </ul> <p>In the preceding options, <code class="codeph">FILTERNAME</code> is the name of your filter. </p> <p>An <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html"><code class="apiname">RHTTPSession</code></a> contains a queue that can hold zero or more filters, which are arranged in a priority order. The filter objects are shared amongst all transactions. To join the filter queue, a filter must be registered on the session, providing registration details that specify its triggers. </p> <p>Filter triggers include: particular events, the presence of particular headers, or particular status codes. </p> <p>When an event occurs on a transaction, the event traverses the filter queue either from the client to the server, or from the server back to the client. Priority order determines which filters are visited first when events traverse away from the client (that is, events that originate from the client such as <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-518CC5C3-1CE1-316E-9688-93DB12E58EB3.html#GUID-8E201ED0-7AC9-37D4-A5CD-E26C81A72CC1"><code class="apiname">THTTPEvent::ESubmit</code></a>, which is sent when <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E673024-239B-3965-8880-C47B7CC24EF6.html#GUID-F3A8B916-5618-319D-89D8-9B7B04A8A2FC"><code class="apiname">RHTTPTransaction::SubmitL()</code></a> is called). Reverse priority order applies to events that traverse back towards the client (that is, those that originate from the server, such as <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-518CC5C3-1CE1-316E-9688-93DB12E58EB3.html#GUID-0056851B-2933-3701-BFE2-E28162F4EE5B"><code class="apiname">THTTPEvent::EResponseComplete</code></a>). </p> <div><h3 class="section-title">Adding, removing and querying filters</h3> <p>When an <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html"><code class="apiname">RHTTPSession</code></a> is opened, a standard set of filters is pre-installed. The client does not need to do anything further if these filters are acceptable. The standard set includes: </p> <ul><li id="GUID-7315BBF2-709E-5F18-85D5-9597F340DE21"><a name="GUID-7315BBF2-709E-5F18-85D5-9597F340DE21"><!-- --></a><p>Redirection filter </p> </li> <li id="GUID-6110EFD0-D9B2-5328-9CE5-BD0A8729D87B"><a name="GUID-6110EFD0-D9B2-5328-9CE5-BD0A8729D87B"><!-- --></a><p>Validation filter </p> </li> </ul> <p>The client may add more filters of its own, or remove filters from the pre-installed set. <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-1B7541CC-9B0B-361C-9BF0-64C027DB6745.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-1B7541CC-9B0B-361C-9BF0-64C027DB6745.html"><code class="apiname">RHTTPFilterCollection</code></a>, for which a handle is obtained using <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html#GUID-E1775A83-8494-3B3F-8DFA-57F4FB64F35A"><code class="apiname">RHTTPSession::FilterCollection()</code></a>, provides facilities for adding and deleting filters, and for querying what filters are installed. <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2495D233-106D-3223-A84B-2C04EEB1E98F.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2495D233-106D-3223-A84B-2C04EEB1E98F.html"><code class="apiname">TFilterConfigurationIterator</code></a> allows a client to enumerate and query all available filters, and to install and uninstall a selected one. </p> <p>Filters may only be added to, or removed from, a session when no transactions are opened on that session. This is easy to determine immediately when a session is opened. To help the client in determining the condition later, <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-1B7541CC-9B0B-361C-9BF0-64C027DB6745.html#GUID-C9809478-62A4-37EF-B582-9128DDEA4812"><code class="apiname">RHTTPFilterCollection::CanChangeFilters()</code></a> is provided. </p> <p>The collection of currently installed filters can be queried using an iterator. The following sample code demonstrates the use of the iterator: </p> <pre class="codeblock">void CHttpClient::ShowFilters()
    {
    RHTTPFilterCollection filtColl = iSess.FilterCollection();
    THTTPFilterIterator iter = filtColl.Query();

    THTTPFilterRegistration regInfo;
    iter.First();
    TInt lines = 0;
    while (!iter.AtEnd())
        {
        // Get next filter registration info
        regInfo = iter();

        TBuf&lt;KMaxFilterNameLength&gt; name;
        name.Copy(iSess.StringPool().StringF(regInfo.iName).DesC().Left(KMaxFilterNameLength));
        TBuf&lt;KMaxHeaderNameLength&gt; header;
        header.Copy(iSess.StringPool().StringF(regInfo.iHeader).DesC().Left(KMaxHeaderNameLength));

        Printf(_L("\n%16S | %4d  | %4d   | %16S |   %3d  | %2d"),
        &amp;name, regInfo.iPosition, regInfo.iEvent.iStatus, &amp;header, regInfo.iStatus, regInfo.iHandle);
        ++iter;
        }
    filtColl.Close();
    }</pre> </div> <div><h3 class="section-title">Authentication filter</h3> <p>The authentication filter provides an easy way of supporting basic and digest authentication, as defined in RFC2617. As it needs to get passwords, it is not installed as standard, but only when a <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html"><code class="apiname">MHTTPAuthenticationCallback</code></a> installs it. To use it, you need to implement a subclass of <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html"><code class="apiname">MHTTPAuthenticationCallback</code></a>, and should refer to the documentation of that class for more details. </p> <p>Users of HTTP authentication should be aware of its security limitations. In particular, basic authentication passes passwords in plaintext. <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-1B96E431-2572-30D2-AEFD-E1460C477A93"><code class="apiname">MHTTPAuthenticationCallback::GetCredentialsL()</code></a> is told the authentication scheme being used, and applications where plaintext passwords would be an issue must consider rejecting challenges using basic authentication. See section 4 of RFC2617 for more details. </p> <p>The authentication filter supports the following: </p> <ul><li id="GUID-B330D7E7-98A5-5185-9DFF-9826FC2B8668"><a name="GUID-B330D7E7-98A5-5185-9DFF-9826FC2B8668"><!-- --></a><p>Basic (Base64) authentication </p> </li> <li id="GUID-D882595D-FB59-5895-B8FF-B1F836EA6A39"><a name="GUID-D882595D-FB59-5895-B8FF-B1F836EA6A39"><!-- --></a><p>Digest authentication using the MD5 algorithm and the 'auth' Quality of Protection. </p> </li> <li id="GUID-D17C8599-6052-5F84-B1B1-5991CF864318"><a name="GUID-D17C8599-6052-5F84-B1B1-5991CF864318"><!-- --></a><p>The older RFC2069 style digest authentication for backwards compatibility. </p> </li> </ul> <p>The MD5-sess algorithm is not supported as no major servers support it. The 'auth-int' QoP (Quality of Protection) is not supported as it does not add any real benefit. For integrity checking, SSL is preferred. </p> <p>The filter remembers passwords and attempts to use them for subsequent challenges where appropriate. It will forget them if they turn out to be wrong. Currently, there is no facility to persist the passwords. For basic authentication, an attempt is made to supply the username and password with the first request, if the URI suggests that a previously stored username and password are applicable. This is not done for digest, as that introduces extra complications into the digest algorithm. </p> <p>If an authentication challenge is received which the filter cannot understand, or if the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html"><code class="apiname">MHTTPAuthenticationCallback</code></a> does not supply credentials (returns <code class="codeph">EFalse</code>) the filter effectively does nothing, that is, the client will receive a 401 error response in the same way as other error responses. </p> <p>There are two alternative methods of supplying the username and password with a request. Clients that already know the username and password can consider using these methods and getting their <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-1B96E431-2572-30D2-AEFD-E1460C477A93"><code class="apiname">MHTTPAuthenticationCallback::GetCredentialsL()</code></a> to always return <code class="codeph">EFalse</code>. The first method is to supply a URI of the form <code class="codeph">http://&lt;username&gt;:&lt;password&gt;@host/</code>. In this case, the username and the password are removed from the URI when it is submitted, but will be used for any subsequent authentication challenge. The other method is to define transaction properties called 'username' and 'password' containing the username and password. </p> <p>The filter is registered at position <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E1C08E2-9024-3269-A1BD-C6B901E78841.html#GUID-CD1FDCD5-57B8-3888-8753-55A1F9F31466"><code class="apiname">MHTTPFilter::EStatusCodeHandler</code></a> for handling the '401' return code, and at position <code class="codeph">EStatusCodeHandler</code> + 1 for handling submit events. </p> </div> <div><h3 class="section-title">Redirection filter</h3> <p>The Redirection filter handles 300-series status codes from HTTP servers. These are used to tell the client of the correct location of a resource that has moved. Most clients will want this situation to be handled transparently: that is, to make a new request for the resource at the location specified by the server using the 'Location' header. </p> <p>When an HTTP response is received that includes the status codes 300, 301, 302, 303, or 307, the Redirection filter cancels the current transaction and uses the URI from the 'Location' response header to resubmit a request on the same transaction. This means that all the headers in the original client request are preserved in the new request. </p> <p>If no 'Location' header is found in the server response, the filter sends a KErrHttpRedirectNoLocationField error to the client. The response body can contain further information about the possible location of the resource. </p> <p>In the case of the HTTP 305 'Use Proxy' status code, the transaction is not resubmitted. Instead, a KErrHttpRedirectUseProxy error is sent to the client. The 'Location' header will contain the address of a proxy to which the client must send the request for that URL. In practice, this means the client should modify the properties of their current <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-651801A5-5473-3856-9647-46823598C5C1.html"><code class="apiname">RHTTPSession</code></a> as described in <a href="GUID-F9184A82-A467-5022-B02F-2FDF52258618.html">Session and transaction properties</a>. </p> <p>HTTP 304 'Not Modified' responses are not handled by the redirection filter as they are used to indicate that the client contains a valid copy of the resource in the cache. </p> <p>It is possible for the client request to be redirected more than once. To prevent the request getting into an endless loop of redirections, successive redirections that the filter will handle is limited to five. </p> </div> <div id="GUID-8DB0C8B3-4ED6-59D6-A796-F4EA2DE5DC5B"><h3 class="section-title">Validation filter</h3> <p>The Validation filter has three main roles: </p> <ul><li id="GUID-8B074A32-E937-5179-9DC1-3DE0B89A055A"><a name="GUID-8B074A32-E937-5179-9DC1-3DE0B89A055A"><!-- --></a><p>It checks the presence of a request body to ensure that it is consistent with the HTTP method in use. </p> </li> <li id="GUID-79346A52-732A-5D1D-8AB0-3B58A9C932B9"><a name="GUID-79346A52-732A-5D1D-8AB0-3B58A9C932B9"><!-- --></a><p>It validates client requests to ensure that they do not include inappropriate header fields. </p> </li> <li id="GUID-71D96A1F-29EB-5D3E-AF2A-5607A9C7DBF6"><a name="GUID-71D96A1F-29EB-5D3E-AF2A-5607A9C7DBF6"><!-- --></a><p>It provides a simplified result status for transactions. </p> </li> </ul> <p>Request bodies are only allowed for HTTP methods POST and PUT. If GET, HEAD, or TRACE requests contain a body, the filter will cancel the transaction and send a KErrHttpRequestHasBody error event to the client. </p> <p>If the request headers contain any fields that are defined by RFC 2616 as response header fields, then the error event KErrHttpInvalidHeaderInRequest is sent to the client. Invalid fields are removed, and the transaction is allowed to continue. </p> <p>If the request does not have a body, and the request headers contain any fields that are defined by RFC 2616 as entity header fields, then KErrHttpInvalidHeaderInRequest is sent to the client, the fields are removed, and the transaction continues. </p> <p>If the request has a body, and the 'Content-Type' header is not present in the request headers, then the transaction will be cancelled and the KErrHttpEntityHeaderMissingContentType error event is sent to the client. </p> <p>See also <a href="GUID-F6CF2920-9095-568B-B332-D5F4A05BD23A.html">Headers</a> and the header enumerations in HTTP for further information about different header types. </p> <p>When a transaction response is received, the validation filter will determine from the status code if the transaction has been a success or a failure. The two events <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-518CC5C3-1CE1-316E-9688-93DB12E58EB3.html#GUID-619AC671-5679-3036-82C9-DAAF5B892100"><code class="apiname">THTTPEvent::ESucceeded</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-518CC5C3-1CE1-316E-9688-93DB12E58EB3.html#GUID-6BC33448-9CB9-3488-87DD-EFB0C5435044"><code class="apiname">THTTPEvent::EFailed</code></a> are used to inform the client of this. The client can assume that no further events for that transaction will arrive after it has received either of these two events. </p> </div> <div><h3 class="section-title">Configuring and installing filters</h3> <p>Apart from the standard set of filters, the client must manually install any other filter it wishes to use. Some filters may need to be configured before they can be installed; this should be done when the filter is instantiated. </p> <p>An example of where filter configuration is needed is the authentication filter, which requires a callback to gather user credentials from the client. The client must implement the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-4818EAC3-BE59-3438-A864-E4746FE8DDBC.html"><code class="apiname">MHTTPAuthenticationCallback</code></a> class, and at the time it opens an HTTP session must specify the object that implements the callback to configure the filter. </p> <p>From <code>httpexampleclient.h</code>: </p> <pre class="codeblock">class CHttpClient : public CBase, public MHTTPDataSupplier, 
                    public MHTTPAuthenticationCallback
    {
public:
    ...
    // methods inherited from MHTTPAuthenticationCallback
    virtual TBool GetCredentialsL(const TUriC8&amp; aURI, RString aRealm, 
                                 RStringF aAuthenticationType,
                                 RString&amp; aUsername, 
                                 RString&amp; aPassword);
    ...</pre> <p>From <code>httpexampleclient.cpp</code>: </p> <pre class="codeblock">void CHttpClient::ConstructL()
    {
    ...

    // Open the RHTTPSession and install this class as the callback for authentication requests
    iSess.OpenL();
    InstallAuthenticationL(iSess);
    ...
    }</pre> <p>In this case, <code>MHTTPAuthenticationCallback::InstallAuthenticationL()</code> is already implemented in the library. It creates and installs the filter on the client's behalf: </p> <pre class="codeblock">void MHTTPAuthenticationCallback::InstallAuthenticationL(RHTTPSession aSession)
    {
    // Create an authentication filter. This will install itself, and
    // will delete itself when uninstalled, so we don't need to keep
    // track of it at all.
    CAuthenticationFilter::NewL(*this, aSession);
    }</pre> <p>However in other cases, the client may have to construct the filter itself and configure it, before installing it on the session, for example: </p> <pre class="codeblock">void CAuthenticationFilter::ConstructL(RHTTPSession aSession)
    {
    ...
    // Register for WWW-Authenticate headers and 401 status codes
    aSession.FilterCollection().AddFilterL(*this, 
        THTTPEvent::EGotResponseHeaders, 
        iStringPool.StringF(HTTP::EWWWAuthenticate,RHTTPSession::GetTable()), 
        401, 
        EStatusCodeHandler, 
        iStringPool.StringF(HTTP::EAuthentication,RHTTPSession::GetTable()));
    ...
}</pre> </div> <div><h3 class="section-title">Writing a filter</h3> <p>This section provides an overview of writing filters. Refer to the functions mentioned for more details. </p> <p>Filters need to derive from the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E1C08E2-9024-3269-A1BD-C6B901E78841.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E1C08E2-9024-3269-A1BD-C6B901E78841.html"><code class="apiname">MHTTPFilter</code></a> class. Normally, the constructor or <code class="codeph">NewL()</code> of a filter would take a session as a parameter, and would then register itself by calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-1B7541CC-9B0B-361C-9BF0-64C027DB6745.html#GUID-B4659DF8-C5DD-30DC-AFF8-D4F22D540386"><code class="apiname">RHTTPFilterCollection::AddFilterL()</code></a>. </p> <p>Filters can often delete themselves automatically. If a filter only registers itself once, it can delete itself simply by overriding <code class="codeph">MHFUnload()</code> and <code class="codeph">delete this</code> in it. If you register several times, it is probably easiest to overload both <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E1C08E2-9024-3269-A1BD-C6B901E78841.html#GUID-CFFDC252-CC6F-30F3-87A6-5F1398D5C3CD"><code class="apiname">MHTTPFilter::MHFLoad()</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E1C08E2-9024-3269-A1BD-C6B901E78841.html#GUID-33452FD8-4AB4-32F8-BD98-0FC9B7E46717"><code class="apiname">MHTTPFilter::MHFUnload()</code></a>, increment a reference count in <code class="codeph">MHFLoad()</code>, decrement it in <code class="codeph">MHTTPFilter::MHFUnload()</code> and when it reaches zero, <code class="codeph">delete this</code>. </p> <p>A filter is notified of events through <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-57216A14-97B8-324C-BB00-63CA880CC779.html#GUID-50C6321D-AFEF-3B0F-84DD-5AE0E70274C4"><code class="apiname">MHTTPFilterBase::MHFRunL()</code></a>, similar to client notification. If the <code class="codeph">MHFRunL()</code> implementation leaves, the filter must handle the error in <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-57216A14-97B8-324C-BB00-63CA880CC779.html#GUID-4ED494E3-6499-3C89-A35A-A672A24FA849"><code class="apiname">MHTTPFilterBase::MHFRunError()</code></a>. There is a potential problem there, in that you may well want to tell the client that something has gone wrong by <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E673024-239B-3965-8880-C47B7CC24EF6.html#GUID-7F9EAF08-316A-3641-B145-10534D72A9FB"><code class="apiname">RHTTPTransaction::SendEventL()</code></a>, which can itself leave. If it does leave, you may be forced to call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2E673024-239B-3965-8880-C47B7CC24EF6.html#GUID-BAED8ED4-CFC0-3CF4-88E1-784F7C68C219"><code class="apiname">RHTTPTransaction::Fail()</code></a>, which cancels the transaction and sends an <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-518CC5C3-1CE1-316E-9688-93DB12E58EB3.html#GUID-623B9859-6DEC-313F-8D07-0B1F3C93E1BD"><code class="apiname">THTTPEvent::EUnrecoverableError</code></a> message outwards. </p> <p>It is important to note that a filter object is per-session, and so might be shared by several transactions. This means that if you have a per-transaction state that you need to store, it must be stored in the transaction's property set. Do <em>not</em> store any per-transaction information in the filter object. </p> </div> </div></div></div><div class="footer"><p class="metadata">Last updated December 14th, 2009</p><hr /><div class="copy">Â© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-AA2A730E-A7C9-5647-AD42-11C3BAF4C38D.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:59:26 GMT -->
</html>