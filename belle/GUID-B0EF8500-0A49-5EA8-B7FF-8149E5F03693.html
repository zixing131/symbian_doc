
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-B0EF8500-0A49-5EA8-B7FF-8149E5F03693.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:05:21 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="How to use the SIP Client API" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-6425B722-4095-56E3-9198-70BA3E06C617" /><meta name="DC.Relation" scheme="URI" content="GUID-057F1F82-56AF-5696-853E-79196A3D567E" /><meta name="DC.Relation" scheme="URI" content="GUID-E339A683-94E2-54E8-BB2B-286B11B0FCE3" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-B0EF8500-0A49-5EA8-B7FF-8149E5F03693" /><meta name="DC.Language" content="en" /><title>How to use the SIP Client API </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-B0EF8500-0A49-5EA8-B7FF-8149E5F03693">How to use the SIP Client API</h1><div><div id="GUID-DC93FFFF-1981-5EA1-9B88-E3CC56CCCEB7"><h3 class="section-title">Protocols</h3> <p>The following sections describe how to do the following: </p> <ul><li id="GUID-7E5B3D7B-45E4-543A-8219-A5C1C0D25913"><a name="GUID-7E5B3D7B-45E4-543A-8219-A5C1C0D25913"><!-- --></a><p><a href="#GUID-AFD6AB5D-1B1B-53CB-ABC7-4585D9A91CE8">Starting the SIP Client</a> </p> </li> <li id="GUID-39810F58-A7EB-5F1C-96C6-4A2E62B263EB"><a name="GUID-39810F58-A7EB-5F1C-96C6-4A2E62B263EB"><!-- --></a><p><a href="#GUID-42784C1C-600A-53AE-9AEB-463EBF34C636">Closing SIP Client</a> </p> </li> <li id="GUID-544748CF-463C-546B-A291-08D1C2887C01"><a name="GUID-544748CF-463C-546B-A291-08D1C2887C01"><!-- --></a><p><a href="#GUID-AC90094E-BF4E-5C2B-81B2-EF9BF5603BA2"> Sending a SIP request</a> </p> </li> <li id="GUID-F71538DD-111C-5DFE-88A3-2E025E05429C"><a name="GUID-F71538DD-111C-5DFE-88A3-2E025E05429C"><!-- --></a><p><a href="#GUID-5E5EC61F-5AB3-55F6-9AB0-463D5D0876DA">Receiving a SIP request</a> </p> </li> <li id="GUID-CC881957-ACE4-597F-85B4-1859886B61E7"><a name="GUID-CC881957-ACE4-597F-85B4-1859886B61E7"><!-- --></a><p><a href="#GUID-820D689F-6404-5E40-AAC2-A45ABECDBADC">Receiving a SIP request and creating a session</a> </p> </li> <li id="GUID-5FBBC17B-D4B7-51F3-8560-13F6730010B6"><a name="GUID-5FBBC17B-D4B7-51F3-8560-13F6730010B6"><!-- --></a><p><a href="#GUID-109B933C-1063-577F-9A58-BA809869A0DF">Registration</a> </p> </li> <li id="GUID-8E35F949-CC67-546C-9899-3A2C1BF8BBC1"><a name="GUID-8E35F949-CC67-546C-9899-3A2C1BF8BBC1"><!-- --></a><p><a href="#GUID-E683488B-B7EA-5215-8476-8C39950AC21B">Creating a dialog with INVITE</a> </p> </li> <li id="GUID-3246EFA2-48AB-5D54-9E5C-E8095886FCCD"><a name="GUID-3246EFA2-48AB-5D54-9E5C-E8095886FCCD"><!-- --></a><p><a href="#GUID-E4E6E0C2-7B0F-51AA-B1E3-282E8F728EDC"> Generating a '100 SIP response'</a> </p> </li> <li id="GUID-6E4E101D-8638-5AD8-B105-D5FD5D9ED6E5"><a name="GUID-6E4E101D-8638-5AD8-B105-D5FD5D9ED6E5"><!-- --></a><p><a href="#GUID-C1ED4FC7-5DEB-5C5B-AE82-549D4577A9A9">Responding to a CANCEL request</a> </p> </li> <li id="GUID-010BA345-B521-54AC-8208-B0C5969BA87D"><a name="GUID-010BA345-B521-54AC-8208-B0C5969BA87D"><!-- --></a><p><a href="#GUID-CB27D3C3-D28B-5081-B201-8C10DE60CF25">Sending a SIP request and responding to a HTTP Digest challenge</a> </p> </li> <li id="GUID-4A8CF777-7379-5AF6-90A9-B15480B2E67E"><a name="GUID-4A8CF777-7379-5AF6-90A9-B15480B2E67E"><!-- --></a><p><a href="#GUID-B882D001-CDE9-579F-8DDE-C087D8707C2E">Notification of a failed refresh</a> </p> </li> <li id="GUID-79F2A3B3-2CC0-52ED-903B-3D4855E4A274"><a name="GUID-79F2A3B3-2CC0-52ED-903B-3D4855E4A274"><!-- --></a><p><a href="#GUID-DDD7FDBD-FBC9-5111-BE71-A71E6CCEFB2A">Error handling</a> </p> </li> <li id="GUID-AB416C57-9986-54AD-BB8A-7240D8FBCD7D"><a name="GUID-AB416C57-9986-54AD-BB8A-7240D8FBCD7D"><!-- --></a><p><a href="#GUID-0FC8038A-64AE-5E98-A9F9-ADBC6F05DF2B">Refreshing a Connection</a> </p> </li> </ul> </div> <div id="GUID-AFD6AB5D-1B1B-53CB-ABC7-4585D9A91CE8"><h3 class="section-title">Starting the SIP Client</h3> <p>To start the SIP Client: </p> <ol id="GUID-62B966F0-272C-5A03-9364-7685412436B0"><li id="GUID-626ACA6E-6CA9-5A3C-8582-EDEE7AE823D0"><a name="GUID-626ACA6E-6CA9-5A3C-8582-EDEE7AE823D0"><!-- --></a><p>Create an instance of the CSIP class. The CSIP class creates a CSIP object and implements the callback functions defined by MSIPObserver. The CSIP object connects the client to a shared server. </p> <p> <strong>Note:</strong> The server is started if it is not active. This may take a short time while the server side resources are created and initialised. </p> </li> <li id="GUID-BEE4CC97-50C6-5681-ACEB-180CA59B0CD3"><a name="GUID-BEE4CC97-50C6-5681-ACEB-180CA59B0CD3"><!-- --></a><p>Create an instance of the CSIPConnection class to use an IAP. The CSIPConnection class must implement the callback functions defined by MSIPConnectionObserver. The CSIPConnection class creates CSIPConnection object. The CSIPConnection object forms a sub-session between the client and the server. </p> </li> <li id="GUID-1B0B51F8-37DF-5495-AEEC-F49A6C7EE947"><a name="GUID-1B0B51F8-37DF-5495-AEEC-F49A6C7EE947"><!-- --></a><p>Call the CSIPConnection::NewL() function to create an active connection. The <code class="codeph">CSIPConnection::EActive</code> state indicates that the object can be used to send SIP messages and create registrations and dialogs. The current state is asked by calling CSIPConnection::State(). The <code class="codeph">MSIPConnectionObserver::ConnectionStateChanged(CSIPConnection::
                EActive)</code> callback function is called. </p> </li> </ol> <p>The following illustration shows the sequence of events involved in starting the SIP Client API. </p> <div class="figure" id="GUID-86E80D26-544B-587A-B2FD-B15CF44E47B4"><img src="GUID-15CAB5AF-CAA5-5D1B-9236-7874BF944484_d0e418552_href.png" /></div> </div> <div id="GUID-42784C1C-600A-53AE-9AEB-463EBF34C636"><h3 class="section-title">Closing the SIP Client</h3> <p>To close the SIP Client: </p> <ul><li id="GUID-9FA5F4F3-9403-5256-9B80-939042BB2A8A"><a name="GUID-9FA5F4F3-9403-5256-9B80-939042BB2A8A"><!-- --></a><p>Delete the CSIP object to close the connection to the SIP server. </p> </li> <li id="GUID-2C9F26A2-D5D1-585A-87C8-222A57D05F2F"><a name="GUID-2C9F26A2-D5D1-585A-87C8-222A57D05F2F"><!-- --></a><p>Delete the CSIPConnection object to close the sub-session between the client and the server. </p> </li> <li id="GUID-78A46553-52E1-57E3-BB0A-AEC70FC36F0F"><a name="GUID-78A46553-52E1-57E3-BB0A-AEC70FC36F0F"><!-- --></a><p>When the connection has been closed, operations on objects that depend on the connection fail with the <code class="codeph">KErrSIPResourceNotAvailable</code> error code. </p> </li> </ul> <p>For example, if an application has CSIPConnection and CSIPRegistrationBinding objects, and it deletes the CSIPConnection object, then subsequent attempts to use the <code class="codeph">CSIPRegistrationBinding</code> object fails. This is because <code class="codeph">CSIPRegistrationBinding</code> cannot communicate with the server side of the SIP stack without the <code class="codeph">CSIPConnection</code> object. </p> <p>The following illustration shows the order for deleting SIP Client API objects. </p> <div class="figure" id="GUID-5C5F0C8E-76BD-56CC-AA9E-BECF035D1A9F"><img src="GUID-A9BFB95C-E2B0-5CD0-8B39-C448E3C81400_d0e418618_href.png" /></div> </div> <div id="GUID-AC90094E-BF4E-5C2B-81B2-EF9BF5603BA2"><h3 class="section-title"> Sending a SIP request</h3> <p>To send a SIP request: </p> <ul><li id="GUID-C92F9ADF-1BF5-5057-8851-0940E67A3C6A"><a name="GUID-C92F9ADF-1BF5-5057-8851-0940E67A3C6A"><!-- --></a><p>Create a CSIPRequestElements object and enter the required fields of the request. </p> </li> <li id="GUID-E69DA3E7-5C13-5D10-BD82-1D37AEE0EE8A"><a name="GUID-E69DA3E7-5C13-5D10-BD82-1D37AEE0EE8A"><!-- --></a><p>Call the <code class="codeph">CSIPConnection::SendRequestL(CSIPRequestElements*)</code> function to take control of the CSIPRequestElements objects and communicate the request to the server side of the SIP stack. </p> <p>  CSIPConnection creates a CSIPClientTransaction object and returns it to the application. </p> </li> </ul> <p> <strong>Note:</strong> <code class="codeph">SendRequestL()</code> starts the server side processing of sending the MESSAGE request. This task takes time as address resolving and socket operations are done only after the <code class="codeph">SendRequestL()</code> call is returned. If an error occurs after <code class="codeph">SendRequestL()</code> returns, then the error is communicated to the application through one of the MSIPConnectionObserver::ErrorOccured() callback functions. An example of such a failure is failure to resolve the address. When <code class="codeph">SendRequestL()</code> returns, the MESSAGE request is not yet sent to the network, and is being processed on the server side of the SIP stack. </p> <p>After <code class="codeph">SendRequestL()</code> returns and the sending of a MESSAGE request is in progress on the shared server, there is no way for the application to cancel that operation. This also applies to other operation types. However the CSIPClientTransaction::CancelL() function is used to send a CANCEL request after the application sends an INVITE request. </p> <p>When the SIP response is received from the server side, the CSIPConnection object: </p> <ol id="GUID-0DB00054-27E8-57BF-8BB0-7F8231C7627B"><li id="GUID-D207CF42-5B04-5625-8CF8-4EEAD3451542"><a name="GUID-D207CF42-5B04-5625-8CF8-4EEAD3451542"><!-- --></a><p>creates a CSIPResponseElements object to represent the SIP response </p> </li> <li id="GUID-7131D953-EFF6-5D31-B20F-64B56C968368"><a name="GUID-7131D953-EFF6-5D31-B20F-64B56C968368"><!-- --></a><p>attaches it to the CSIPClientTransaction object </p> </li> <li id="GUID-72C682B2-05BE-58ED-B743-0554C9476CC2"><a name="GUID-72C682B2-05BE-58ED-B743-0554C9476CC2"><!-- --></a><p>notifies the application through a call to one of the MSIPConnectionObserver:: IncomingResponse() callback functions. </p> </li> </ol> <p>The application determines the kind of response received by accessing the CSIPResponseElements object through CSIPClientTransaction. As the response is provisional, the application does not delete the <code class="codeph">CSIPClientTransaction</code> object. A '200 response' is received later, and the application then deletes the <code class="codeph">CSIPClientTransaction</code> object. </p> <p>Then, create a CSIPResponseElements object to represent the SIP response, attach it to <code class="codeph">CSIPClientTransaction</code> and notify the application with <code class="codeph">MSIPConnectionObserver::
          IncomingResponse</code>. </p> <p>The following illustration shows the sequence of events involved in sending a MESSAGE request and receiving two responses to it. </p> <div class="figure" id="GUID-6724EF0B-9B98-5225-BABA-3967A5065711"><img src="GUID-7712BAB3-5F48-5A28-9EA9-104D8B4A0431_d0e418764_href.png" /></div> </div> <div id="GUID-5E5EC61F-5AB3-55F6-9AB0-463D5D0876DA"><h3 class="section-title">Receiving a SIP request</h3> <p>A standalone SIP request is received through an existing CSIPConnection object. The CSIPConnection creates CSIPRequestElements and CSIPServerTransaction objects before notifying the application through the MSIPConnectionObserver::IncomingRequest() callback function. The CSIPRequestElements and CSIPServerTransaction represent the incoming SIP request </p> <p>The CSIPServerTransaction object is passed to the CSIPRequestElements object through the callback function. The application retrieves information about the request from the CSIPServerTransaction object. </p> <p>To send a response, the application creates a CSIPResponseElements object and passes it to CSIPServerTransaction::SendResponseL(). This passes the response to the server side for further processing. When <code class="codeph">SendResponseL()</code> is returned, the application no longer needs the CSIPServerTransaction object and deletes it. </p> <p>The following illustration shows the sequence of events involved in receiving a MESSAGE request and sending a response to it. </p> <div class="figure" id="GUID-8C9A8944-1150-52E2-A031-BA65F16191F4"><img src="GUID-1158BDD3-69F7-5892-9887-FAE30110E33C_d0e418839_href.png" /></div> </div> <div id="GUID-820D689F-6404-5E40-AAC2-A45ABECDBADC"><h3 class="section-title">Receiving a SIP request and creating a session</h3> <p>The SIP stack receives a SIP INVITE request from the network acting as a User Agent Server (UAS) and creates an invite server transaction for the received request. The SIP stack sends a '100 SIP response' to the remote UA. After comparing the received request with the stored application capabilities, the SIP stack routes the received INVITE request to the chosen application. </p> <p>The application creates a CSIPInviteDialogAssoc object and the SIP stack creates an instance of CSIPDialog. The application sends a '200 SIP response' to the remote UA. The remote UA acknowledges the '200 SIP' response with ACK and creates a SIP session is between the local and remote UA. </p> <p>The following illustration shows the sequence of events involved in receiving a SIP request and creating a SIP dialog. </p> <div class="figure" id="GUID-8A8D96E1-99DC-5F11-847A-9D407212CA6E"><img src="GUID-C64D200D-32A9-5F50-ACF1-4D93DDD0B0A4_d0e418864_href.png" /></div> </div> <div id="GUID-109B933C-1063-577F-9A58-BA809869A0DF"><h3 class="section-title">Registration</h3> <p>An application creates a CSIPRefresh object to initiate a registration. It then creates a CSIPRegistrationBinding object, passing <code class="codeph">CSIPRefresh</code> to it. </p> <p> <strong>Note:</strong> It is not mandatory to create a <code class="codeph">CSIPRefresh</code> object. It is required if the registration is to be refreshed by the SIP stack. </p> <p>After the <code class="codeph">CSIPRegistrationBinding</code> object exists, the application initiates the registration process by calling <code class="codeph">RegisterL()</code> on the <code class="codeph">CSIPRegistrationBinding</code> object. <code class="codeph"></code> <code class="codeph">CSIPRegistrationBinding</code> forms a REGISTER request and communicates it to the server side of the SIP stack, it instantiates the CSIPClientTransaction object and returns it to the application. </p> <p>When the '200 SIP response' is received from the server side, CSIPConnection creates the CSIPResponseElements object to contain the response, and then routes the response to CSIPRegistrationBinding. CSIPRegistrationBinding attaches the response to CSIPClientTransaction. The application is informed about the response through one of the MSIPConnectionObserver::IncomingResponse() callback functions. </p> <p>The application does not require the CSIPClientTransaction object and can delete it. The <code class="codeph">IsContextActive()</code> finds out if the registration is successful. </p> <p>The following illustration shows the sequence of events involved in registering with a refresh and receiving a '200 OK response'. </p> <div class="figure" id="GUID-7F489E97-2ADE-5753-A03B-5600E4BD1C55"><img src="GUID-02521DB0-53C4-55D5-856F-BD478E134B73_d0e418956_href.png" /></div> </div> <div id="GUID-45BEF04F-64A3-5B29-8CE4-8B1F5CA0E64F"><h3 class="section-title">Configuring the registration</h3> <p>When registering an SIP connection, applications have two options to configure the registration : outbound proxy caching and expiration value removal. To set each of these options, call CSIPRegistrationBinding::SetProperty() with the corresponding property constant, as explained below. </p> <p>The SIP stack resolves the IP address of the outbound proxy during registration. The default behavior is to resolve the address again for each SIP message sent using this registration context. However, you can also cache the address to optimise network traffic. If you set KSIPCacheOutboundProxyIP property to <code class="codeph">ETrue</code>, the SIP stack reuses the proxy address that was resolved during registration. The proxy address is refreshed by successful REGISTER transactions, which always perform a DNS query. </p> <p>By default, the SIP stack sends the expiration value in the REGISTER request. In the '200 OK' answer to a REGISTER message, the registrar returns an expiration value that may be different from the value that was sent. The SIP stack validates the returned expiration value against the minimum and maximum expiration values: if the returned expiration value is out of range, the SIP stack uses the minimum value or the maximum value. </p> <ul><li id="GUID-478291AE-D709-5AF1-AE4A-F1C115F8BE7C"><a name="GUID-478291AE-D709-5AF1-AE4A-F1C115F8BE7C"><!-- --></a><p>The minimum expiration value is 30 seconds, to reduce network activity and battery consumption. </p> </li> <li id="GUID-A0C7C631-F4CF-5CC0-BAA7-236C939E87C8"><a name="GUID-A0C7C631-F4CF-5CC0-BAA7-236C939E87C8"><!-- --></a><p>The maximum expiration value is the expiration value that you specify for the REGISTER request. By default, the maximum expiration value is 3600 seconds, to protect the application from DOS attacks that provide '200 OK' responses with a very high expiration value. </p> </li> </ul> <p>If you set KSIPSendWithExpires to <code class="codeph">EFalse</code>, the SIP stack does not send the application's expiration value in the REGISTER message. </p> </div> <div id="GUID-E683488B-B7EA-5215-8476-8C39950AC21B"><h3 class="section-title">Creating a dialog with INVITE</h3> <p>To create a dialog with INVITE an application creates CSIPInviteDialogAssoc and CSIPMessageElements objects. The application must enter the relevant SIP headers in the CSIPMessageElements  object before passing it to CSIPInviteDialogAssoc using the CSIPInviteDialogAssoc::SendInviteL() function. </p> <p> CSIPInviteDialogAssoc then forms an INVITE request and communicates it to the server side of the SIP stack. It then creates a CSIPClientTransaction object, and returns it to the application. </p> <p>When the server sends '180 response', the CSIPConnection creates a CSIPResponseElements object to contain the response, and then routes the response to CSIPDialog. <code class="codeph">CSIPDialog</code> attaches the response to CSIPClientTransaction. The application is informed about the receipt of the '180 response' through a call to one of the MSIPConnectionObserver:: IncomingResponse() callback functions. </p> <p>When the '200 response' is received, processing similar to '180 response' occurs. Then the application responds by sending an ACK request. This is done by invoking the CSIPInviteDialogAssoc::SendAckL() function, which forms the ACK request and sends it to the server side of the SIP stack. </p> <p>The INVITE request might fork at a proxy, so the server side of the SIP stack waits for several possible responses. When the forking is does not happen, the server side of the SIP stack sends an <code class="codeph">InviteCompleted</code> event. The SIP Client API forwards the <code class="codeph">InviteCompleted</code> event to the application, indicating that the application can now delete the CSIPClientTransaction. </p> <p>The following figure shows the sequence of events involved in sending an INVITE, receiving a response and sending an ACK. </p> <div class="figure" id="GUID-3AE23155-63D4-5948-855E-9D44F48E4D11"><img src="GUID-C8D04D54-D391-5505-9E80-596589410179_d0e419094_href.png" /></div> </div> <div id="GUID-E4E6E0C2-7B0F-51AA-B1E3-282E8F728EDC"><h3 class="section-title"> Generating a '100 SIP response'</h3> <p>The SIP stack generates a '100 response' automatically when it receives an <code class="codeph">INVITE</code> request from the network. Applications are not allowed to send '100 responses'. </p> </div> <div id="GUID-C1ED4FC7-5DEB-5C5B-AE82-549D4577A9A9"><h3 class="section-title">Responding to a CANCEL request</h3> <p>When the SIP stack receives a CANCEL request from the network, it automatically responds to it. CANCEL requests are never passed to an application. </p> <p>If the SIP stack: </p> <ul><li id="GUID-05B62303-9453-5E42-8E2A-6D50A5857312"><a name="GUID-05B62303-9453-5E42-8E2A-6D50A5857312"><!-- --></a><p>does not find a matching transaction for a CANCEL request, it automatically generates a '481 response'. </p> </li> <li id="GUID-69DBD19D-1871-57C5-AF95-8858A92BE6C5"><a name="GUID-69DBD19D-1871-57C5-AF95-8858A92BE6C5"><!-- --></a><p>finds a matching transaction for a CANCEL request, it automatically generates a '200 response'. </p> </li> <li id="GUID-C806FF70-7EBD-5D06-989E-971E2E7589DD"><a name="GUID-C806FF70-7EBD-5D06-989E-971E2E7589DD"><!-- --></a><p>finds a matching INVITE server transaction that is in the <code class="codeph">Proceeding</code> state (that is a final response is not yet sent), it also automatically generates a '487 response' to the INVITE transaction. </p> </li> </ul> <p>After these actions are complete, the SIP stack informs the application by calling the MSIPConnectionObserver::InviteCanceled() callback function. </p> </div> <div id="GUID-CB27D3C3-D28B-5081-B201-8C10DE60CF25"><h3 class="section-title">Sending a SIP request and responding to a HTTP Digest challenge</h3> <p>A SIP server in the signalling chain challenges any SIP request initiated by the application with an HTTP Digest challenge by responding with a '401 SIP response', '407 SIP response' or a '494 SIP response'. The responses contain details of the challenge. These responses are never passed directly to the application. Instead, they are passed to the application through a call to the callback function MSIPHttpDigestChallengeObserver::ChallengeReceived(). </p> <p>To enable an application to respond to a challenge, it must: </p> <ul><li id="GUID-69B100E7-A67F-5F0C-B886-1B0FAE9DBEB4"><a name="GUID-69B100E7-A67F-5F0C-B886-1B0FAE9DBEB4"><!-- --></a><p>create a CSIPHttpDigest object </p> </li> <li id="GUID-A58199C3-57A0-536F-8EC2-76A29F3003DA"><a name="GUID-A58199C3-57A0-536F-8EC2-76A29F3003DA"><!-- --></a><p>provide an implementation of the callback function MSIPHttpDigestChallengeObserver::ChallengeReceived() . </p> </li> </ul> <p>The application can either accept or reject the challenge: </p> <ul><li id="GUID-8EFD6F96-73E8-594E-9971-95DB3DA5B5ED"><a name="GUID-8EFD6F96-73E8-594E-9971-95DB3DA5B5ED"><!-- --></a><p>If it accepts the challenge, the callback function must call CSIPHttpDigest::SetCredentialsL(), specifying the username, password, and the realm passed to the callback function. </p> <p>Then, SIP stack re-sends the original SIP request with the HTTP Digest response. </p> </li> <li id="GUID-C1A1BCCC-7E0C-5B4F-A0D9-EDC52F081D59"><a name="GUID-C1A1BCCC-7E0C-5B4F-A0D9-EDC52F081D59"><!-- --></a><p>If it rejects the challenge, the callback function must call CSIPHttpDigest::IgnoreChallenge(), specifying the realm passed to the callback function. </p> <p>Then, SIP stack calls the callback function MSIPConnectionObserver::ErrorOccured(), by passing the error code KErrSIPForbidden. </p> </li> </ul> <p>If an application does not want to receive the HTTP Digest challenge then it must not create a CSIPHttpDigest object. In this event, the SIP stack calls the callback function MSIPConnectionObserver::ErrorOccured(), passing the error code KErrSIPForbidden. </p> <p> <strong>Note:</strong> </p> <ul><li id="GUID-A028B39A-292E-5556-B4A0-AF801F6131F3"><a name="GUID-A028B39A-292E-5556-B4A0-AF801F6131F3"><!-- --></a><p>If an application uses the SIP Profile Agent for SIP registration, the SIP Profile Agent handles the HTTP Digest challenges related to the registration procedure according to the SIP profile information. </p> </li> <li id="GUID-19A777A8-E8D0-54F4-A59E-53550B6A802C"><a name="GUID-19A777A8-E8D0-54F4-A59E-53550B6A802C"><!-- --></a><p>The SIP stack maintains a HTTP Digest cache which stores username and password pairs for realms. If the username and password have been configured for a proxy, or if the application has already provided them after being asked through a MSIPHttpDigestChallengeObserver::ChallengeReceived() call, then the SIP stack uses them to answer subsequent challenges for a matching realm automatically. </p> <p>For example, if the application uses a SIP Profile whose proxy is configured with HTTP Digest passwords and then sends an INVITE, it does not need to provide the passwords for the proxy as the SIP stack gets it from the HTTP Digest cache. </p> </li> </ul> </div> <div id="GUID-B882D001-CDE9-579F-8DDE-C087D8707C2E"><h3 class="section-title">Notification of a failed refresh</h3> <p>The following example shows how an application is notified when a refresh request within a dialog terminates after an error occurs. In this example the application sends a SUBSCRIBE request with refresh, and receives a <code class="codeph">2xx</code> class response. The SIP stack periodically sends a refreshed SUBSCRIBE message. After successfully refreshed SUBSCRIBE requests, the remote server responds with a '481 response', and the application receives the following callback: </p> <pre class="codeblock">MSIPConnectionObserver::ErrorOccured(TInt aError, CSIPDialogAssocBase&amp; aDialogAssoc)</pre> <p>If the value of <code class="codeph">aError</code> is KErrSIPTerminatedWithResponse, then the actual SIP response causing the refresh to end can be found as follows: </p> <ul><li id="GUID-76291322-B9F0-55D3-A019-73A9040F2652"><a name="GUID-76291322-B9F0-55D3-A019-73A9040F2652"><!-- --></a><p>Check that <code class="codeph">aDialogAssoc.Type()</code> returns <code class="codeph">"SUBSCRIBE"</code>. </p> </li> <li id="GUID-52B18DCF-2308-52A9-AB13-5920042C2E5D"><a name="GUID-52B18DCF-2308-52A9-AB13-5920042C2E5D"><!-- --></a><p>Call the function with the following signature to get the refresh instance (CSIPRefresh object): </p> <pre class="codeblock">const CSIPRefresh* CSIPSubscribeDialogAssoc::SIPRefresh() const</pre> </li> <li id="GUID-6AB4677A-19F9-5CD3-8DAB-E1A242A98D54"><a name="GUID-6AB4677A-19F9-5CD3-8DAB-E1A242A98D54"><!-- --></a><p>Use the CSIPRefresh object to get the associated transaction by calling the following function: </p> <pre class="codeblock">const CSIPClientTransaction* CSIPRefresh::SIPTransaction() const</pre> <p> <strong>Note:</strong> The returned CSIPClientTransaction object is not similar to the one returned from the call to <code class="codeph">SendSubscribeL(),</code> that the application originally used to send the SUBSCRIBE request. </p> </li> <li id="GUID-D1B61B14-7B99-59EA-9FDD-5ECEB839C4DA"><a name="GUID-D1B61B14-7B99-59EA-9FDD-5ECEB839C4DA"><!-- --></a><p>Call the following function to get the SIP response: </p> <pre class="codeblock">const CSIPResponseElements* CSIPClientTransaction::ResponseElements() const</pre> </li> </ul> </div> <div id="GUID-DDD7FDBD-FBC9-5111-BE71-A71E6CCEFB2A"><h3 class="section-title">Error handling</h3> <p>Errors are passed to an application by calling the callback functions or by leaving. For more information, see <a href="GUID-E5A83EF3-948B-5729-A2CD-3644E803520B.html">Cleanup support overview</a>. If an error occurs during the synchronous part of an operation is initiated by the application, functions leave with an error code. If an error occurs during the asynchronous processing stage, the error is passed to the application through one of the MSIPConnectionObserver::ErrorOccured() callback functions. </p> <p>There are several overloaded variants of <code class="codeph">ErrorOccured()</code> functions. Each of them takes the error code and reference to the SIP Client API object that encountered the error: </p> <ul><li id="GUID-2734ECF0-1751-5AB8-BFE3-425965D01CF0"><a name="GUID-2734ECF0-1751-5AB8-BFE3-425965D01CF0"><!-- --></a><p>A call to the variants of <code class="codeph">ErrorOccured()</code> taking a CSIPTransactionBase or CSIPClientTransaction parameter means that transaction has entered the state CTransactionBase::ETerminated. </p> </li> <li id="GUID-C45D4A2D-F175-542B-92BF-211E1673F3F1"><a name="GUID-C45D4A2D-F175-542B-92BF-211E1673F3F1"><!-- --></a><p>A call to the variant of <code class="codeph">ErrorOccured()</code> taking a CSIPRegistrationBinding parameter means that the registration context is no longer active, that is <code class="codeph">CSIPRegistrationBinding::IsContextActive() == EFalse</code>. </p> <p>If the registration was being refreshed, then the refresh has also ended and its state is CSIPRefresh::ETerminated. </p> </li> </ul> <p>If the callback function MSIPConnectionObserver::ConnectionStateChanged() is called and the <code class="codeph">aState</code> parameter is either CSIPConnection::EInactive or CSIPConnection::EUnavailable, then all dialogs, registrations, and standalone transactions using the CSIPConnection are terminated. </p> <p>To avoid an overload of callback calls in this type of situation, calls to <code class="codeph">ErrorOccured()</code> for the individual dialog, registration and transaction objects are not sent to the application. </p> <p>When the connection state changes, the <code class="codeph">MSIPConnectionObserver::ConnectionStateChanged()</code> callback function does not provide a reason. Call CSIPConnection::GetConnectionError() to get details about the connection error that caused the change. </p> </div> <div id="GUID-0FC8038A-64AE-5E98-A9F9-ADBC6F05DF2B"><h3 class="section-title">Refreshing a Connection</h3> <p>To refresh a connection, do the following steps: </p> <ol id="GUID-368431B7-E9FB-56E7-A45F-01B686DBECAA"><li id="GUID-97E972C7-E839-5942-A487-48A9FD1EEC0E"><a name="GUID-97E972C7-E839-5942-A487-48A9FD1EEC0E"><!-- --></a><p>Start the connection on the desired IAP. </p> </li> <li id="GUID-35157131-E6EA-5EB2-8773-33832C45F46E"><a name="GUID-35157131-E6EA-5EB2-8773-33832C45F46E"><!-- --></a><p>Monitor the status of the connection using the MSIPConnectionObserver::ConnectionStateChanged(CSIPConnection::TState
                aState) function. </p> </li> <li id="GUID-85CDAB12-933A-5748-B2B8-33971F58B7B4"><a name="GUID-85CDAB12-933A-5748-B2B8-33971F58B7B4"><!-- --></a><p>If the connection is inactive, notify the <code class="codeph">EInactive</code> state to the application through MSIPConnectionObserver::ConnectionStateChanged() function that is, if (CSIPConnection::TState == EInactive), then send a RefreshConnection() function to make it active. </p> <p> <strong>Note:</strong> This requires a bearer monitor on that IAP to which a refresh request is sent. </p> </li> <li id="GUID-49A770C0-0992-5D27-B8A6-4D68E4B90E09"><a name="GUID-49A770C0-0992-5D27-B8A6-4D68E4B90E09"><!-- --></a><p>Any changes to the state of the connection is notified through MSIPConnectionObserver::ConnectionStateChanged(). </p> </li> </ol> <p>The following sequence diagram shows how a client refreshes a connection. </p> <div class="figure" id="GUID-B3D9E694-31F8-59AA-A722-BE6F9C0D5E89"><img src="GUID-A50BBBE2-2E23-5AEE-BF53-9EF54FD7F00E_d0e419505_href.jpg" /></div> <p>The following example code describes how to refresh a connection. </p> <pre class="codeblock">// It is assumed that the connection is started and is in an Inactive state that is, 
// (CSIPConnection::TState == EInactive)

// Refresh the IAP ID of the connection by sending a Refresh Request to the Bearer monitor of the IAP
CSIPConnection:: RefreshConnection()

// Note: The application is notified of the changes in the state of the connection through the 
// ConnectionStateChanged() function of MSIPConnectionObserver Interface.</pre> </div> </div></div></div><div class="footer"><p class="metadata">Last updated November 11th, 2009</p><hr /><div class="copy">Â© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-B0EF8500-0A49-5EA8-B7FF-8149E5F03693.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:05:31 GMT -->
</html>